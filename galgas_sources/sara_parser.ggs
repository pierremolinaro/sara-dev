#---------------------------------------------------------------------------*#                                                                           *#   S Y N T A X                                                             *#                                                                           *#---------------------------------------------------------------------------*syntax sara_parser :import lexique sara_scanner in "sara_scanner.ggs" ;import semantics sara_semantics in "sara_semantics.ggs" ;nonterminal <start_symbol> ;nonterminal <modalcompadd_definition>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap variablesMap  !@M_modesMap outModeMap  !@ListForModes outInclusionList;nonterminal <modalcompsub_definition>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap variablesMap  !@M_modesMap outModeMap  !@ListForModes outExclusionList;nonterminal <explicit_automaton>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap outputVariableMap  !@AC_machineDefinition outDefinition;nonterminal <definition_expression>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap outputVariableMap  !@AC_machineDefinition outDefinition;nonterminal <definition_expression_term>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap outputVariableMap  !@AC_machineDefinition outDefinition;nonterminal <definition_expression_factor>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap outputVariableMap  !@AC_machineDefinition outDefinition;nonterminal <component>  ?!@M_machinesMap ioMachinesMap  ?!@L_jobList ioJobList;nonterminal <io_bool_expression>  ?!@M_machinesMap ioMachinesMap
  ?!@M_variablesMap ioVarMap  !@AC_boolExpression outExpression;nonterminal <io_and_expression>   ?!@M_machinesMap ioMachinesMap
  ?!@M_variablesMap ioVarMap  !@AC_boolExpression outExpression;nonterminal <io_primary>   ?!@M_machinesMap ioMachinesMap
  ?!@M_variablesMap ioVarMap  !@AC_boolExpression outExpression;action performComputations  ?!@L_jobList ioJobList;

#---------------------------------------------------------------------------*

#list @myList {
#  @string mString ;
#  @uint mUInt ;
#}

#---------------------------------------------------------------------------*rule <start_symbol>:  @L_jobList componentsMap [emptyList] ;  @M_machinesMap machinesMap [emptyMap] ;  repeat    <component> !?machinesMap !?componentsMap ;  while  end repeat ;  action performComputations !?componentsMap ;
##--- Build a list
#  @myList aList [listWithValue !"b" !2] ; # Using ‘listWithValue' constructor
#  aList := aList . [@myList listWithValue !"c" !3] ; # Using ‘.' operator as list concatenation
#  [!?aList prependValue !"a" !1] ;
##--- Display the list: ("a", 1), ("b", 2), ("c", 3)
#  message "--- Display the list: ('a', 1), ('b', 2), ('c', 3)\n" ;
#  log aList ;
##--- Display the first: ("a", 1)
#  message "--- Display the first: ('a', 1)\n" ;
#  @string s ;
#  @uint n ;
#  [aList first ?s ?n] ;
#  log s, n ;
##--- Display the last: ("c", 3)
#  message "--- Display the last: ('c', 3)\n" ;
#  [aList last ?s ?n] ;
#  log s, n ;
##--- Using popFirst
#  message "--- Using popFirst: display('a', 1), ('b', 2), ('c', 3)\n" ;
#  @myList aListCopy := aList ;
#  loop [aListCopy length] + 1:
#  while [aListCopy length] > 0 do
#    [!?aListCopy popFirst ?s ?n] ;
#    log s, n ;
#  end loop ;
##--- Using popLast
#  message "--- Using popLast: display('c', 3), ('b', 2), ('a', 1)\n" ;
#  loop [aList length] + 1:
#  while [aList length] > 0 do
#    [!?aList popLast ?s ?n] ;
#    log s, n ;
#  end loop ;

##--- Remove
#  @stringset allKeys := [machinesMap allKeys] ;
#  log allKeys ;
#  foreach allKeys (@string kKey) :
#    @lstring s [new !kKey !here] ;
#    log kKey ;
#    [!?machinesMap removeKey !s ?3*] ;
#  end foreach ;
#  log machinesMap ;

##--- Make directory test
#  @string s := [[@string stringWithSourceFilePath] stringByDeletingLastPathComponent] . "/a/b/c/d" ;
#  log s ;
#  [s makeDirectory] ;
end rule ; #---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap ioMachinesMap  ?!@L_jobList ioJobList:  @M_variablesMap variablesMap [emptyMap] ;  @M_stateMap statesMap [emptyMap] ;  @L_stateDefinition stateDefinitionList [emptyList] ;#--- Machine name  $check$ ;  @lstring machineName ;  $machineIdf$ ? machineName ;  $;$ ;#--- Insert machine into machine map  @luint machineIndex ;  [ioMachinesMap searchKeyGetIndex !machineName ?machineIndex ?* ?* ?*] ;#--- Insert into component map  @AC_job job := [@C_machineCheck new !machineIndex !false] ; ioJobList += !job ;end rule ;

#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap ioMachinesMap  ?!@L_jobList ioJobList:  @M_variablesMap variablesMap [emptyMap] ;  @M_stateMap statesMap [emptyMap] ;  @L_stateDefinition stateDefinitionList [emptyList] ;#--- Machine name  $checkidentical$ ;  @lstring machineName1 ;  $machineIdf$ ? machineName1 ;  $,$ ;  @lstring machineName2 ;  $machineIdf$ ? machineName2 ;  $;$ ;#--- Insert machine into machine map  @luint machineIndex1 ;  [ioMachinesMap searchKeyGetIndex !machineName1 ?machineIndex1 ?* ?* ?*] ;#--- Insert machine into machine map  @luint machineIndex2 ;  [ioMachinesMap searchKeyGetIndex !machineName2 ?machineIndex2 ?* ?* ?*] ;#--- Insert into component map  @AC_job job := [@C_machineCheckIdentical new !machineIndex1 !machineIndex2] ; ioJobList += !job ;end rule ;

#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap ioMachinesMap  ?!@L_jobList ioJobList:  @M_variablesMap variablesMap [emptyMap] ;  @M_stateMap statesMap [emptyMap] ;  @L_stateDefinition stateDefinitionList [emptyList] ;#--- Machine name  $checkbool$ ;  @lstring machineName ;  $machineIdf$ ? machineName ;  $;$ ;#--- Insert machine into machine map  @luint machineIndex ;  [ioMachinesMap searchKeyGetIndex !machineName ?machineIndex ?* ?* ?*] ;#--- Insert into component map  @AC_job job := [@C_machineCheck new !machineIndex !true] ; ioJobList += !job ;end rule ;

#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap unused ioMachinesMap  ?!@L_jobList ioJobList:  $use_and$ ;  $;$ ;  @AC_job job := [@typeUse_AND new] ;  ioJobList += !job ;end rule ;

#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap unused ioMachinesMap  ?!@L_jobList ioJobList:  $use_ite$ ;  $;$ ;  @AC_job job := [@typeUse_ITE new] ;  ioJobList += !job ;end rule ;

#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap unused ioMachinesMap  ?!@L_jobList ioJobList:  $use_and_ite$ ;  $;$ ;  @AC_job job := [@typeUse_AND_ITE new] ;  ioJobList += !job ;end rule ;#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap unused ioMachinesMap  ?!@L_jobList ioJobList:  $and_cache$ ;  @luint size ;  $literal_integer$ ? size ;  $;$ ;  @AC_job job := [@typeResize_AND_cache new !size] ;  ioJobList += !job ;end rule ;#---------------------------------------------------------------------------*rule <component>  ?!@M_machinesMap unused ioMachinesMap  ?!@L_jobList ioJobList:  $ite_cache$ ;  @luint size ;  $literal_integer$ ? size ;  $;$ ;  @AC_job job := [@typeResize_ITE_cache new !size] ;  ioJobList += !job ;end rule ;#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap unused ioMachinesMap  ?!@L_jobList ioJobList:  $map$ ;  @luint size ;  $literal_integer$ ? size ;  $;$ ;  @AC_job job := [@typeResizeMap new !size] ;  ioJobList += !job ;end rule ;

#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap unused ioMachinesMap  ?!@L_jobList ioJobList:  $bdd$ ;  $;$ ;  @AC_job job := [@typeDisplayBDDstats new] ;  ioJobList += !job ;end rule ;

#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap ioMachinesMap  ?!@L_jobList ioJobList:  @M_variablesMap variablesMap [emptyMap] ;  @M_stateMap statesMap [emptyMap] ;  @L_stateDefinition stateDefinitionList [emptyList] ;#--- Machine name  @lstring machineName ;  $machineIdf$ ? machineName ;  $($ ;#--- Parse input variables  repeat    @lstring inputVarName ;    $identifier$ ? inputVarName ;    [!?variablesMap insertKey !inputVarName] ;  while    $,$ ;  end repeat ;  @uint inputVariablesCount := [variablesMap count] ;  $)$ ;#--- Parse internal variables  $($ ;  select  or    repeat      @lstring outputVarName ;      $identifier$ ? outputVarName ;      [!?variablesMap insertKey !outputVarName] ;    while      $,$ ;    end repeat ;  end select ;  $)$ ;  @uint inputAndInternalVariablesCount := [variablesMap count] ;#--- Parse output variables  $($ ;  repeat    @lstring outputVarName ;    $identifier$ ? outputVarName ;    [!?variablesMap insertKey !outputVarName] ;  while    $,$ ;  end repeat ;  $)$ ;  $:=$ ;#--- Machine definition  @AC_machineDefinition definition ;  <definition_expression> !?ioMachinesMap !?variablesMap ?definition ;#--- Insert machine into machine map  @luint machineIndex ;  [!?ioMachinesMap insertKeyGetIndex !machineName ?machineIndex !inputVariablesCount !inputAndInternalVariablesCount !variablesMap] ;#--- Insert into component map  @AC_job machine := [@C_machineComponent new !machineName !machineIndex !inputVariablesCount !inputAndInternalVariablesCount !variablesMap !definition] ; ioJobList += !machine ;  $;$ ;end rule ;

#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap ioMachinesMap  ?!@L_jobList ioJobList:  @M_variablesMap variablesMap [emptyMap] ;  @M_stateMap statesMap [emptyMap] ;  @L_stateDefinition stateDefinitionList [emptyList] ;#--- Machine name  $modalcompadd$ ;  @lstring machineName ;  $machineIdf$ ? machineName ;  $($ ;#--- Parse input variables  repeat    @lstring inputVarName ;    $identifier$ ? inputVarName ;    [!?variablesMap insertKey !inputVarName] ;  while    $,$ ;  end repeat ;  @uint inputVariablesCount := [variablesMap count] ;  $)$ ;#--- Parse internal variables  $($ ;  select  or    repeat      @lstring outputVarName ;      $identifier$ ? outputVarName ;      [!?variablesMap insertKey !outputVarName] ;    while      $,$ ;    end repeat ;  end select ;  $)$ ;  @uint inputAndInternalVariablesCount := [variablesMap count] ;#--- Parse output variables  $($ ;  repeat    @lstring outputVarName ;    $identifier$ ? outputVarName ;    [!?variablesMap insertKey !outputVarName] ;  while    $,$ ;  end repeat ;  $)$ ;  $:=$ ;#--- Machine definition  @M_modesMap modeMap ;  @ListForModes inclusionList ;  <modalcompadd_definition>    !?ioMachinesMap    !?variablesMap    ?modeMap    ?inclusionList  ;#--- Insert machine into machine map  @luint machineIndex ;  [!?ioMachinesMap insertKeyGetIndex !machineName ?machineIndex !inputVariablesCount !inputAndInternalVariablesCount !variablesMap] ;#--- Insert into component map  @AC_job machine := [@C_machineDefinedByAdditiveModalComp new   !machineName   !machineIndex   !inputVariablesCount   !inputAndInternalVariablesCount   !variablesMap   !modeMap   !inclusionList  ] ;  ioJobList += !machine ;  $;$ ;end rule ;

#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap ioMachinesMap  ?!@L_jobList ioJobList:  @M_variablesMap variablesMap [emptyMap] ;  @M_stateMap statesMap [emptyMap] ;  @L_stateDefinition stateDefinitionList [emptyList] ;#--- Machine name  $modalcompsub$ ;  @lstring machineName ;  $machineIdf$ ? machineName ;  $($ ;#--- Parse input variables  repeat    @lstring inputVarName ;    $identifier$ ? inputVarName ;    [!?variablesMap insertKey !inputVarName] ;  while    $,$ ;  end repeat ;  @uint inputVariablesCount := [variablesMap count] ;  $)$ ;#--- Parse internal variables  $($ ;  select  or    repeat      @lstring outputVarName ;      $identifier$ ? outputVarName ;      [!?variablesMap insertKey !outputVarName] ;    while      $,$ ;    end repeat ;  end select ;  $)$ ;  @uint inputAndInternalVariablesCount := [variablesMap count] ;#--- Parse output variables  $($ ;  repeat    @lstring outputVarName ;    $identifier$ ? outputVarName ;    [!?variablesMap insertKey !outputVarName] ;  while    $,$ ;  end repeat ;  $)$ ;  $:=$ ;#--- Machine definition  @M_modesMap modeMap ;  @ListForModes exclusionList ;  <modalcompsub_definition>    !?ioMachinesMap    !?variablesMap    ?modeMap    ?exclusionList  ;#--- Insert machine into machine map  @luint machineIndex ;  [!?ioMachinesMap insertKeyGetIndex !machineName ?machineIndex !inputVariablesCount !inputAndInternalVariablesCount !variablesMap] ;#--- Insert into component map  @AC_job machine := [@C_machineDefinedBySubstractiveModalComp new   !machineName   !machineIndex   !inputVariablesCount   !inputAndInternalVariablesCount   !variablesMap   !modeMap   !exclusionList  ] ;  ioJobList += !machine ;  $;$ ;end rule ;#---------------------------------------------------------------------------*rule <component>  ?!@M_machinesMap ioMachinesMap  ?!@L_jobList ioJobList:  $scenario$ ;  @M_variablesMap variablesMap [emptyMap] ;  @M_stateMap statesMap [emptyMap] ;  @L_stateDefinition stateDefinitionList [emptyList] ;#--- Machine name  @lstring machineName ;  $machineIdf$ ? machineName ;#--- Search machine from machine map  @luint machineIndex ;  @uint inputVariablesCountFromDefinition ;  @uint inputAndInternalVariablesCountFromDefinition ;  @M_variablesMap variablesMapFromDefinition ;  [ioMachinesMap searchKeyGetIndex !machineName ?machineIndex ?inputVariablesCountFromDefinition ?inputAndInternalVariablesCountFromDefinition ?variablesMapFromDefinition] ;#--- Parse input variables  $($ ;  repeat    @lstring inputVarName ;    $identifier$ ? inputVarName ;    [!?variablesMap insertKey !inputVarName] ;  while    $,$ ;  end repeat ;  @uint inputVariablesCount := [variablesMap count] ;  $)$ ;#--- Check correct number of input variables  if inputVariablesCountFromDefinition != inputVariablesCount then    error here : "This declaration names " . [inputVariablesCount string]      . " input variable(s), but machine definition names " . [inputVariablesCountFromDefinition string] . " input variable(s)" ;  end if ;#--- Parse internal variables  $($ ;  select  or    repeat      @lstring outputVarName ;      $identifier$ ? outputVarName ;      [!?variablesMap insertKey !outputVarName] ;    while      $,$ ;    end repeat ;  end select ;  $)$ ;#--- Check correct number of internal variables  @uint inputAndInternalVariablesCount := [variablesMap count] ;  if inputAndInternalVariablesCountFromDefinition != inputAndInternalVariablesCount then    error here : "This declaration names " . [inputAndInternalVariablesCount string]      . " input and internal variable(s), but machine definition names " . [inputAndInternalVariablesCountFromDefinition string] . " input and internal variable(s)" ;  end if ;#--- Parse output variables  $($ ;  repeat    @lstring outputVarName ;    $identifier$ ? outputVarName ;    [!?variablesMap insertKey !outputVarName] ;  while    $,$ ;  end repeat ;  $)$ ;#--- Check correct number of internal variables  @uint outputVariablesCount := [variablesMap count] ;  @uint outputVariablesCountFromDefinition := [variablesMapFromDefinition count] ;  if outputVariablesCountFromDefinition != outputVariablesCount then    error here : "This declaration names " . [outputVariablesCount string]      . " variables, but machine definition names " . [outputVariablesCountFromDefinition string] . " variables" ;  end if ;  ${$ ;  @L_scenarioList scenarioList [emptyList] ;  repeat    @lstring scenarioTitle ;    $literal_string$ ? scenarioTitle ;    @L_inputScenario inputScenario [emptyList] ;    repeat      $:$ ;      @L_inputConfigurationForScenario inputConfigurationForScenario [emptyList] ;      repeat       @luint v ;       $literal_integer$  ? v ;       if [v uint] > 1 then         error v : "this value is not a  binary digit" ;       end if ;       inputConfigurationForScenario += !v ;      while       $,$ ;      end repeat ;      if inputVariablesCount != [inputConfigurationForScenario length] then        error here : "this input configuration names " . [[inputConfigurationForScenario length] string] . " input variable(s), instead of " . [inputVariablesCount string] ;      end if ;      inputScenario += !inputConfigurationForScenario ;    while    end repeat ;    $;$ ;    scenarioList += !scenarioTitle !inputScenario ;  while  end repeat ;  $}$ ;#--- Insert job into job list  @AC_job machine := [@C_scenarioComponent new !machineIndex !inputVariablesCount !inputAndInternalVariablesCount !variablesMap !scenarioList] ; ioJobList += !machine ;end rule ;

#---------------------------------------------------------------------------*

rule <io_bool_expression>  ?!@M_machinesMap ioMachinesMap
  ?!@M_variablesMap ioVarMap  !@AC_boolExpression outExpression:  <io_and_expression> !?ioMachinesMap !?ioVarMap ?outExpression ;  repeat  while    $|$ ;    @AC_boolExpression rightExpression ;    <io_and_expression> !?ioMachinesMap !?ioVarMap ?rightExpression ;    outExpression := [@C_orExpression new ! outExpression ! rightExpression] ;  while    $^$ ;    @AC_boolExpression rightExpression ;    <io_and_expression> !?ioMachinesMap !?ioVarMap ?rightExpression ;    outExpression := [@C_xorExpression new ! outExpression ! rightExpression] ;  while    $->$ ;    @AC_boolExpression rightExpression ;    <io_and_expression> !?ioMachinesMap !?ioVarMap ?rightExpression ;    outExpression := [@C_impliesExpression new ! outExpression ! rightExpression] ;  while    $=$ ;    @AC_boolExpression rightExpression ;    <io_and_expression> !?ioMachinesMap !?ioVarMap ?rightExpression ;    outExpression := [@C_equalExpression new ! outExpression ! rightExpression] ;  end repeat ;end rule ;

#---------------------------------------------------------------------------*

rule <io_and_expression>   ?!@M_machinesMap ioMachinesMap
  ?!@M_variablesMap ioVarMap  !@AC_boolExpression outExpression:  <io_primary> !?ioMachinesMap !?ioVarMap ?outExpression ;  repeat  while    $&$ ;    @AC_boolExpression rightExpression ;    <io_primary> !?ioMachinesMap !?ioVarMap ?rightExpression ;    outExpression := [@C_andExpression new ! outExpression !rightExpression] ;  end repeat ;end rule ;

#---------------------------------------------------------------------------*

rule <io_primary>   ?!@M_machinesMap ioMachinesMap
  ?!@M_variablesMap ioVarMap  !@AC_boolExpression outExpression:  $($ ;  <io_bool_expression> !?ioMachinesMap !?ioVarMap ?outExpression ;  $)$ ;end rule ;

#---------------------------------------------------------------------------*

rule <io_primary>   ?!@M_machinesMap unused ioMachinesMap
  ?!@M_variablesMap ioVarMap  !@AC_boolExpression outExpression:  @lstring inputVarName ;  $identifier$ ? inputVarName ;  @luint inputVarIndex ;  [ioVarMap searchKeyGetIndex !inputVarName ?inputVarIndex] ;  outExpression := [@C_VariableExpression new !inputVarIndex] ;end rule ;

#---------------------------------------------------------------------------*

rule <io_primary>   ?!@M_machinesMap ioMachinesMap
  ?!@M_variablesMap ioVarMap  !@AC_boolExpression outExpression:  $~$ ;  @AC_boolExpression expression ;  <io_primary> !?ioMachinesMap !?ioVarMap ? expression ;  outExpression := [@C_notExpression new ! expression] ;end rule ;

#---------------------------------------------------------------------------*

rule <io_primary>   ?!@M_machinesMap unused ioMachinesMap
  ?!@M_variablesMap unused ioVarMap  !@AC_boolExpression outExpression:  $false$ ;  outExpression := [@C_falseExpression new] ;end rule ;

#---------------------------------------------------------------------------*

rule <io_primary>   ?!@M_machinesMap unused ioMachinesMap
  ?!@M_variablesMap unused ioVarMap  !@AC_boolExpression outExpression:  $true$ ;  outExpression := [@C_trueExpression new] ;end rule ;

#---------------------------------------------------------------------------*

rule <io_primary>   ?!@M_machinesMap ioMachinesMap
  ?!@M_variablesMap ioVarMap  !@AC_boolExpression outExpression
:  @lstring machineIdentifier ;  $machineIdf$ ? machineIdentifier ;  @uint machineInputVariableCount ;  @uint machineInputAndInternalVariableCount ;  @M_variablesMap machineVariablesMap ;  @luint indexOfImportedMachine ;  [ioMachinesMap searchKeyGetIndex !machineIdentifier ?indexOfImportedMachine ?machineInputVariableCount ?machineInputAndInternalVariableCount ?machineVariablesMap] ;  @L_translationVector translationVector [emptyList] ;#--- Parse input variables  $($ ;  repeat    @lstring inputVar ;    $identifier$ ? inputVar ;    @luint inputVarIndex ;    [ioVarMap searchKeyGetIndex !inputVar ?inputVarIndex] ;    translationVector += !inputVarIndex ;  while    $,$ ;  end repeat ;  $)$ ;  @uint inputVariablesCount := [translationVector length] ;  if inputVariablesCount != machineInputVariableCount then    error here : "The '$" . machineIdentifier . "' machine defines " . [machineInputVariableCount string]    . " input variable(s), but this operand defines " . [inputVariablesCount string] . " input variable(s)" ;  end if ;#--- Parse internal variables  $($ ;  select  or    repeat      @lstring internalVar ;      $identifier$ ? internalVar ;      @luint internalVarIndex ;      [ioVarMap searchKeyGetIndex !internalVar ?internalVarIndex] ;      translationVector += ! internalVarIndex ;    while      $,$ ;    end repeat ;  end select ;  $)$ ;  @uint inputAndInternalVariablesCount := [translationVector length] ;  if inputAndInternalVariablesCount != machineInputAndInternalVariableCount then    error here : "The '$" . [machineIdentifier string] . "' machine defines " . [machineInputAndInternalVariableCount string]    . " input and internal variable(s), but this operand defines " . [inputAndInternalVariablesCount string] . " input and internal variable(s)" ;  end if ;#--- Parse output variables  $($ ;  repeat    @lstring outputVar ;    $identifier$ ? outputVar ;    @luint outputVarIndex ;    [ioVarMap searchKeyGetIndex !outputVar ?outputVarIndex] ;    translationVector += !outputVarIndex ;  while    $,$ ;  end repeat ;  $)$ ;  @uint allVariablesCount := [translationVector length] ;  @uint machineAllVariablesCount := [machineVariablesMap count] ;  if allVariablesCount != machineAllVariablesCount then    error here : "The '$" . [machineIdentifier string] . "' machine defines " . [machineAllVariablesCount string]    . " variables, but this operand defines " . [allVariablesCount string] . " variables" ;  end if ;  outExpression := [@C_importBoolMachine new
    ![indexOfImportedMachine uint]
    ![machineIdentifier location]
    !translationVector]
  ;end rule ;

#---------------------------------------------------------------------------*#         DEFINITION EXPRESSION                                             *#---------------------------------------------------------------------------*

rule <definition_expression>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap variablesMap  !@AC_machineDefinition outDefinition:  <definition_expression_term> !?ioMachinesMap !?variablesMap ?outDefinition ;  repeat  while    $+$ ;    @AC_machineDefinition leftOperand := outDefinition ;    @AC_machineDefinition rightOperand ;    <definition_expression_term> !?ioMachinesMap !? variablesMap ?rightOperand ;    outDefinition := [@C_orComposition new !leftOperand !rightOperand] ;  end repeat ;end rule ;

#---------------------------------------------------------------------------*

rule <definition_expression_term>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap variablesMap  !@AC_machineDefinition outDefinition:  <definition_expression_factor> !?ioMachinesMap !? variablesMap ?outDefinition ;  repeat  while    $*$ ;    @location errorLocation := here ;    @AC_machineDefinition leftOperand := outDefinition ;    @AC_machineDefinition rightOperand ;    <definition_expression_factor> !?ioMachinesMap !? variablesMap ?rightOperand ;    outDefinition := [@C_strongModalComposition new !leftOperand !errorLocation !rightOperand] ;  while    $**$ ;    @location errorLocation := here ;    @AC_machineDefinition leftOperand := outDefinition ;    @AC_machineDefinition rightOperand ;    <definition_expression_factor> !?ioMachinesMap !? variablesMap ?rightOperand ;    outDefinition := [@C_weakModalComposition new !leftOperand !errorLocation !rightOperand] ;  while    $||$ ;    @AC_machineDefinition leftOperand := outDefinition ;    @AC_machineDefinition rightOperand ;    <definition_expression_factor> !?ioMachinesMap !? variablesMap ?rightOperand ;    outDefinition := [@C_parallelComposition new !leftOperand !rightOperand] ;  end repeat ;end rule ;

#---------------------------------------------------------------------------*

rule <modalcompadd_definition>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap variablesMap  !@M_modesMap outModeMap  !@ListForModes outInclusionList:  outModeMap := [@M_modesMap emptyMap] ;  outInclusionList := [@ListForModes emptyList] ;  repeat    @lstring modeName ;    $identifier$ ? modeName ;    $:$ ;    @AC_machineDefinition def ;    <definition_expression> !?ioMachinesMap !?variablesMap ?def ;    [!?outModeMap insertKey !modeName !def] ;    $;$ ;  while  end repeat ;  repeat  while    $include$ ;    @lstring sourceModeName ;    $identifier$ ? sourceModeName ;    @luint sourceModeIndex ;    [outModeMap searchKeyGetIndex !sourceModeName ?sourceModeIndex ?*] ;    $to$ ;    @lstring targetModeName ;    $identifier$ ? targetModeName ;    @luint targetModeIndex ;    [outModeMap searchKeyGetIndex !targetModeName ?targetModeIndex ?*] ;    $;$ ;    if [sourceModeIndex uint] == [targetModeIndex uint] then      warning targetModeIndex : "unuseful include: 'modalcompadd' operator never adds transitions from terminal states to initial states of the same mode" ;    else      outInclusionList += !sourceModeIndex !targetModeIndex ;    end if ;  end repeat ;end rule ;

#---------------------------------------------------------------------------*

rule <modalcompsub_definition>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap variablesMap  !@M_modesMap outModeMap  !@ListForModes outExclusionList:  outModeMap := [@M_modesMap emptyMap] ;  outExclusionList := [@ListForModes emptyList] ;  repeat    @lstring modeName ;    $identifier$ ? modeName ;    $:$ ;    @AC_machineDefinition def ;    <definition_expression> !?ioMachinesMap !?variablesMap ?def ;    [!?outModeMap insertKey !modeName !def] ;    $;$ ;  while  end repeat ;  repeat  while    $exclude$ ;    @lstring sourceModeName ;    $identifier$ ? sourceModeName ;    @luint sourceModeIndex ;    [outModeMap searchKeyGetIndex !sourceModeName ?sourceModeIndex ?*] ;    $to$ ;    @lstring targetModeName ;    $identifier$ ? targetModeName ;    @luint targetModeIndex ;    [outModeMap searchKeyGetIndex !targetModeName ?targetModeIndex ?*] ;    $;$ ;    if [sourceModeIndex uint] == [targetModeIndex uint] then      warning targetModeIndex : "unuseful include: 'modalcompadd' operator never adds transitions from terminal states to initial states of the same mode" ;    else      outExclusionList += !sourceModeIndex !targetModeIndex ;    end if ;  end repeat ;end rule ;

#---------------------------------------------------------------------------*

rule <definition_expression_factor>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap variablesMap  !@AC_machineDefinition outDefinition:  select    <explicit_automaton> !?ioMachinesMap !?variablesMap ?outDefinition ;  or    $($ ;    <definition_expression> !?ioMachinesMap !? variablesMap ?outDefinition ;    $)$ ;  or    @M_variablesMap extendedVariablesMap := variablesMap ;    @uint previousVariableCount := [extendedVariablesMap count] ;    $?$ ;    repeat      @lstring variableName ;      $identifier$ ? variableName ;      [!?extendedVariablesMap insertKey !variableName] ;    while      $,$ ;    end repeat ;    @uint actualVariableCount := [extendedVariablesMap count] ;    $($ ;    @AC_machineDefinition def ;    <definition_expression> !?ioMachinesMap !?extendedVariablesMap ?def ;    $)$ ;    outDefinition := [@C_existsDefinition new !previousVariableCount !actualVariableCount !def] ;  or    @M_variablesMap extendedVariablesMap := variablesMap ;    @uint previousVariableCount := [extendedVariablesMap count] ;    $!$ ;    repeat      @lstring variableName ;      $identifier$ ? variableName ;      [!?extendedVariablesMap insertKey !variableName] ;    while      $,$ ;    end repeat ;    @uint actualVariableCount := [extendedVariablesMap count] ;    $($ ;    @AC_machineDefinition def ;    <definition_expression> !?ioMachinesMap !?extendedVariablesMap ?def ;    $)$ ;    outDefinition := [@C_forallDefinition new !previousVariableCount !actualVariableCount !def] ;  or    $bool$ ;
    ${$ ;    @AC_boolExpression def ;    <io_bool_expression> !?ioMachinesMap !?variablesMap ?def ;    outDefinition := [@C_boolToSeqExpression new !def] ;
    $}$ ;  or    $@$ ;    @AC_machineDefinition def ;    <definition_expression_factor> !?ioMachinesMap !? variablesMap ?def ;    outDefinition := [@C_fullSaturationOperation new !def] ;  or    $~$ ;    @AC_machineDefinition def ;    <definition_expression_factor> !?ioMachinesMap !? variablesMap ?def ;    outDefinition := [@C_complementationOperation new !def] ;  or    $nofirst$ ;    $($ ;    @AC_machineDefinition def ;    <definition_expression> !?ioMachinesMap !? variablesMap ?def ;    outDefinition := [@C_suppressInitialStatesOperation new !def] ;    $)$ ;  or    $nolast$ ;    $($ ;    @AC_machineDefinition def ;    <definition_expression> !?ioMachinesMap !? variablesMap ?def ;    outDefinition := [@C_suppressTerminalStatesOperation new !def] ;    $)$ ;  or    $modalcompadd$ ;    ${$ ;    @M_modesMap modeMap ;    @ListForModes inclusionList ;    <modalcompadd_definition>      !?ioMachinesMap      !?variablesMap      ?modeMap      ?inclusionList    ;    $}$ ;    outDefinition := [@C_additiveModalCompositionComponent new !modeMap !inclusionList] ;  or    $modalcompsub$ ;    ${$ ;    @M_modesMap modeMap ;    @ListForModes exclusionList ;    <modalcompsub_definition>      !?ioMachinesMap      !?variablesMap      ?modeMap      ?exclusionList    ;    $}$ ;    outDefinition := [@C_substractiveModalCompositionComponent new !modeMap !exclusionList] ;  or    $trans$ ;    ${$ ;    @AC_boolExpression sourceExpression ;    <io_bool_expression> !?ioMachinesMap !?variablesMap ?sourceExpression ;    $to$ ;    @AC_boolExpression targetExpression ;    <io_bool_expression> !?ioMachinesMap !?variablesMap ?targetExpression ;    $}$ ;    outDefinition := [@C_trans new !sourceExpression !targetExpression] ;  end select ;end rule ;

#---------------------------------------------------------------------------*

rule <definition_expression_factor>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap ioVarMap  !@AC_machineDefinition outDefinition:  @lstring machineIdentifier ;  $machineIdf$ ? machineIdentifier ;  @uint machineInputVariableCount ;  @uint machineInputAndInternalVariableCount ;  @M_variablesMap machineVariablesMap ;  @luint indexOfImportedMachine ;  [ioMachinesMap searchKeyGetIndex !machineIdentifier ?indexOfImportedMachine ?machineInputVariableCount ?machineInputAndInternalVariableCount ?machineVariablesMap] ;  @L_translationVector translationVector [emptyList] ;#--- Parse input variables  $($ ;  repeat    @lstring inputVar ;    $identifier$ ? inputVar ;    @luint inputVarIndex ;    [ioVarMap searchKeyGetIndex !inputVar ?inputVarIndex] ;    translationVector += !inputVarIndex ;  while    $,$ ;  end repeat ;  $)$ ;  @uint inputVariablesCount := [translationVector length] ;  if inputVariablesCount != machineInputVariableCount then    error here : "The '$" . [machineIdentifier string] . "' machine defines " . [machineInputVariableCount string]    . " input variable(s), but this operand defines " . [inputVariablesCount string] . " input variable(s)" ;  end if ;#--- Parse internal variables  $($ ;  select  or    repeat      @lstring internalVar ;      $identifier$ ? internalVar ;      @luint internalVarIndex ;      [ioVarMap searchKeyGetIndex !internalVar ?internalVarIndex] ;      translationVector += ! internalVarIndex ;    while      $,$ ;    end repeat ;  end select ;  $)$ ;  @uint inputAndInternalVariablesCount := [translationVector length] ;  if inputAndInternalVariablesCount != machineInputAndInternalVariableCount then    error here : "The '$" . [machineIdentifier string] . "' machine defines " . [machineInputAndInternalVariableCount string]    . " input and internal variable(s), but this operand defines " . [inputAndInternalVariablesCount string] . " input and internal variable(s)" ;  end if ;#--- Parse output variables  $($ ;  repeat    @lstring outputVar ;    $identifier$ ? outputVar ;    @luint outputVarIndex ;    [ioVarMap searchKeyGetIndex !outputVar ?outputVarIndex] ;    translationVector += !outputVarIndex ;  while    $,$ ;  end repeat ;  $)$ ;  @uint allVariablesCount := [translationVector length] ;  @uint machineAllVariablesCount := [machineVariablesMap count] ;  if allVariablesCount != machineAllVariablesCount then    error here : "The '$" . [machineIdentifier string] . "' machine defines " . [machineAllVariablesCount string]    . " variables, but this operand defines " . [allVariablesCount string] . " variables" ;  end if ;  outDefinition := [@C_importMachine new ![indexOfImportedMachine uint] !translationVector] ;end rule ;

#---------------------------------------------------------------------------*#         EXPLICIT AUTOMATON                                                *#---------------------------------------------------------------------------*

rule <explicit_automaton>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap variablesMap  !@AC_machineDefinition outDefinition:  @M_stateMap statesMap [emptyMap] ;  @L_stateDefinition stateDefinitionList [emptyList] ;  $auto$ ;  ${$ ;#--- States declaration  $state$ ;  repeat    @lstring stateName ;    $identifier$ ? stateName ;    [!?statesMap insertKey !stateName] ;  while    $,$ ;  end repeat ;  $;$ ;#--- Initial states  @L_statesDefinitionList initialStatesDefinitionList [emptyList] ;  $first$ ;  repeat    @lstring initialState ;    $identifier$ ? initialState ;    @luint initialStateIndex ;    [statesMap searchKeyGetIndex !initialState ?initialStateIndex] ;    initialStatesDefinitionList += !initialStateIndex !here ;  while    $,$ ;  end repeat ;  $;$ ;#--- terminal states  @L_statesDefinitionList terminalStatesDefinitionList [emptyList] ;  select  or    $last$ ;    repeat      @lstring terminalState ;      $identifier$ ? terminalState ;      @luint terminalStateIndex ;      [statesMap searchKeyGetIndex !terminalState ?terminalStateIndex] ;      terminalStatesDefinitionList += ! terminalStateIndex !here ;    while      $,$ ;    end repeat ;    $;$ ;  end select ;#--- Parse state definitions  @M_stateMap stateDefinitionMap [emptyMap] ;  repeat  #--- Current state    @lstring stateName ;    $identifier$ ? stateName ;    @luint stateIndex ;    [statesMap searchKeyGetIndex !stateName ?stateIndex] ;    [!?stateDefinitionMap defineState !stateName] ;    $:$ ;  #--- State input expression    @AC_boolExpression stateExpression ;    <io_bool_expression> !?ioMachinesMap !?variablesMap ?stateExpression ;    @location endOfStateExpression := here ;    ${$ ;  #--- Parse state transition    @L_transitionDefinition transitionsList [emptyList] ;    repeat    while      @AC_boolExpression transitionInputExpression ;      <io_bool_expression> !?ioMachinesMap !?variablesMap ?transitionInputExpression ;      @location endOfExpression := here ;      $goto$ ;      @lstring targetStateName ;      $identifier$ ? targetStateName ;      @luint targetStateIndex ;      [statesMap searchKeyGetIndex !targetStateName ?targetStateIndex] ;      transitionsList += !transitionInputExpression !endOfExpression !targetStateIndex ;      $;$ ;    end repeat ;    $}$ ;    stateDefinitionList += !stateIndex !stateExpression !endOfStateExpression                           !transitionsList ;  while  end repeat ;#--- Check all states are defined  foreach statesMap (@lstring kStateName) :    if not [stateDefinitionMap hasKey ![kStateName string]] then      error here : "'" . [kStateName string] . "' state is not described" ;    end if ;  end foreach ;#--- End of input source  $}$ ;  outDefinition := [@C_explicitAutomatonDefinition new !statesMap !initialStatesDefinitionList !terminalStatesDefinitionList !stateDefinitionList !here] ;end rule ;

#---------------------------------------------------------------------------*

end syntax ;#--------------------------------------------------------------------------------*