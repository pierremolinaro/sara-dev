#---------------------------------------------------------------------------*#                                                                           *#   L E X I Q U E                                                           *#                                                                           *#---------------------------------------------------------------------------*

lexique sara_scanner :

@lstring identifierString ;@luint ulongValue ;

style identifier -> "Identifiers" ;style keyWords -> "Key words" ;style machineNameStyle -> "Machine names" ;style delimitors -> "Delimitors" ;style integer_csts -> "Integer constants" ;style stringStyle -> "Character strings" ;

# -------------------------- identifier or key word --------------------# keywords can be written in lower# for identifiers, case is significant
$identifier$ ! identifierString error message "an identifier" style identifier ;list keyWordList error message "the '%K' key word" style keyWords : "auto", "state", "first", "last", "goto", "timer", "true", "false", "nofirst", "nolast", "modalcompadd", "exclude", "modalcompsub", "include", "to", "scenario", "trans", "ite_cache", "and_cache", "map", "bdd", "bool", "use_and", "use_ite", "use_and_ite", "check", "checkbool", "checkidentical" ;rule 'a'->'z' | 'A'->'Z' :  repeat    enterCharacterIntoString (identifierString, *) ;  while 'a'->'z' | 'A'->'Z' | '_' | '0'->'9' :  end repeat ;  send search identifierString in keyWordList default $identifier$ ;end rule ;

# -------------------------- Delimitors -------------------------------
list delimitorsList error message "the '%K' delimitor" style delimitors :  ",", ";", ":", "{", "}", "->", "&", "~", "?", "!", "|", "||", "+", "(", ")", ":=", "^", "=", "*", "@", "**" ;rule list delimitorsList ;

# -------------------- Characters string --------------------------------------
$literal_string$ ! identifierString error message "a character string constant \"...\"" style stringStyle ;message incorrectStringEnd : "string does not end with '\"'" ;message incorrectCharInString : "this character cannot appear within a string" ;rule '"' :  repeat  while '\\' :    select    when 'n' :      enterCharacterIntoString (identifierString, '\n') ;    when '\\' :      enterCharacterIntoString (identifierString, '\\') ;    when '"' :      enterCharacterIntoString (identifierString, '"') ;    default      error incorrectCharInString ;    end select ;   while ' ' | '!' | '#'-> '\x7F' :    enterCharacterIntoString (identifierString, *) ;  end repeat ;  select  when '"' :    send $literal_string$ ;  default    error incorrectStringEnd ;  end select ;end rule ;

# -------------------------- Machine name -----------------------------$machineIdf$ ! identifierString error message "a machine name ($...)" style machineNameStyle ;message incorrectMachineNameBeginning : "incorrect machine name beginning" ;rule '$' :  select  when 'a'->'z' | 'A'->'Z' | '_' :    repeat      enterCharacterIntoString (identifierString, *) ;    while 'a'->'z' | 'A'->'Z' | '_' | '0'->'9' :    end repeat ;  default    error incorrectMachineNameBeginning ;  end select ;  send $machineIdf$ ; end rule ;

#------------------------------- Decimal positive number ------------------$literal_integer$ ! ulongValue error message "a decimal number" style integer_csts ;message decimalNumberTooLarge : "decimal number too large" ;message internalError : "internal error" ;rule '0'->'9' :  enterDigitIntoUlong (ulongValue, *) error decimalNumberTooLarge, internalError ;  repeat  while '0'->'9' :    enterDigitIntoUlong (ulongValue, *) error decimalNumberTooLarge, internalError ;  while '_' :  end repeat ;  send $literal_integer$ ;end rule ;#--- separators  rule '\x1' -> ' ' :  end rule ;#------------------------------------ Comment ----------------------------message incorrectEndOfComment : "incorrect end of comment" ;rule '#' :  repeat  while '\x1' ->'\t' | '\v'-> '\xFF' :  end repeat ;  select  when '\n' :  default    error incorrectEndOfComment ;  end select ;end rule ;end lexique ;#---------------------------------------------------------------------------*#                                                                           *#   S E M A N T I C S                                                       *#                                                                           *#---------------------------------------------------------------------------*semantics sara_semantics :map @M_variablesMap {  insert insertKey error message "the '%K' variable has been already declared" ;  search searchKey, searchKeyGetIndex error message "the '%K' variable is not declared" ;}

map @M_stateMap {  insert insertKey error message "the '%K' state has been already declared" ;  insert defineState error message "the '%K' state has been already defined" ;  search searchKey, searchKeyGetIndex error message "the '%K' state is not declared" ;}

#---------------------------------------------------------------------------*

list @L_translationVector {  @luint mTargetSlot ;}abstract class @AC_boolExpression {}

class @C_importBoolMachine extends @AC_boolExpression {  @uint mIndexOfImportedMachine ;
  @location mErrorLocation ;  @L_translationVector mTranslationVector ;
}

class @C_andExpression extends @AC_boolExpression {  @AC_boolExpression mLeftExpression ;  @AC_boolExpression mRightExpression ;}  class @C_orExpression extends @AC_boolExpression {  @AC_boolExpression mLeftExpression ;  @AC_boolExpression mRightExpression ;}  class @C_xorExpression extends @AC_boolExpression {  @AC_boolExpression mLeftExpression ;  @AC_boolExpression mRightExpression ;}  class @C_impliesExpression extends @AC_boolExpression  {  @AC_boolExpression mLeftExpression ;  @AC_boolExpression mRightExpression ;}  class @C_equalExpression extends @AC_boolExpression {  @AC_boolExpression mLeftExpression ;  @AC_boolExpression mRightExpression ;}  class @C_notExpression extends @AC_boolExpression {  @AC_boolExpression mExpression ;}    class @C_VariableExpression extends @AC_boolExpression {  @luint mInputVarIndex ;}

class @C_trueExpression extends @AC_boolExpression {}

class @C_falseExpression extends @AC_boolExpression {}

#---------------------------------------------------------------------------*

list @L_transitionDefinition {  @AC_boolExpression mActionExpression ;  @location mEndOfExpression ;  @luint mTargetStateIndex ;}list @L_stateDefinition {  @luint mStateIndex ;  @AC_boolExpression mStateExpression ;  @location mEndOfStateExpression ;  @L_transitionDefinition mTransitionsList ;}

#---------------------------------------------------------------------------*

list @L_statesDefinitionList {  @luint mStateIndex ;  @location mStateLocation ;}

#---------------------------------------------------------------------------*

abstract class @AC_machineDefinition {}

map @M_modesMap {  @AC_machineDefinition mModeDefinition ;  insert insertKey error message "the '%K' mode has been already declared" ;  search searchKey, searchKeyGetIndex error message "the '%K' mode is not declared" ;}

list @ListForModes {  @luint mSourceMode ;  @luint mTargetMode ;}

class @C_substractiveModalCompositionComponent extends @AC_machineDefinition {  @M_modesMap mModeMap ;  @ListForModes mExclusionList ;}

class @C_additiveModalCompositionComponent extends @AC_machineDefinition {  @M_modesMap mModeMap ;  @ListForModes mInclusionList ;}

class @C_trans extends @AC_machineDefinition {  @AC_boolExpression mSourceStateExpression ;  @AC_boolExpression mTargetStateExpression ;}
  class @C_importMachine extends @AC_machineDefinition {  @uint mIndexOfImportedMachine ;  @L_translationVector mTranslationVector ;
}

class @C_explicitAutomatonDefinition extends @AC_machineDefinition {  @M_stateMap mStatesMap ;  @L_statesDefinitionList mInitialStatesDefinitionList ;  @L_statesDefinitionList mTerminalStatesDefinitionList ;  @L_stateDefinition mStateDefinitionList ;  @location mEndOfDefinition ;}

 class @C_boolToSeqExpression extends @AC_machineDefinition {   @AC_boolExpression mExpression ; }  
class @C_existsDefinition extends @AC_machineDefinition {  @uint mPreviousVariableCount ;  @uint mTotalVariableCount ;  @AC_machineDefinition mOperand ;}

class @C_forallDefinition extends @AC_machineDefinition {  @uint mPreviousVariableCount ;  @uint mTotalVariableCount ;  @AC_machineDefinition mOperand ;}

class @C_parallelComposition extends @AC_machineDefinition {  @AC_machineDefinition mLeftOperand ;  @AC_machineDefinition mRightOperand ;}

class @C_orComposition extends @AC_machineDefinition {  @AC_machineDefinition mLeftOperand ;  @AC_machineDefinition mRightOperand ;}

class @C_strongModalComposition extends @AC_machineDefinition {  @AC_machineDefinition mLeftOperand ;  @location mErrorLocation ;  @AC_machineDefinition mRightOperand ;}

class @C_weakModalComposition extends @AC_machineDefinition {  @AC_machineDefinition mLeftOperand ;  @location mErrorLocation ;  @AC_machineDefinition mRightOperand ;}

class @C_fullSaturationOperation extends @AC_machineDefinition {  @AC_machineDefinition mOperand ;
}

class @C_complementationOperation extends @AC_machineDefinition {  @AC_machineDefinition mOperand ;
}

class @C_suppressTerminalStatesOperation extends @AC_machineDefinition {  @AC_machineDefinition mOperand ;}

class @C_suppressInitialStatesOperation extends @AC_machineDefinition {  @AC_machineDefinition mOperand ;}

#---------------------------------------------------------------------------*

abstract class @AC_job {
} class @C_machineCheck extends @AC_job {  @luint mMachineIndex ;
  @bool mCheckMachineIsBoolean ;}

class @C_machineCheckIdentical extends @AC_job {  @luint mMachineIndex1 ;
  @luint mMachineIndex2 ;
}

class @C_machineComponent extends @AC_job {  @lstring mMachineName ;  @luint mMachineIndex ;  @uint mInputVariableCount ;  @uint mInputAndInternalVariableCount ;  @M_variablesMap mVariablesMap ;  @AC_machineDefinition mDefinition ;}

class @C_machineDefinedByAdditiveModalComp extends @AC_job {  @lstring mMachineName ;  @luint mMachineIndex ;  @uint mInputVariableCount ;  @uint mInputAndInternalVariableCount ;  @M_variablesMap mVariablesMap ;  @M_modesMap mModeMap ;  @ListForModes mInclusionList ;}

class @C_machineDefinedBySubstractiveModalComp extends @AC_job {  @lstring mMachineName ;  @luint mMachineIndex ;  @uint mInputVariableCount ;  @uint mInputAndInternalVariableCount ;  @M_variablesMap mVariablesMap ;  @M_modesMap mModeMap ;  @ListForModes mExclusionList ;}

list @L_inputConfigurationForScenario {  @luint mInputValue ;}

list @L_inputScenario {  @L_inputConfigurationForScenario mInputConfiguration ;}

list @L_scenarioList {  @lstring mScenarioTitle ;  @L_inputScenario mInputScenario ;}

class @C_scenarioComponent extends @AC_job {  @luint mMachineIndex ;  @uint mInputVariableCount ;  @uint mInputAndInternalVariableCount ;  @M_variablesMap mVariablesMap ;  @L_scenarioList mScenarioList ;}

class @typeUse_AND extends @AC_job {}class @typeUse_ITE extends @AC_job {}class @typeUse_AND_ITE extends @AC_job {}class @typeResize_AND_cache extends @AC_job {  @luint mNewSize ;}class @typeResize_ITE_cache extends @AC_job {  @luint mNewSize ;}class @typeResizeMap extends @AC_job {  @luint mNewSize ;}class @typeDisplayBDDstats extends @AC_job {}#---------------------------------------------------------------------------*

list @L_jobList {  @AC_job mComponent ;}

#---------------------------------------------------------------------------*

map @M_machinesMap {  @uint mInputVariableCount ;  @uint mInputAndInternalVariableCount ;  @M_variablesMap mVariablesMap ;  insert insertKey, insertKeyGetIndex error message "the '%K' machine has been already declared" ;  search searchKey, searchKeyGetIndex error message "the '%K' machine is not defined" ;}

#---------------------------------------------------------------------------*end semantics ;#---------------------------------------------------------------------------*#                                                                           *#   S Y N T A X                                                             *#                                                                           *#---------------------------------------------------------------------------*syntax sara_parser :import lexique sara_scanner ;import semantics sara_semantics ;rule <start_symbol> ;rule <modalcompadd_definition>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap variablesMap  !@M_modesMap outModeMap  !@ListForModes outInclusionList;rule <modalcompsub_definition>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap variablesMap  !@M_modesMap outModeMap  !@ListForModes outExclusionList;rule <explicit_automaton>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap outputVariableMap  !@AC_machineDefinition outDefinition;rule <definition_expression>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap outputVariableMap  !@AC_machineDefinition outDefinition;rule <definition_expression_term>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap outputVariableMap  !@AC_machineDefinition outDefinition;rule <definition_expression_factor>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap outputVariableMap  !@AC_machineDefinition outDefinition;rule <component>  ?!@M_machinesMap ioMachinesMap  ?!@L_jobList ioJobList;rule <io_bool_expression>  ?!@M_machinesMap ioMachinesMap
  ?!@M_variablesMap ioVarMap  !@AC_boolExpression outExpression;rule <io_and_expression>   ?!@M_machinesMap ioMachinesMap
  ?!@M_variablesMap ioVarMap  !@AC_boolExpression outExpression;rule <io_primary>   ?!@M_machinesMap ioMachinesMap
  ?!@M_variablesMap ioVarMap  !@AC_boolExpression outExpression;action performComputations  ?!@L_jobList ioJobList;#---------------------------------------------------------------------------*rule <start_symbol>:  @L_jobList componentsMap [emptyList] ;  @M_machinesMap machinesMap [emptyMap] ;  repeat    <component> !?machinesMap !?componentsMap ;  while  end repeat ;  action performComputations !? componentsMap ;end rule ; #---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap ioMachinesMap  ?!@L_jobList ioJobList:  @M_variablesMap variablesMap [emptyMap] ;  @M_stateMap statesMap [emptyMap] ;  @L_stateDefinition stateDefinitionList [emptyList] ;#--- Machine name  $check$ ;  @lstring machineName ;  $machineIdf$ ? machineName ;  $;$ ;#--- Insert machine into machine map  @luint machineIndex ;  [ioMachinesMap searchKeyGetIndex !machineName ?machineIndex ?* ?* ?*] ;#--- Insert into component map  @AC_job job := [@C_machineCheck new !machineIndex !false] ; ioJobList += !job ;end rule ;

#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap ioMachinesMap  ?!@L_jobList ioJobList:  @M_variablesMap variablesMap [emptyMap] ;  @M_stateMap statesMap [emptyMap] ;  @L_stateDefinition stateDefinitionList [emptyList] ;#--- Machine name  $checkidentical$ ;  @lstring machineName1 ;  $machineIdf$ ? machineName1 ;  $,$ ;  @lstring machineName2 ;  $machineIdf$ ? machineName2 ;  $;$ ;#--- Insert machine into machine map  @luint machineIndex1 ;  [ioMachinesMap searchKeyGetIndex !machineName1 ?machineIndex1 ?* ?* ?*] ;#--- Insert machine into machine map  @luint machineIndex2 ;  [ioMachinesMap searchKeyGetIndex !machineName2 ?machineIndex2 ?* ?* ?*] ;#--- Insert into component map  @AC_job job := [@C_machineCheckIdentical new !machineIndex1 !machineIndex2] ; ioJobList += !job ;end rule ;

#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap ioMachinesMap  ?!@L_jobList ioJobList:  @M_variablesMap variablesMap [emptyMap] ;  @M_stateMap statesMap [emptyMap] ;  @L_stateDefinition stateDefinitionList [emptyList] ;#--- Machine name  $checkbool$ ;  @lstring machineName ;  $machineIdf$ ? machineName ;  $;$ ;#--- Insert machine into machine map  @luint machineIndex ;  [ioMachinesMap searchKeyGetIndex !machineName ?machineIndex ?* ?* ?*] ;#--- Insert into component map  @AC_job job := [@C_machineCheck new !machineIndex !true] ; ioJobList += !job ;end rule ;

#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap unused ioMachinesMap  ?!@L_jobList ioJobList:  $use_and$ ;  $;$ ;  @AC_job job := [@typeUse_AND new] ;  ioJobList += !job ;end rule ;

#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap unused ioMachinesMap  ?!@L_jobList ioJobList:  $use_ite$ ;  $;$ ;  @AC_job job := [@typeUse_ITE new] ;  ioJobList += !job ;end rule ;

#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap unused ioMachinesMap  ?!@L_jobList ioJobList:  $use_and_ite$ ;  $;$ ;  @AC_job job := [@typeUse_AND_ITE new] ;  ioJobList += !job ;end rule ;#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap unused ioMachinesMap  ?!@L_jobList ioJobList:  $and_cache$ ;  @luint size ;  $literal_integer$ ? size ;  $;$ ;  @AC_job job := [@typeResize_AND_cache new !size] ;  ioJobList += !job ;end rule ;#---------------------------------------------------------------------------*rule <component>  ?!@M_machinesMap unused ioMachinesMap  ?!@L_jobList ioJobList:  $ite_cache$ ;  @luint size ;  $literal_integer$ ? size ;  $;$ ;  @AC_job job := [@typeResize_ITE_cache new !size] ;  ioJobList += !job ;end rule ;#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap unused ioMachinesMap  ?!@L_jobList ioJobList:  $map$ ;  @luint size ;  $literal_integer$ ? size ;  $;$ ;  @AC_job job := [@typeResizeMap new !size] ;  ioJobList += !job ;end rule ;

#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap unused ioMachinesMap  ?!@L_jobList ioJobList:  $bdd$ ;  $;$ ;  @AC_job job := [@typeDisplayBDDstats new] ;  ioJobList += !job ;end rule ;

#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap ioMachinesMap  ?!@L_jobList ioJobList:  @M_variablesMap variablesMap [emptyMap] ;  @M_stateMap statesMap [emptyMap] ;  @L_stateDefinition stateDefinitionList [emptyList] ;#--- Machine name  @lstring machineName ;  $machineIdf$ ? machineName ;  $($ ;#--- Parse input variables  repeat    @lstring inputVarName ;    $identifier$ ? inputVarName ;    [!?variablesMap insertKey !inputVarName] ;  while    $,$ ;  end repeat ;  @uint inputVariablesCount := [variablesMap count] ;  $)$ ;#--- Parse internal variables  $($ ;  select  or    repeat      @lstring outputVarName ;      $identifier$ ? outputVarName ;      [!?variablesMap insertKey !outputVarName] ;    while      $,$ ;    end repeat ;  end select ;  $)$ ;  @uint inputAndInternalVariablesCount := [variablesMap count] ;#--- Parse output variables  $($ ;  repeat    @lstring outputVarName ;    $identifier$ ? outputVarName ;    [!?variablesMap insertKey !outputVarName] ;  while    $,$ ;  end repeat ;  $)$ ;  $:=$ ;#--- Machine definition  @AC_machineDefinition definition ;  <definition_expression> !?ioMachinesMap !?variablesMap ?definition ;#--- Insert machine into machine map  @luint machineIndex ;  [!?ioMachinesMap insertKeyGetIndex !machineName ?machineIndex !inputVariablesCount !inputAndInternalVariablesCount !variablesMap] ;#--- Insert into component map  @AC_job machine := [@C_machineComponent new !machineName !machineIndex !inputVariablesCount !inputAndInternalVariablesCount !variablesMap !definition] ; ioJobList += !machine ;  $;$ ;end rule ;

#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap ioMachinesMap  ?!@L_jobList ioJobList:  @M_variablesMap variablesMap [emptyMap] ;  @M_stateMap statesMap [emptyMap] ;  @L_stateDefinition stateDefinitionList [emptyList] ;#--- Machine name  $modalcompadd$ ;  @lstring machineName ;  $machineIdf$ ? machineName ;  $($ ;#--- Parse input variables  repeat    @lstring inputVarName ;    $identifier$ ? inputVarName ;    [!?variablesMap insertKey !inputVarName] ;  while    $,$ ;  end repeat ;  @uint inputVariablesCount := [variablesMap count] ;  $)$ ;#--- Parse internal variables  $($ ;  select  or    repeat      @lstring outputVarName ;      $identifier$ ? outputVarName ;      [!?variablesMap insertKey !outputVarName] ;    while      $,$ ;    end repeat ;  end select ;  $)$ ;  @uint inputAndInternalVariablesCount := [variablesMap count] ;#--- Parse output variables  $($ ;  repeat    @lstring outputVarName ;    $identifier$ ? outputVarName ;    [!?variablesMap insertKey !outputVarName] ;  while    $,$ ;  end repeat ;  $)$ ;  $:=$ ;#--- Machine definition  @M_modesMap modeMap ;  @ListForModes inclusionList ;  <modalcompadd_definition>    !?ioMachinesMap    !?variablesMap    ?modeMap    ?inclusionList  ;#--- Insert machine into machine map  @luint machineIndex ;  [!?ioMachinesMap insertKeyGetIndex !machineName ?machineIndex !inputVariablesCount !inputAndInternalVariablesCount !variablesMap] ;#--- Insert into component map  @AC_job machine := [@C_machineDefinedByAdditiveModalComp new   !machineName   !machineIndex   !inputVariablesCount   !inputAndInternalVariablesCount   !variablesMap   !modeMap   !inclusionList  ] ;  ioJobList += !machine ;  $;$ ;end rule ;

#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap ioMachinesMap  ?!@L_jobList ioJobList:  @M_variablesMap variablesMap [emptyMap] ;  @M_stateMap statesMap [emptyMap] ;  @L_stateDefinition stateDefinitionList [emptyList] ;#--- Machine name  $modalcompsub$ ;  @lstring machineName ;  $machineIdf$ ? machineName ;  $($ ;#--- Parse input variables  repeat    @lstring inputVarName ;    $identifier$ ? inputVarName ;    [!?variablesMap insertKey !inputVarName] ;  while    $,$ ;  end repeat ;  @uint inputVariablesCount := [variablesMap count] ;  $)$ ;#--- Parse internal variables  $($ ;  select  or    repeat      @lstring outputVarName ;      $identifier$ ? outputVarName ;      [!?variablesMap insertKey !outputVarName] ;    while      $,$ ;    end repeat ;  end select ;  $)$ ;  @uint inputAndInternalVariablesCount := [variablesMap count] ;#--- Parse output variables  $($ ;  repeat    @lstring outputVarName ;    $identifier$ ? outputVarName ;    [!?variablesMap insertKey !outputVarName] ;  while    $,$ ;  end repeat ;  $)$ ;  $:=$ ;#--- Machine definition  @M_modesMap modeMap ;  @ListForModes exclusionList ;  <modalcompsub_definition>    !?ioMachinesMap    !?variablesMap    ?modeMap    ?exclusionList  ;#--- Insert machine into machine map  @luint machineIndex ;  [!?ioMachinesMap insertKeyGetIndex !machineName ?machineIndex !inputVariablesCount !inputAndInternalVariablesCount !variablesMap] ;#--- Insert into component map  @AC_job machine := [@C_machineDefinedBySubstractiveModalComp new   !machineName   !machineIndex   !inputVariablesCount   !inputAndInternalVariablesCount   !variablesMap   !modeMap   !exclusionList  ] ;  ioJobList += !machine ;  $;$ ;end rule ;#---------------------------------------------------------------------------*rule <component>  ?!@M_machinesMap ioMachinesMap  ?!@L_jobList ioJobList:  $scenario$ ;  @M_variablesMap variablesMap [emptyMap] ;  @M_stateMap statesMap [emptyMap] ;  @L_stateDefinition stateDefinitionList [emptyList] ;#--- Machine name  @lstring machineName ;  $machineIdf$ ? machineName ;#--- Search machine from machine map  @luint machineIndex ;  @uint inputVariablesCountFromDefinition ;  @uint inputAndInternalVariablesCountFromDefinition ;  @M_variablesMap variablesMapFromDefinition ;  [ioMachinesMap searchKeyGetIndex !machineName ?machineIndex ?inputVariablesCountFromDefinition ?inputAndInternalVariablesCountFromDefinition ?variablesMapFromDefinition] ;#--- Parse input variables  $($ ;  repeat    @lstring inputVarName ;    $identifier$ ? inputVarName ;    [!?variablesMap insertKey !inputVarName] ;  while    $,$ ;  end repeat ;  @uint inputVariablesCount := [variablesMap count] ;  $)$ ;#--- Check correct number of input variables  if inputVariablesCountFromDefinition != inputVariablesCount then    error here : "This declaration names " . [inputVariablesCount string]      . " input variable(s), but machine definition names " . [inputVariablesCountFromDefinition string] . " input variable(s)" ;  end if ;#--- Parse internal variables  $($ ;  select  or    repeat      @lstring outputVarName ;      $identifier$ ? outputVarName ;      [!?variablesMap insertKey !outputVarName] ;    while      $,$ ;    end repeat ;  end select ;  $)$ ;#--- Check correct number of internal variables  @uint inputAndInternalVariablesCount := [variablesMap count] ;  if inputAndInternalVariablesCountFromDefinition != inputAndInternalVariablesCount then    error here : "This declaration names " . [inputAndInternalVariablesCount string]      . " input and internal variable(s), but machine definition names " . [inputAndInternalVariablesCountFromDefinition string] . " input and internal variable(s)" ;  end if ;#--- Parse output variables  $($ ;  repeat    @lstring outputVarName ;    $identifier$ ? outputVarName ;    [!?variablesMap insertKey !outputVarName] ;  while    $,$ ;  end repeat ;  $)$ ;#--- Check correct number of internal variables  @uint outputVariablesCount := [variablesMap count] ;  @uint outputVariablesCountFromDefinition := [variablesMapFromDefinition count] ;  if outputVariablesCountFromDefinition != outputVariablesCount then    error here : "This declaration names " . [outputVariablesCount string]      . " variables, but machine definition names " . [outputVariablesCountFromDefinition string] . " variables" ;  end if ;  ${$ ;  @L_scenarioList scenarioList [emptyList] ;  repeat    @lstring scenarioTitle ;    $literal_string$ ? scenarioTitle ;    @L_inputScenario inputScenario [emptyList] ;    repeat      $:$ ;      @L_inputConfigurationForScenario inputConfigurationForScenario [emptyList] ;      repeat       @luint v ;       $literal_integer$  ? v ;       if [v uint] > 1 then         error v : "this value is not a  binary digit" ;       end if ;       inputConfigurationForScenario += !v ;      while       $,$ ;      end repeat ;      if inputVariablesCount != [inputConfigurationForScenario length] then        error here : "this input configuration names " . [[inputConfigurationForScenario length] string] . " input variable(s), instead of " . [inputVariablesCount string] ;      end if ;      inputScenario += !inputConfigurationForScenario ;    while    end repeat ;    $;$ ;    scenarioList += !scenarioTitle !inputScenario ;  while  end repeat ;  $}$ ;#--- Insert job into job list  @AC_job machine := [@C_scenarioComponent new !machineIndex !inputVariablesCount !inputAndInternalVariablesCount !variablesMap !scenarioList] ; ioJobList += !machine ;end rule ;

#---------------------------------------------------------------------------*

rule <io_bool_expression>  ?!@M_machinesMap ioMachinesMap
  ?!@M_variablesMap ioVarMap  !@AC_boolExpression outExpression:  <io_and_expression> !?ioMachinesMap !?ioVarMap ?outExpression ;  repeat  while    $|$ ;    @AC_boolExpression rightExpression ;    <io_and_expression> !?ioMachinesMap !?ioVarMap ?rightExpression ;    outExpression := [@C_orExpression new ! outExpression ! rightExpression] ;  while    $^$ ;    @AC_boolExpression rightExpression ;    <io_and_expression> !?ioMachinesMap !?ioVarMap ?rightExpression ;    outExpression := [@C_xorExpression new ! outExpression ! rightExpression] ;  while    $->$ ;    @AC_boolExpression rightExpression ;    <io_and_expression> !?ioMachinesMap !?ioVarMap ?rightExpression ;    outExpression := [@C_impliesExpression new ! outExpression ! rightExpression] ;  while    $=$ ;    @AC_boolExpression rightExpression ;    <io_and_expression> !?ioMachinesMap !?ioVarMap ?rightExpression ;    outExpression := [@C_equalExpression new ! outExpression ! rightExpression] ;  end repeat ;end rule ;

#---------------------------------------------------------------------------*

rule <io_and_expression>   ?!@M_machinesMap ioMachinesMap
  ?!@M_variablesMap ioVarMap  !@AC_boolExpression outExpression:  <io_primary> !?ioMachinesMap !?ioVarMap ?outExpression ;  repeat  while    $&$ ;    @AC_boolExpression rightExpression ;    <io_primary> !?ioMachinesMap !?ioVarMap ?rightExpression ;    outExpression := [@C_andExpression new ! outExpression !rightExpression] ;  end repeat ;end rule ;

#---------------------------------------------------------------------------*

rule <io_primary>   ?!@M_machinesMap ioMachinesMap
  ?!@M_variablesMap ioVarMap  !@AC_boolExpression outExpression:  $($ ;  <io_bool_expression> !?ioMachinesMap !?ioVarMap ?outExpression ;  $)$ ;end rule ;

#---------------------------------------------------------------------------*

rule <io_primary>   ?!@M_machinesMap unused ioMachinesMap
  ?!@M_variablesMap ioVarMap  !@AC_boolExpression outExpression:  @lstring inputVarName ;  $identifier$ ? inputVarName ;  @luint inputVarIndex ;  [ioVarMap searchKeyGetIndex !inputVarName ?inputVarIndex] ;  outExpression := [@C_VariableExpression new !inputVarIndex] ;end rule ;

#---------------------------------------------------------------------------*

rule <io_primary>   ?!@M_machinesMap ioMachinesMap
  ?!@M_variablesMap ioVarMap  !@AC_boolExpression outExpression:  $~$ ;  @AC_boolExpression expression ;  <io_primary> !?ioMachinesMap !?ioVarMap ? expression ;  outExpression := [@C_notExpression new ! expression] ;end rule ;

#---------------------------------------------------------------------------*

rule <io_primary>   ?!@M_machinesMap unused ioMachinesMap
  ?!@M_variablesMap unused ioVarMap  !@AC_boolExpression outExpression:  $false$ ;  outExpression := [@C_falseExpression new] ;end rule ;

#---------------------------------------------------------------------------*

rule <io_primary>   ?!@M_machinesMap unused ioMachinesMap
  ?!@M_variablesMap unused ioVarMap  !@AC_boolExpression outExpression:  $true$ ;  outExpression := [@C_trueExpression new] ;end rule ;

#---------------------------------------------------------------------------*

rule <io_primary>   ?!@M_machinesMap ioMachinesMap
  ?!@M_variablesMap ioVarMap  !@AC_boolExpression outExpression
:  @lstring machineIdentifier ;  $machineIdf$ ? machineIdentifier ;  @uint machineInputVariableCount ;  @uint machineInputAndInternalVariableCount ;  @M_variablesMap machineVariablesMap ;  @luint indexOfImportedMachine ;  [ioMachinesMap searchKeyGetIndex !machineIdentifier ?indexOfImportedMachine ?machineInputVariableCount ?machineInputAndInternalVariableCount ?machineVariablesMap] ;  @L_translationVector translationVector [emptyList] ;#--- Parse input variables  $($ ;  repeat    @lstring inputVar ;    $identifier$ ? inputVar ;    @luint inputVarIndex ;    [ioVarMap searchKeyGetIndex !inputVar ?inputVarIndex] ;    translationVector += !inputVarIndex ;  while    $,$ ;  end repeat ;  $)$ ;  @uint inputVariablesCount := [translationVector length] ;  if inputVariablesCount != machineInputVariableCount then    error here : "The '$" . [machineIdentifier string] . "' machine defines " . [machineInputVariableCount string]    . " input variable(s), but this operand defines " . [inputVariablesCount string] . " input variable(s)" ;  end if ;#--- Parse internal variables  $($ ;  select  or    repeat      @lstring internalVar ;      $identifier$ ? internalVar ;      @luint internalVarIndex ;      [ioVarMap searchKeyGetIndex !internalVar ?internalVarIndex] ;      translationVector += ! internalVarIndex ;    while      $,$ ;    end repeat ;  end select ;  $)$ ;  @uint inputAndInternalVariablesCount := [translationVector length] ;  if inputAndInternalVariablesCount != machineInputAndInternalVariableCount then    error here : "The '$" . [machineIdentifier string] . "' machine defines " . [machineInputAndInternalVariableCount string]    . " input and internal variable(s), but this operand defines " . [inputAndInternalVariablesCount string] . " input and internal variable(s)" ;  end if ;#--- Parse output variables  $($ ;  repeat    @lstring outputVar ;    $identifier$ ? outputVar ;    @luint outputVarIndex ;    [ioVarMap searchKeyGetIndex !outputVar ?outputVarIndex] ;    translationVector += !outputVarIndex ;  while    $,$ ;  end repeat ;  $)$ ;  @uint allVariablesCount := [translationVector length] ;  @uint machineAllVariablesCount := [machineVariablesMap count] ;  if allVariablesCount != machineAllVariablesCount then    error here : "The '$" . [machineIdentifier string] . "' machine defines " . [machineAllVariablesCount string]    . " variables, but this operand defines " . [allVariablesCount string] . " variables" ;  end if ;  outExpression := [@C_importBoolMachine new
    ![indexOfImportedMachine uint]
    ![machineIdentifier location]
    !translationVector]
  ;end rule ;

#---------------------------------------------------------------------------*#         DEFINITION EXPRESSION                                             *#---------------------------------------------------------------------------*

rule <definition_expression>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap variablesMap  !@AC_machineDefinition outDefinition:  <definition_expression_term> !?ioMachinesMap !?variablesMap ?outDefinition ;  repeat  while    $+$ ;    @AC_machineDefinition leftOperand := outDefinition ;    @AC_machineDefinition rightOperand ;    <definition_expression_term> !?ioMachinesMap !? variablesMap ?rightOperand ;    outDefinition := [@C_orComposition new !leftOperand !rightOperand] ;  end repeat ;end rule ;

#---------------------------------------------------------------------------*

rule <definition_expression_term>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap variablesMap  !@AC_machineDefinition outDefinition:  <definition_expression_factor> !?ioMachinesMap !? variablesMap ?outDefinition ;  repeat  while    $*$ ;    @location errorLocation := here ;    @AC_machineDefinition leftOperand := outDefinition ;    @AC_machineDefinition rightOperand ;    <definition_expression_factor> !?ioMachinesMap !? variablesMap ?rightOperand ;    outDefinition := [@C_strongModalComposition new !leftOperand !errorLocation !rightOperand] ;  while    $**$ ;    @location errorLocation := here ;    @AC_machineDefinition leftOperand := outDefinition ;    @AC_machineDefinition rightOperand ;    <definition_expression_factor> !?ioMachinesMap !? variablesMap ?rightOperand ;    outDefinition := [@C_weakModalComposition new !leftOperand !errorLocation !rightOperand] ;  while    $||$ ;    @AC_machineDefinition leftOperand := outDefinition ;    @AC_machineDefinition rightOperand ;    <definition_expression_factor> !?ioMachinesMap !? variablesMap ?rightOperand ;    outDefinition := [@C_parallelComposition new !leftOperand !rightOperand] ;  end repeat ;end rule ;

#---------------------------------------------------------------------------*

rule <modalcompadd_definition>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap variablesMap  !@M_modesMap outModeMap  !@ListForModes outInclusionList:  outModeMap := [@M_modesMap emptyMap] ;  outInclusionList := [@ListForModes emptyList] ;  repeat    @lstring modeName ;    $identifier$ ? modeName ;    $:$ ;    @AC_machineDefinition def ;    <definition_expression> !?ioMachinesMap !?variablesMap ?def ;    [!?outModeMap insertKey !modeName !def] ;    $;$ ;  while  end repeat ;  repeat  while    $include$ ;    @lstring sourceModeName ;    $identifier$ ? sourceModeName ;    @luint sourceModeIndex ;    [outModeMap searchKeyGetIndex !sourceModeName ?sourceModeIndex ?*] ;    $to$ ;    @lstring targetModeName ;    $identifier$ ? targetModeName ;    @luint targetModeIndex ;    [outModeMap searchKeyGetIndex !targetModeName ?targetModeIndex ?*] ;    $;$ ;    if [sourceModeIndex uint] == [targetModeIndex uint] then      warning targetModeIndex : "unuseful include: 'modalcompadd' operator never adds transitions from terminal states to initial states of the same mode" ;    else      outInclusionList += !sourceModeIndex !targetModeIndex ;    end if ;  end repeat ;end rule ;

#---------------------------------------------------------------------------*

rule <modalcompsub_definition>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap variablesMap  !@M_modesMap outModeMap  !@ListForModes outExclusionList:  outModeMap := [@M_modesMap emptyMap] ;  outExclusionList := [@ListForModes emptyList] ;  repeat    @lstring modeName ;    $identifier$ ? modeName ;    $:$ ;    @AC_machineDefinition def ;    <definition_expression> !?ioMachinesMap !?variablesMap ?def ;    [!?outModeMap insertKey !modeName !def] ;    $;$ ;  while  end repeat ;  repeat  while    $exclude$ ;    @lstring sourceModeName ;    $identifier$ ? sourceModeName ;    @luint sourceModeIndex ;    [outModeMap searchKeyGetIndex !sourceModeName ?sourceModeIndex ?*] ;    $to$ ;    @lstring targetModeName ;    $identifier$ ? targetModeName ;    @luint targetModeIndex ;    [outModeMap searchKeyGetIndex !targetModeName ?targetModeIndex ?*] ;    $;$ ;    if [sourceModeIndex uint] == [targetModeIndex uint] then      warning targetModeIndex : "unuseful include: 'modalcompadd' operator never adds transitions from terminal states to initial states of the same mode" ;    else      outExclusionList += !sourceModeIndex !targetModeIndex ;    end if ;  end repeat ;end rule ;

#---------------------------------------------------------------------------*

rule <definition_expression_factor>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap variablesMap  !@AC_machineDefinition outDefinition:  select    <explicit_automaton> !?ioMachinesMap !?variablesMap ?outDefinition ;  or    $($ ;    <definition_expression> !?ioMachinesMap !? variablesMap ?outDefinition ;    $)$ ;  or    @M_variablesMap extendedVariablesMap := variablesMap ;    @uint previousVariableCount := [extendedVariablesMap count] ;    $?$ ;    repeat      @lstring variableName ;      $identifier$ ? variableName ;      [!?extendedVariablesMap insertKey !variableName] ;    while      $,$ ;    end repeat ;    @uint actualVariableCount := [extendedVariablesMap count] ;    $($ ;    @AC_machineDefinition def ;    <definition_expression> !?ioMachinesMap !?extendedVariablesMap ?def ;    $)$ ;    outDefinition := [@C_existsDefinition new !previousVariableCount !actualVariableCount !def] ;  or    @M_variablesMap extendedVariablesMap := variablesMap ;    @uint previousVariableCount := [extendedVariablesMap count] ;    $!$ ;    repeat      @lstring variableName ;      $identifier$ ? variableName ;      [!?extendedVariablesMap insertKey !variableName] ;    while      $,$ ;    end repeat ;    @uint actualVariableCount := [extendedVariablesMap count] ;    $($ ;    @AC_machineDefinition def ;    <definition_expression> !?ioMachinesMap !?extendedVariablesMap ?def ;    $)$ ;    outDefinition := [@C_forallDefinition new !previousVariableCount !actualVariableCount !def] ;  or    $bool$ ;
    ${$ ;    @AC_boolExpression def ;    <io_bool_expression> !?ioMachinesMap !?variablesMap ?def ;    outDefinition := [@C_boolToSeqExpression new !def] ;
    $}$ ;  or    $@$ ;    @AC_machineDefinition def ;    <definition_expression_factor> !?ioMachinesMap !? variablesMap ?def ;    outDefinition := [@C_fullSaturationOperation new !def] ;  or    $~$ ;    @AC_machineDefinition def ;    <definition_expression_factor> !?ioMachinesMap !? variablesMap ?def ;    outDefinition := [@C_complementationOperation new !def] ;  or    $nofirst$ ;    $($ ;    @AC_machineDefinition def ;    <definition_expression> !?ioMachinesMap !? variablesMap ?def ;    outDefinition := [@C_suppressInitialStatesOperation new !def] ;    $)$ ;  or    $nolast$ ;    $($ ;    @AC_machineDefinition def ;    <definition_expression> !?ioMachinesMap !? variablesMap ?def ;    outDefinition := [@C_suppressTerminalStatesOperation new !def] ;    $)$ ;  or    $modalcompadd$ ;    ${$ ;    @M_modesMap modeMap ;    @ListForModes inclusionList ;    <modalcompadd_definition>      !?ioMachinesMap      !?variablesMap      ?modeMap      ?inclusionList    ;    $}$ ;    outDefinition := [@C_additiveModalCompositionComponent new !modeMap !inclusionList] ;  or    $modalcompsub$ ;    ${$ ;    @M_modesMap modeMap ;    @ListForModes exclusionList ;    <modalcompsub_definition>      !?ioMachinesMap      !?variablesMap      ?modeMap      ?exclusionList    ;    $}$ ;    outDefinition := [@C_substractiveModalCompositionComponent new !modeMap !exclusionList] ;  or    $trans$ ;    ${$ ;    @AC_boolExpression sourceExpression ;    <io_bool_expression> !?ioMachinesMap !?variablesMap ?sourceExpression ;    $to$ ;    @AC_boolExpression targetExpression ;    <io_bool_expression> !?ioMachinesMap !?variablesMap ?targetExpression ;    $}$ ;    outDefinition := [@C_trans new !sourceExpression !targetExpression] ;  end select ;end rule ;

#---------------------------------------------------------------------------*

rule <definition_expression_factor>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap ioVarMap  !@AC_machineDefinition outDefinition:  @lstring machineIdentifier ;  $machineIdf$ ? machineIdentifier ;  @uint machineInputVariableCount ;  @uint machineInputAndInternalVariableCount ;  @M_variablesMap machineVariablesMap ;  @luint indexOfImportedMachine ;  [ioMachinesMap searchKeyGetIndex !machineIdentifier ?indexOfImportedMachine ?machineInputVariableCount ?machineInputAndInternalVariableCount ?machineVariablesMap] ;  @L_translationVector translationVector [emptyList] ;#--- Parse input variables  $($ ;  repeat    @lstring inputVar ;    $identifier$ ? inputVar ;    @luint inputVarIndex ;    [ioVarMap searchKeyGetIndex !inputVar ?inputVarIndex] ;    translationVector += !inputVarIndex ;  while    $,$ ;  end repeat ;  $)$ ;  @uint inputVariablesCount := [translationVector length] ;  if inputVariablesCount != machineInputVariableCount then    error here : "The '$" . [machineIdentifier string] . "' machine defines " . [machineInputVariableCount string]    . " input variable(s), but this operand defines " . [inputVariablesCount string] . " input variable(s)" ;  end if ;#--- Parse internal variables  $($ ;  select  or    repeat      @lstring internalVar ;      $identifier$ ? internalVar ;      @luint internalVarIndex ;      [ioVarMap searchKeyGetIndex !internalVar ?internalVarIndex] ;      translationVector += ! internalVarIndex ;    while      $,$ ;    end repeat ;  end select ;  $)$ ;  @uint inputAndInternalVariablesCount := [translationVector length] ;  if inputAndInternalVariablesCount != machineInputAndInternalVariableCount then    error here : "The '$" . [machineIdentifier string] . "' machine defines " . [machineInputAndInternalVariableCount string]    . " input and internal variable(s), but this operand defines " . [inputAndInternalVariablesCount string] . " input and internal variable(s)" ;  end if ;#--- Parse output variables  $($ ;  repeat    @lstring outputVar ;    $identifier$ ? outputVar ;    @luint outputVarIndex ;    [ioVarMap searchKeyGetIndex !outputVar ?outputVarIndex] ;    translationVector += !outputVarIndex ;  while    $,$ ;  end repeat ;  $)$ ;  @uint allVariablesCount := [translationVector length] ;  @uint machineAllVariablesCount := [machineVariablesMap count] ;  if allVariablesCount != machineAllVariablesCount then    error here : "The '$" . [machineIdentifier string] . "' machine defines " . [machineAllVariablesCount string]    . " variables, but this operand defines " . [allVariablesCount string] . " variables" ;  end if ;  outDefinition := [@C_importMachine new ![indexOfImportedMachine uint] !translationVector] ;end rule ;

#---------------------------------------------------------------------------*#         EXPLICIT AUTOMATON                                                *#---------------------------------------------------------------------------*

rule <explicit_automaton>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap variablesMap  !@AC_machineDefinition outDefinition:  @M_stateMap statesMap [emptyMap] ;  @L_stateDefinition stateDefinitionList [emptyList] ;  $auto$ ;  ${$ ;#--- States declaration  $state$ ;  repeat    @lstring stateName ;    $identifier$ ? stateName ;    [!?statesMap insertKey !stateName] ;  while    $,$ ;  end repeat ;  $;$ ;#--- Initial states  @L_statesDefinitionList initialStatesDefinitionList [emptyList] ;  $first$ ;  repeat    @lstring initialState ;    $identifier$ ? initialState ;    @luint initialStateIndex ;    [statesMap searchKeyGetIndex !initialState ?initialStateIndex] ;    initialStatesDefinitionList += !initialStateIndex !here ;  while    $,$ ;  end repeat ;  $;$ ;#--- terminal states  @L_statesDefinitionList terminalStatesDefinitionList [emptyList] ;  select  or    $last$ ;    repeat      @lstring terminalState ;      $identifier$ ? terminalState ;      @luint terminalStateIndex ;      [statesMap searchKeyGetIndex !terminalState ?terminalStateIndex] ;      terminalStatesDefinitionList += ! terminalStateIndex !here ;    while      $,$ ;    end repeat ;    $;$ ;  end select ;#--- Parse state definitions  @M_stateMap stateDefinitionMap [emptyMap] ;  repeat  #--- Current state    @lstring stateName ;    $identifier$ ? stateName ;    @luint stateIndex ;    [statesMap searchKeyGetIndex !stateName ?stateIndex] ;    [!?stateDefinitionMap defineState !stateName] ;    $:$ ;  #--- State input expression    @AC_boolExpression stateExpression ;    <io_bool_expression> !?ioMachinesMap !?variablesMap ?stateExpression ;    @location endOfStateExpression := here ;    ${$ ;  #--- Parse state transition    @L_transitionDefinition transitionsList [emptyList] ;    repeat    while      @AC_boolExpression transitionInputExpression ;      <io_bool_expression> !?ioMachinesMap !?variablesMap ?transitionInputExpression ;      @location endOfExpression := here ;      $goto$ ;      @lstring targetStateName ;      $identifier$ ? targetStateName ;      @luint targetStateIndex ;      [statesMap searchKeyGetIndex !targetStateName ?targetStateIndex] ;      transitionsList += !transitionInputExpression !endOfExpression !targetStateIndex ;      $;$ ;    end repeat ;    $}$ ;    stateDefinitionList += !stateIndex !stateExpression !endOfStateExpression                           !transitionsList ;  while  end repeat ;#--- Check all states are defined  foreach statesMap (??@lstring kStateName) :    if not [stateDefinitionMap hasKey ![kStateName string]] then      error here : "'" . [kStateName string] . "' state is not described" ;    end if ;  end foreach ;#--- End of input source  $}$ ;  outDefinition := [@C_explicitAutomatonDefinition new !statesMap !initialStatesDefinitionList !terminalStatesDefinitionList !stateDefinitionList !here] ;end rule ;

#---------------------------------------------------------------------------*

end syntax ;#---------------------------------------------------------------------------*#                                                                           *#   C O M M A N D    L I N E    O P T I O N S                               *#                                                                           *#---------------------------------------------------------------------------*option sara_cli_options :  @bool displayBDDvaluesCount : 'c', "display-bdd-values-count" -> "displays values count for every BDD" ;  @bool displayBDDvalues : 'v', "display-bdd-values" -> "displays values for every BDD" ;end option ;
#---------------------------------------------------------------------------*#                                                                           *#   G R A M M A R                                                           *#                                                                           *#---------------------------------------------------------------------------*grammar sara_grammar "LL1" :  import lexique sara_scanner ;  import option sara_cli_options ;  import syntax sara_parser ;  root <start_symbol> ;end grammar ;
#---------------------------------------------------------------------------*#                                                                           *#   C O C O A                                                               *#                                                                           *#---------------------------------------------------------------------------*

gui cocoa_sara "cocoa" : program "sara" ; import grammar sara_grammar ;end gui ;#---------------------------------------------------------------------------*#                                                                           *#   P R O G R A M                                                           *#                                                                           *#---------------------------------------------------------------------------*program sara_main "version 1.4.0" . "sara" :  import grammar sara_grammar ;#--- max error and warning count  error 100 ;  warning 100 ;end program ;#--------------------------------------------------------------------------------*