#---------------------------------------------------------------------------*#                                                                           *#   L E X I Q U E                                                           *#                                                                           *#---------------------------------------------------------------------------*lexique sara_scanner :header "galgas/F_LexicalActions.h" ;@lstring identifierString ;@luint ulongValue ;style identifier -> "Identifiers" ;style keyWords -> "Key words" ;style machineNameStyle -> "Machine names" ;style delimitors -> "Delimitors" ;style integer_csts -> "Integer constants" ;style stringStyle -> "Character strings" ;# -------------------------- identifier or key word --------------------# keywords can be written in lower# for identifiers, case is significant$identifier$ ! identifierString error message "an identifier" style identifier ;list keyWordList error message "the '" . * . "' key word" style keyWords : "auto", "state", "first", "last", "goto", "timer", "true", "false", "check", "checkbool", "nofirst", "nolast", "modalcompadd", "exclude", "modalcompsub", "include", "to", "scenario", "trans", "ite_cache", "and_cache", "map", "bdd", "bool", "use_and", "use_ite", "use_and_ite" ;rule 'a'->'z' | 'A'->'Z' :  repeat    enterCharacterIntoString (identifierString, *) ;  while 'a'->'z' | 'A'->'Z' | '_' | '0'->'9' :  end repeat ;  send search identifierString in keyWordList default $identifier$ ;end rule ;

# -------------------------- Delimitors -------------------------------list delimitorsList error message "the '" . * . "' delimitor" style delimitors :  ",", ";", ":", "{", "}", "->", "&", "~", "?", "|", "||", "(", ")", ":=", "^", "=", "*", "@", "**" ;rule list delimitorsList ;

# -------------------- Characters string --------------------------------------$literal_string$ ! identifierString error message "a character string constant \"...\"" style stringStyle ;message incorrectStringEnd : "string does not end with '\"'" ;message incorrectCharInString : "this character cannot appear within a string" ;rule '"' :  repeat  while '\\' :    select    when 'n' :      enterCharacterIntoString (identifierString, '\n') ;    when '\\' :      enterCharacterIntoString (identifierString, '\\') ;    when '"' :      enterCharacterIntoString (identifierString, '"') ;    default      error incorrectCharInString ;    end select ;   while ' ' | '!' | '#'-> '\127' :    enterCharacterIntoString (identifierString, *) ;  end repeat ;  select  when '"' :    send $literal_string$ ;  default    error incorrectStringEnd ;  end select ;end rule ;

# -------------------------- Machine name -----------------------------$machineIdf$ ! identifierString error message "a machine name ($...)" style machineNameStyle ;message incorrectMachineNameBeginning : "incorrect machine name beginning" ;rule '$' :  select  when 'a'->'z' | 'A'->'Z' | '_' :    repeat      enterCharacterIntoString (identifierString, *) ;    while 'a'->'z' | 'A'->'Z' | '_' | '0'->'9' :    end repeat ;  default    error incorrectMachineNameBeginning ;  end select ;  send $machineIdf$ ; end rule ;

#------------------------------- Decimal positive number ------------------$literal_integer$ ! ulongValue error message "a decimal number" style integer_csts ;message decimalNumberTooLarge : "decimal number too large" ;message internalError : "internal error" ;rule '0'->'9' :  enterDigitIntoUlong (ulongValue, *) error decimalNumberTooLarge, internalError ;  repeat  while '0'->'9' :    enterDigitIntoUlong (ulongValue, *) error decimalNumberTooLarge, internalError ;  while '_' :  end repeat ;  send $literal_integer$ ;end rule ;#--- separators  rule '\1' -> ' ' :  end rule ;#------------------------------------ Comment ----------------------------message incorrectEndOfComment : "incorrect end of comment" ;rule '#' :  repeat  while '\1' ->'\t' | '\v'-> '\255' :  end repeat ;  select  when '\n' :  default    error incorrectEndOfComment ;  end select ;end rule ;end lexique ;#---------------------------------------------------------------------------*#                                                                           *#   S E M A N T I C S                                                       *#                                                                           *#---------------------------------------------------------------------------*semantics sara_semantics :  map @M_variablesMap    insert insertKey error message "the '" . * . "' variable has been already declared" ;    search searchKey error message "the '" . * . "' variable is not declared" ;    key @lstring ;  end map ;  map @M_stateMap    insert insertKey error message "the '" . * . "' state has been already declared" ;    insert defineState error message "the '" . * . "' state has been already defined" ;    search searchKey error message "the '" . * . "' state is not declared" ;    key @lstring ;  end map ;

#---------------------------------------------------------------------------*

list @L_translationVector  @luint mTargetSlot ;end list ;abstract class @AC_boolExpression  include header ;end class ;

class @C_importBoolMachine extends @AC_boolExpression  @uint mIndexOfImportedMachine ;
  @location mErrorLocation ;  @L_translationVector mTranslationVector ;
end class ;

class @C_andExpression extends @AC_boolExpression  @AC_boolExpression mLeftExpression ;  @AC_boolExpression mRightExpression ;end class ;  class @C_orExpression extends @AC_boolExpression   @AC_boolExpression mLeftExpression ;  @AC_boolExpression mRightExpression ;end class ;  class @C_xorExpression extends @AC_boolExpression   @AC_boolExpression mLeftExpression ;  @AC_boolExpression mRightExpression ;end class ;  class @C_impliesExpression extends @AC_boolExpression   @AC_boolExpression mLeftExpression ;  @AC_boolExpression mRightExpression ;end class ;  class @C_equalExpression extends @AC_boolExpression   @AC_boolExpression mLeftExpression ;  @AC_boolExpression mRightExpression ;end class ;  class @C_notExpression extends @AC_boolExpression   @AC_boolExpression mExpression ;end class ;    class @C_VariableExpression extends @AC_boolExpression   @luint mInputVarIndex ;end class ;

class @C_trueExpression extends @AC_boolExpression end class ;

class @C_falseExpression extends @AC_boolExpression end class ;

#---------------------------------------------------------------------------*

list @L_transitionDefinition  @AC_boolExpression mActionExpression ;  @location mEndOfExpression ;  @luint mTargetStateIndex ;end list ;list @L_stateDefinition  @luint mStateIndex ;  @AC_boolExpression mStateExpression ;  @location mEndOfStateExpression ;  @L_transitionDefinition mTransitionsList ;end list ;

#---------------------------------------------------------------------------*

list @L_statesDefinitionList  @luint mStateIndex ;  @location mStateLocation ;end list ;

#---------------------------------------------------------------------------*

abstract class @AC_machineDefinition  include header ; end class ;

map @M_modesMap  insert insertKey error message "the '" . * . "' mode has been already declared" ;  search searchKey error message "the '" . * . "' mode is not declared" ;  key @lstring ;  @AC_machineDefinition mModeDefinition ;end map ;

list @ListForModes  @luint mSourceMode ;  @luint mTargetMode ;end list ;

class @C_substractiveModalCompositionComponent extends @AC_machineDefinition  @M_modesMap mModeMap ;  @ListForModes mExclusionList ;end class ;

class @C_additiveModalCompositionComponent extends @AC_machineDefinition  @M_modesMap mModeMap ;  @ListForModes mInclusionList ;end class ;

class @C_trans extends @AC_machineDefinition  @AC_boolExpression mSourceStateExpression ;  @AC_boolExpression mTargetStateExpression ;end class ;
  class @C_importMachine extends @AC_machineDefinition  @uint mIndexOfImportedMachine ;  @L_translationVector mTranslationVector ;
end class ;

class @C_explicitAutomatonDefinition extends @AC_machineDefinition  @M_stateMap mStatesMap ;  @L_statesDefinitionList mInitialStatesDefinitionList ;  @L_statesDefinitionList mTerminalStatesDefinitionList ;  @L_stateDefinition mStateDefinitionList ;  @location mEndOfDefinition ;end class ;

 class @C_boolToSeqExpression extends @AC_machineDefinition   @AC_boolExpression mExpression ; end class ;  
class @C_existsDefinition extends @AC_machineDefinition  @uint mPreviousVariableCount ;  @uint mTotalVariableCount ;  @AC_machineDefinition mOperand ;end class ;

class @C_parallelComposition extends @AC_machineDefinition  @AC_machineDefinition mLeftOperand ;  @AC_machineDefinition mRightOperand ;end class ;

class @C_strongModalComposition extends @AC_machineDefinition  @AC_machineDefinition mLeftOperand ;  @location mErrorLocation ;  @AC_machineDefinition mRightOperand ;end class ;

class @C_weakModalComposition extends @AC_machineDefinition  @AC_machineDefinition mLeftOperand ;  @location mErrorLocation ;  @AC_machineDefinition mRightOperand ;end class ;

class @C_fullSaturationOperation extends @AC_machineDefinition  @AC_machineDefinition mOperand ;

end class ;class @C_suppressTerminalStatesOperation extends @AC_machineDefinition  @AC_machineDefinition mOperand ;end class ;

class @C_suppressInitialStatesOperation extends @AC_machineDefinition  @AC_machineDefinition mOperand ;end class ;

#---------------------------------------------------------------------------*

abstract class @AC_job
  include header ;end class ; class @C_machineCheck extends @AC_job  @luint mMachineIndex ;
  @bool mCheckMachineIsBoolean ;end class ;

class @C_machineComponent extends @AC_job  @lstring mMachineName ;  @luint mMachineIndex ;  @uint mInputVariableCount ;  @uint mInputAndInternalVariableCount ;  @M_variablesMap mVariablesMap ;  @AC_machineDefinition mDefinition ;end class ;

class @C_machineDefinedByAdditiveModalComp extends @AC_job  @lstring mMachineName ;  @luint mMachineIndex ;  @uint mInputVariableCount ;  @uint mInputAndInternalVariableCount ;  @M_variablesMap mVariablesMap ;  @M_modesMap mModeMap ;  @ListForModes mInclusionList ;end class ;

class @C_machineDefinedBySubstractiveModalComp extends @AC_job  @lstring mMachineName ;  @luint mMachineIndex ;  @uint mInputVariableCount ;  @uint mInputAndInternalVariableCount ;  @M_variablesMap mVariablesMap ;  @M_modesMap mModeMap ;  @ListForModes mExclusionList ;end class ;

list @L_inputConfigurationForScenario  @luint mInputValue ;end list ;

list @L_inputScenario  @L_inputConfigurationForScenario mInputConfiguration ;end list ;

list @L_scenarioList  @lstring mScenarioTitle ;  @L_inputScenario mInputScenario ;end list ;

class @C_scenarioComponent extends @AC_job  @luint mMachineIndex ;  @uint mInputVariableCount ;  @uint mInputAndInternalVariableCount ;  @M_variablesMap mVariablesMap ;  @L_scenarioList mScenarioList ;end class ;

class @typeUse_AND extends @AC_jobend class ;class @typeUse_ITE extends @AC_jobend class ;class @typeUse_AND_ITE extends @AC_jobend class ;class @typeResize_AND_cache extends @AC_job  @luint mNewSize ;end class ;class @typeResize_ITE_cache extends @AC_job  @luint mNewSize ;end class ;class @typeResizeMap extends @AC_job  @luint mNewSize ;end class ;class @typeDisplayBDDstats extends @AC_jobend class ;#---------------------------------------------------------------------------*

list @L_jobList  @AC_job mComponent ;end list ;

#---------------------------------------------------------------------------*

map @M_machinesMap  insert insertKey error message "the '" . * . "' machine has been already declared" ;  search searchKey error message "the '" . * . "' machine is not defined" ;  key @lstring ;  @uint mInputVariableCount ;  @uint mInputAndInternalVariableCount ;  @M_variablesMap mVariablesMap ;end map ;

#---------------------------------------------------------------------------*end semantics ;#---------------------------------------------------------------------------*#                                                                           *#   S Y N T A X                                                             *#                                                                           *#---------------------------------------------------------------------------*syntax sara_parser :import lexique sara_scanner ;import semantics sara_semantics ;rule <start_symbol> ;rule <modalcompadd_definition>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap variablesMap  !@M_modesMap outModeMap  !@ListForModes outInclusionList;rule <modalcompsub_definition>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap variablesMap  !@M_modesMap outModeMap  !@ListForModes outExclusionList;rule <explicit_automaton>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap outputVariableMap  !@AC_machineDefinition outDefinition;rule <definition_expression>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap outputVariableMap  !@AC_machineDefinition outDefinition;rule <definition_expression_term>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap outputVariableMap  !@AC_machineDefinition outDefinition;rule <definition_expression_factor>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap outputVariableMap  !@AC_machineDefinition outDefinition;rule <component>  ?!@M_machinesMap ioMachinesMap  ?!@L_jobList ioJobList;rule <io_bool_expression>  ?!@M_machinesMap ioMachinesMap
  ?!@M_variablesMap ioVarMap  !@AC_boolExpression outExpression;rule <io_and_expression>   ?!@M_machinesMap ioMachinesMap
  ?!@M_variablesMap ioVarMap  !@AC_boolExpression outExpression;rule <io_primary>   ?!@M_machinesMap ioMachinesMap
  ?!@M_variablesMap ioVarMap  !@AC_boolExpression outExpression;action performComputations  ?!@L_jobList ioJobList;#---------------------------------------------------------------------------*rule <start_symbol>:  @L_jobList componentsMap [empty] ;  @M_machinesMap machinesMap [empty] ;  repeat    <component> !?machinesMap !?componentsMap ;  while  end repeat ;  action performComputations !? componentsMap ;end rule ; #---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap ioMachinesMap  ?!@L_jobList ioJobList:  @M_variablesMap variablesMap [empty] ;  @M_stateMap statesMap [empty] ;  @L_stateDefinition stateDefinitionList [empty] ;#--- Machine name  $check$ ;  @lstring machineName ;  $machineIdf$ ? machineName ;  $;$ ;#--- Insert machine into machine map  @luint machineIndex ;  search ioMachinesMap.searchKey machineName (...) -> machineIndex ;#--- Insert into component map  @AC_job job := [@C_machineCheck new !machineIndex !false] ; ioJobList += !job ;end rule ;

#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap ioMachinesMap  ?!@L_jobList ioJobList:  @M_variablesMap variablesMap [empty] ;  @M_stateMap statesMap [empty] ;  @L_stateDefinition stateDefinitionList [empty] ;#--- Machine name  $checkbool$ ;  @lstring machineName ;  $machineIdf$ ? machineName ;  $;$ ;#--- Insert machine into machine map  @luint machineIndex ;  search ioMachinesMap.searchKey machineName (...) -> machineIndex ;#--- Insert into component map  @AC_job job := [@C_machineCheck new !machineIndex !true] ; ioJobList += !job ;end rule ;

#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap unused ioMachinesMap  ?!@L_jobList ioJobList:  $use_and$ ;  $;$ ;  @AC_job job := [@typeUse_AND new] ;  ioJobList += !job ;end rule ;

#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap unused ioMachinesMap  ?!@L_jobList ioJobList:  $use_ite$ ;  $;$ ;  @AC_job job := [@typeUse_ITE new] ;  ioJobList += !job ;end rule ;

#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap unused ioMachinesMap  ?!@L_jobList ioJobList:  $use_and_ite$ ;  $;$ ;  @AC_job job := [@typeUse_AND_ITE new] ;  ioJobList += !job ;end rule ;#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap unused ioMachinesMap  ?!@L_jobList ioJobList:  $and_cache$ ;  @luint size ;  $literal_integer$ ? size ;  $;$ ;  @AC_job job := [@typeResize_AND_cache new !size] ;  ioJobList += !job ;end rule ;#---------------------------------------------------------------------------*rule <component>  ?!@M_machinesMap unused ioMachinesMap  ?!@L_jobList ioJobList:  $ite_cache$ ;  @luint size ;  $literal_integer$ ? size ;  $;$ ;  @AC_job job := [@typeResize_ITE_cache new !size] ;  ioJobList += !job ;end rule ;#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap unused ioMachinesMap  ?!@L_jobList ioJobList:  $map$ ;  @luint size ;  $literal_integer$ ? size ;  $;$ ;  @AC_job job := [@typeResizeMap new !size] ;  ioJobList += !job ;end rule ;

#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap unused ioMachinesMap  ?!@L_jobList ioJobList:  $bdd$ ;  $;$ ;  @AC_job job := [@typeDisplayBDDstats new] ;  ioJobList += !job ;end rule ;

#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap ioMachinesMap  ?!@L_jobList ioJobList:  @M_variablesMap variablesMap [empty] ;  @M_stateMap statesMap [empty] ;  @L_stateDefinition stateDefinitionList [empty] ;#--- Machine name  @lstring machineName ;  $machineIdf$ ? machineName ;  $($ ;#--- Parse input variables  repeat    @lstring inputVarName ;    $identifier$ ? inputVarName ;    insert variablesMap.insertKey inputVarName () ;  while    $,$ ;  end repeat ;  @uint inputVariablesCount := [variablesMap count] ;  $)$ ;#--- Parse internal variables  $($ ;  select  or    repeat      @lstring outputVarName ;      $identifier$ ? outputVarName ;      insert variablesMap.insertKey outputVarName () ;    while      $,$ ;    end repeat ;  end select ;  $)$ ;  @uint inputAndInternalVariablesCount := [variablesMap count] ;#--- Parse output variables  $($ ;  repeat    @lstring outputVarName ;    $identifier$ ? outputVarName ;    insert variablesMap.insertKey outputVarName () ;  while    $,$ ;  end repeat ;  $)$ ;  $:=$ ;#--- Machine definition  @AC_machineDefinition definition ;  <definition_expression> !?ioMachinesMap !?variablesMap ?definition ;#--- Insert machine into machine map  @luint machineIndex ;  insert ioMachinesMap.insertKey machineName (!inputVariablesCount !inputAndInternalVariablesCount !variablesMap) -> machineIndex ;#--- Insert into component map  @AC_job machine := [@C_machineComponent new !machineName !machineIndex !inputVariablesCount !inputAndInternalVariablesCount !variablesMap !definition] ; ioJobList += !machine ;  $;$ ;end rule ;

#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap ioMachinesMap  ?!@L_jobList ioJobList:  @M_variablesMap variablesMap [empty] ;  @M_stateMap statesMap [empty] ;  @L_stateDefinition stateDefinitionList [empty] ;#--- Machine name  $modalcompadd$ ;  @lstring machineName ;  $machineIdf$ ? machineName ;  $($ ;#--- Parse input variables  repeat    @lstring inputVarName ;    $identifier$ ? inputVarName ;    insert variablesMap.insertKey inputVarName () ;  while    $,$ ;  end repeat ;  @uint inputVariablesCount := [variablesMap count] ;  $)$ ;#--- Parse internal variables  $($ ;  select  or    repeat      @lstring outputVarName ;      $identifier$ ? outputVarName ;      insert variablesMap.insertKey outputVarName () ;    while      $,$ ;    end repeat ;  end select ;  $)$ ;  @uint inputAndInternalVariablesCount := [variablesMap count] ;#--- Parse output variables  $($ ;  repeat    @lstring outputVarName ;    $identifier$ ? outputVarName ;    insert variablesMap.insertKey outputVarName () ;  while    $,$ ;  end repeat ;  $)$ ;  $:=$ ;#--- Machine definition  @M_modesMap modeMap ;  @ListForModes inclusionList ;  <modalcompadd_definition>    !?ioMachinesMap    !?variablesMap    ?modeMap    ?inclusionList  ;#--- Insert machine into machine map  @luint machineIndex ;  insert ioMachinesMap.insertKey machineName (!inputVariablesCount !inputAndInternalVariablesCount !variablesMap) -> machineIndex ;#--- Insert into component map  @AC_job machine := [@C_machineDefinedByAdditiveModalComp new   !machineName   !machineIndex   !inputVariablesCount   !inputAndInternalVariablesCount   !variablesMap   !modeMap   !inclusionList  ] ;  ioJobList += !machine ;  $;$ ;end rule ;

#---------------------------------------------------------------------------*

rule <component>  ?!@M_machinesMap ioMachinesMap  ?!@L_jobList ioJobList:  @M_variablesMap variablesMap [empty] ;  @M_stateMap statesMap [empty] ;  @L_stateDefinition stateDefinitionList [empty] ;#--- Machine name  $modalcompsub$ ;  @lstring machineName ;  $machineIdf$ ? machineName ;  $($ ;#--- Parse input variables  repeat    @lstring inputVarName ;    $identifier$ ? inputVarName ;    insert variablesMap.insertKey inputVarName () ;  while    $,$ ;  end repeat ;  @uint inputVariablesCount := [variablesMap count] ;  $)$ ;#--- Parse internal variables  $($ ;  select  or    repeat      @lstring outputVarName ;      $identifier$ ? outputVarName ;      insert variablesMap.insertKey outputVarName () ;    while      $,$ ;    end repeat ;  end select ;  $)$ ;  @uint inputAndInternalVariablesCount := [variablesMap count] ;#--- Parse output variables  $($ ;  repeat    @lstring outputVarName ;    $identifier$ ? outputVarName ;    insert variablesMap.insertKey outputVarName () ;  while    $,$ ;  end repeat ;  $)$ ;  $:=$ ;#--- Machine definition  @M_modesMap modeMap ;  @ListForModes exclusionList ;  <modalcompsub_definition>    !?ioMachinesMap    !?variablesMap    ?modeMap    ?exclusionList  ;#--- Insert machine into machine map  @luint machineIndex ;  insert ioMachinesMap.insertKey machineName (!inputVariablesCount !inputAndInternalVariablesCount !variablesMap) -> machineIndex ;#--- Insert into component map  @AC_job machine := [@C_machineDefinedBySubstractiveModalComp new   !machineName   !machineIndex   !inputVariablesCount   !inputAndInternalVariablesCount   !variablesMap   !modeMap   !exclusionList  ] ;  ioJobList += !machine ;  $;$ ;end rule ;#---------------------------------------------------------------------------*rule <component>  ?!@M_machinesMap ioMachinesMap  ?!@L_jobList ioJobList:  $scenario$ ;  @M_variablesMap variablesMap [empty] ;  @M_stateMap statesMap [empty] ;  @L_stateDefinition stateDefinitionList [empty] ;#--- Machine name  @lstring machineName ;  $machineIdf$ ? machineName ;#--- Search machine from machine map  @luint machineIndex ;  @uint inputVariablesCountFromDefinition ;  @uint inputAndInternalVariablesCountFromDefinition ;  @M_variablesMap variablesMapFromDefinition ;  search ioMachinesMap.searchKey machineName (?inputVariablesCountFromDefinition ?inputAndInternalVariablesCountFromDefinition ?variablesMapFromDefinition) -> machineIndex ;#--- Parse input variables  $($ ;  repeat    @lstring inputVarName ;    $identifier$ ? inputVarName ;    insert variablesMap.insertKey inputVarName () ;  while    $,$ ;  end repeat ;  @uint inputVariablesCount := [variablesMap count] ;  $)$ ;#--- Check correct number of input variables  if inputVariablesCountFromDefinition != inputVariablesCount then    error here : "This declaration names " . [inputVariablesCount string]      . " input variable(s), but machine definition names " . [inputVariablesCountFromDefinition string] . " input variable(s)" ;  end if ;#--- Parse internal variables  $($ ;  select  or    repeat      @lstring outputVarName ;      $identifier$ ? outputVarName ;      insert variablesMap.insertKey outputVarName () ;    while      $,$ ;    end repeat ;  end select ;  $)$ ;#--- Check correct number of internal variables  @uint inputAndInternalVariablesCount := [variablesMap count] ;  if inputAndInternalVariablesCountFromDefinition != inputAndInternalVariablesCount then    error here : "This declaration names " . [inputAndInternalVariablesCount string]      . " input and internal variable(s), but machine definition names " . [inputAndInternalVariablesCountFromDefinition string] . " input and internal variable(s)" ;  end if ;#--- Parse output variables  $($ ;  repeat    @lstring outputVarName ;    $identifier$ ? outputVarName ;    insert variablesMap.insertKey outputVarName () ;  while    $,$ ;  end repeat ;  $)$ ;#--- Check correct number of internal variables  @uint outputVariablesCount := [variablesMap count] ;  @uint outputVariablesCountFromDefinition := [variablesMapFromDefinition count] ;  if outputVariablesCountFromDefinition != outputVariablesCount then    error here : "This declaration names " . [outputVariablesCount string]      . " variables, but machine definition names " . [outputVariablesCountFromDefinition string] . " variables" ;  end if ;  ${$ ;  @L_scenarioList scenarioList [empty] ;  repeat    @lstring scenarioTitle ;    $literal_string$ ? scenarioTitle ;    @L_inputScenario inputScenario [empty] ;    repeat      $:$ ;      @L_inputConfigurationForScenario inputConfigurationForScenario [empty] ;      repeat       @luint v ;       $literal_integer$  ? v ;       if [v value] > 1 then         error v : "this value is not a  binary digit" ;       end if ;       inputConfigurationForScenario += !v ;      while       $,$ ;      end repeat ;      if inputVariablesCount != [inputConfigurationForScenario length] then        error here : "this input configuration names " . [[inputConfigurationForScenario length] string] . " input variable(s), instead of " . [inputVariablesCount string] ;      end if ;      inputScenario += !inputConfigurationForScenario ;    while    end repeat ;    $;$ ;    scenarioList += !scenarioTitle !inputScenario ;  while  end repeat ;  $}$ ;#--- Insert job into job list  @AC_job machine := [@C_scenarioComponent new !machineIndex !inputVariablesCount !inputAndInternalVariablesCount !variablesMap !scenarioList] ; ioJobList += !machine ;end rule ;

#---------------------------------------------------------------------------*

rule <io_bool_expression>  ?!@M_machinesMap ioMachinesMap
  ?!@M_variablesMap ioVarMap  !@AC_boolExpression outExpression:  <io_and_expression> !?ioMachinesMap !?ioVarMap ?outExpression ;  repeat  while    $|$ ;    @AC_boolExpression rightExpression ;    <io_and_expression> !?ioMachinesMap !?ioVarMap ?rightExpression ;    outExpression := [@C_orExpression new ! outExpression ! rightExpression] ;  while    $^$ ;    @AC_boolExpression rightExpression ;    <io_and_expression> !?ioMachinesMap !?ioVarMap ?rightExpression ;    outExpression := [@C_xorExpression new ! outExpression ! rightExpression] ;  while    $->$ ;    @AC_boolExpression rightExpression ;    <io_and_expression> !?ioMachinesMap !?ioVarMap ?rightExpression ;    outExpression := [@C_impliesExpression new ! outExpression ! rightExpression] ;  while    $=$ ;    @AC_boolExpression rightExpression ;    <io_and_expression> !?ioMachinesMap !?ioVarMap ?rightExpression ;    outExpression := [@C_equalExpression new ! outExpression ! rightExpression] ;  end repeat ;end rule ;

#---------------------------------------------------------------------------*

rule <io_and_expression>   ?!@M_machinesMap ioMachinesMap
  ?!@M_variablesMap ioVarMap  !@AC_boolExpression outExpression:  <io_primary> !?ioMachinesMap !?ioVarMap ?outExpression ;  repeat  while    $&$ ;    @AC_boolExpression rightExpression ;    <io_primary> !?ioMachinesMap !?ioVarMap ?rightExpression ;    outExpression := [@C_andExpression new ! outExpression !rightExpression] ;  end repeat ;end rule ;

#---------------------------------------------------------------------------*

rule <io_primary>   ?!@M_machinesMap ioMachinesMap
  ?!@M_variablesMap ioVarMap  !@AC_boolExpression outExpression:  $($ ;  <io_bool_expression> !?ioMachinesMap !?ioVarMap ?outExpression ;  $)$ ;end rule ;

#---------------------------------------------------------------------------*

rule <io_primary>   ?!@M_machinesMap unused ioMachinesMap
  ?!@M_variablesMap ioVarMap  !@AC_boolExpression outExpression:  @lstring inputVarName ;  $identifier$ ? inputVarName ;  @luint inputVarIndex ;  search ioVarMap.searchKey inputVarName () -> inputVarIndex ;  outExpression := [@C_VariableExpression new !inputVarIndex] ;end rule ;

#---------------------------------------------------------------------------*

rule <io_primary>   ?!@M_machinesMap ioMachinesMap
  ?!@M_variablesMap ioVarMap  !@AC_boolExpression outExpression:  $~$ ;  @AC_boolExpression expression ;  <io_primary> !?ioMachinesMap !?ioVarMap ? expression ;  outExpression := [@C_notExpression new ! expression] ;end rule ;

#---------------------------------------------------------------------------*

rule <io_primary>   ?!@M_machinesMap unused ioMachinesMap
  ?!@M_variablesMap unused ioVarMap  !@AC_boolExpression outExpression:  $false$ ;  outExpression := [@C_falseExpression new] ;end rule ;

#---------------------------------------------------------------------------*

rule <io_primary>   ?!@M_machinesMap unused ioMachinesMap
  ?!@M_variablesMap unused ioVarMap  !@AC_boolExpression outExpression:  $true$ ;  outExpression := [@C_trueExpression new] ;end rule ;

#---------------------------------------------------------------------------*

rule <io_primary>   ?!@M_machinesMap ioMachinesMap
  ?!@M_variablesMap ioVarMap  !@AC_boolExpression outExpression
:  @lstring machineIdentifier ;  $machineIdf$ ? machineIdentifier ;  @uint machineInputVariableCount ;  @uint machineInputAndInternalVariableCount ;  @M_variablesMap machineVariablesMap ;  @luint indexOfImportedMachine ;  search ioMachinesMap.searchKey machineIdentifier (?machineInputVariableCount ?machineInputAndInternalVariableCount ?machineVariablesMap) -> indexOfImportedMachine ;  @L_translationVector translationVector [empty] ;#--- Parse input variables  $($ ;  repeat    @lstring inputVar ;    $identifier$ ? inputVar ;    @luint inputVarIndex ;    search ioVarMap.searchKey inputVar () -> inputVarIndex ;    translationVector += !inputVarIndex ;  while    $,$ ;  end repeat ;  $)$ ;  @uint inputVariablesCount := [translationVector length] ;  if inputVariablesCount != machineInputVariableCount then    error here : "The '$" . [machineIdentifier value] . "' machine defines " . [machineInputVariableCount string]    . " input variable(s), but this operand defines " . [inputVariablesCount string] . " input variable(s)" ;  end if ;#--- Parse internal variables  $($ ;  select  or    repeat      @lstring internalVar ;      $identifier$ ? internalVar ;      @luint internalVarIndex ;      search ioVarMap.searchKey internalVar () -> internalVarIndex ;      translationVector += ! internalVarIndex ;    while      $,$ ;    end repeat ;  end select ;  $)$ ;  @uint inputAndInternalVariablesCount := [translationVector length] ;  if inputAndInternalVariablesCount != machineInputAndInternalVariableCount then    error here : "The '$" . [machineIdentifier value] . "' machine defines " . [machineInputAndInternalVariableCount string]    . " input and internal variable(s), but this operand defines " . [inputAndInternalVariablesCount string] . " input and internal variable(s)" ;  end if ;#--- Parse output variables  $($ ;  repeat    @lstring outputVar ;    $identifier$ ? outputVar ;    @luint outputVarIndex ;    search ioVarMap.searchKey outputVar () -> outputVarIndex ;    translationVector += !outputVarIndex ;  while    $,$ ;  end repeat ;  $)$ ;  @uint allVariablesCount := [translationVector length] ;  @uint machineAllVariablesCount := [machineVariablesMap count] ;  if allVariablesCount != machineAllVariablesCount then    error here : "The '$" . [machineIdentifier value] . "' machine defines " . [machineAllVariablesCount string]    . " variables, but this operand defines " . [allVariablesCount string] . " variables" ;  end if ;  outExpression := [@C_importBoolMachine new
    ![indexOfImportedMachine value]
    ![machineIdentifier location]
    !translationVector]
  ;end rule ;

#---------------------------------------------------------------------------*#         DEFINITION EXPRESSION                                             *#---------------------------------------------------------------------------*

rule <definition_expression>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap variablesMap  !@AC_machineDefinition outDefinition:  <definition_expression_term> !?ioMachinesMap !?variablesMap ?outDefinition ;end rule ;

#---------------------------------------------------------------------------*

rule <definition_expression_term>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap variablesMap  !@AC_machineDefinition outDefinition:  <definition_expression_factor> !?ioMachinesMap !? variablesMap ?outDefinition ;  repeat  while    $*$ ;    @location errorLocation := here ;    @AC_machineDefinition leftOperand := outDefinition ;    @AC_machineDefinition rightOperand ;    <definition_expression_factor> !?ioMachinesMap !? variablesMap ?rightOperand ;    outDefinition := [@C_strongModalComposition new !leftOperand !errorLocation !rightOperand] ;  while    $**$ ;    @location errorLocation := here ;    @AC_machineDefinition leftOperand := outDefinition ;    @AC_machineDefinition rightOperand ;    <definition_expression_factor> !?ioMachinesMap !? variablesMap ?rightOperand ;    outDefinition := [@C_weakModalComposition new !leftOperand !errorLocation !rightOperand] ;  while    $||$ ;    @AC_machineDefinition leftOperand := outDefinition ;    @AC_machineDefinition rightOperand ;    <definition_expression_factor> !?ioMachinesMap !? variablesMap ?rightOperand ;    outDefinition := [@C_parallelComposition new !leftOperand !rightOperand] ;  end repeat ;end rule ;

#---------------------------------------------------------------------------*

rule <modalcompadd_definition>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap variablesMap  !@M_modesMap outModeMap  !@ListForModes outInclusionList:  outModeMap := [@M_modesMap empty] ;  outInclusionList := [@ListForModes empty] ;  repeat    @lstring modeName ;    $identifier$ ? modeName ;    $:$ ;    @AC_machineDefinition def ;    <definition_expression> !?ioMachinesMap !?variablesMap ?def ;    insert outModeMap.insertKey modeName (!def) ;    $;$ ;  while  end repeat ;  repeat  while    $include$ ;    @lstring sourceModeName ;    $identifier$ ? sourceModeName ;    @luint sourceModeIndex ;    search outModeMap.searchKey sourceModeName (...) -> sourceModeIndex ;    $to$ ;    @lstring targetModeName ;    $identifier$ ? targetModeName ;    @luint targetModeIndex ;    search outModeMap.searchKey targetModeName (...) -> targetModeIndex ;    $;$ ;    if [sourceModeIndex value] == [targetModeIndex value] then      warning targetModeIndex : "unuseful include: 'modalcompadd' operator never adds transitions from terminal states to initial states of the same mode" ;    else      outInclusionList += !sourceModeIndex !targetModeIndex ;    end if ;  end repeat ;end rule ;

#---------------------------------------------------------------------------*

rule <modalcompsub_definition>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap variablesMap  !@M_modesMap outModeMap  !@ListForModes outExclusionList:  outModeMap := [@M_modesMap empty] ;  outExclusionList := [@ListForModes empty] ;  repeat    @lstring modeName ;    $identifier$ ? modeName ;    $:$ ;    @AC_machineDefinition def ;    <definition_expression> !?ioMachinesMap !?variablesMap ?def ;    insert outModeMap.insertKey modeName (!def) ;    $;$ ;  while  end repeat ;  repeat  while    $exclude$ ;    @lstring sourceModeName ;    $identifier$ ? sourceModeName ;    @luint sourceModeIndex ;    search outModeMap.searchKey sourceModeName (...) -> sourceModeIndex ;    $to$ ;    @lstring targetModeName ;    $identifier$ ? targetModeName ;    @luint targetModeIndex ;    search outModeMap.searchKey targetModeName (...) -> targetModeIndex ;    $;$ ;    if [sourceModeIndex value] == [targetModeIndex value] then      warning targetModeIndex : "unuseful include: 'modalcompadd' operator never adds transitions from terminal states to initial states of the same mode" ;    else      outExclusionList += !sourceModeIndex !targetModeIndex ;    end if ;  end repeat ;end rule ;

#---------------------------------------------------------------------------*

rule <definition_expression_factor>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap variablesMap  !@AC_machineDefinition outDefinition:  select    <explicit_automaton> !?ioMachinesMap !?variablesMap ?outDefinition ;  or    $($ ;    <definition_expression> !?ioMachinesMap !? variablesMap ?outDefinition ;    $)$ ;  or    @M_variablesMap extendedVariablesMap := variablesMap ;    @uint previousVariableCount := [extendedVariablesMap count] ;    $?$ ;    repeat      @lstring variableName ;      $identifier$ ? variableName ;      insert extendedVariablesMap.insertKey variableName () ;    while      $,$ ;    end repeat ;    @uint actualVariableCount := [extendedVariablesMap count] ;    $($ ;    @AC_machineDefinition def ;    <definition_expression> !?ioMachinesMap !?extendedVariablesMap ?def ;    $)$ ;    outDefinition := [@C_existsDefinition new !previousVariableCount !actualVariableCount !def] ;  or    $bool$ ;
    ${$ ;    @AC_boolExpression def ;    <io_bool_expression> !?ioMachinesMap !?variablesMap ?def ;    outDefinition := [@C_boolToSeqExpression new !def] ;
    $}$ ;  or    $@$ ;    @AC_machineDefinition def ;    <definition_expression_factor> !?ioMachinesMap !? variablesMap ?def ;    outDefinition := [@C_fullSaturationOperation new !def] ;  or    $nofirst$ ;    $($ ;    @AC_machineDefinition def ;    <definition_expression> !?ioMachinesMap !? variablesMap ?def ;    outDefinition := [@C_suppressInitialStatesOperation new !def] ;    $)$ ;  or    $nolast$ ;    $($ ;    @AC_machineDefinition def ;    <definition_expression> !?ioMachinesMap !? variablesMap ?def ;    outDefinition := [@C_suppressTerminalStatesOperation new !def] ;    $)$ ;  or    $modalcompadd$ ;    ${$ ;    @M_modesMap modeMap ;    @ListForModes inclusionList ;    <modalcompadd_definition>      !?ioMachinesMap      !?variablesMap      ?modeMap      ?inclusionList    ;    $}$ ;    outDefinition := [@C_additiveModalCompositionComponent new !modeMap !inclusionList] ;  or    $modalcompsub$ ;    ${$ ;    @M_modesMap modeMap ;    @ListForModes exclusionList ;    <modalcompsub_definition>      !?ioMachinesMap      !?variablesMap      ?modeMap      ?exclusionList    ;    $}$ ;    outDefinition := [@C_substractiveModalCompositionComponent new !modeMap !exclusionList] ;  or    $trans$ ;    ${$ ;    @AC_boolExpression sourceExpression ;    <io_bool_expression> !?ioMachinesMap !?variablesMap ?sourceExpression ;    $to$ ;    @AC_boolExpression targetExpression ;    <io_bool_expression> !?ioMachinesMap !?variablesMap ?targetExpression ;    $}$ ;    outDefinition := [@C_trans new !sourceExpression !targetExpression] ;  end select ;end rule ;

#---------------------------------------------------------------------------*

rule <definition_expression_factor>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap ioVarMap  !@AC_machineDefinition outDefinition:  @lstring machineIdentifier ;  $machineIdf$ ? machineIdentifier ;  @uint machineInputVariableCount ;  @uint machineInputAndInternalVariableCount ;  @M_variablesMap machineVariablesMap ;  @luint indexOfImportedMachine ;  search ioMachinesMap.searchKey machineIdentifier (?machineInputVariableCount ?machineInputAndInternalVariableCount ?machineVariablesMap) -> indexOfImportedMachine ;  @L_translationVector translationVector [empty] ;#--- Parse input variables  $($ ;  repeat    @lstring inputVar ;    $identifier$ ? inputVar ;    @luint inputVarIndex ;    search ioVarMap.searchKey inputVar () -> inputVarIndex ;    translationVector += !inputVarIndex ;  while    $,$ ;  end repeat ;  $)$ ;  @uint inputVariablesCount := [translationVector length] ;  if inputVariablesCount != machineInputVariableCount then    error here : "The '$" . [machineIdentifier value] . "' machine defines " . [machineInputVariableCount string]    . " input variable(s), but this operand defines " . [inputVariablesCount string] . " input variable(s)" ;  end if ;#--- Parse internal variables  $($ ;  select  or    repeat      @lstring internalVar ;      $identifier$ ? internalVar ;      @luint internalVarIndex ;      search ioVarMap.searchKey internalVar () -> internalVarIndex ;      translationVector += ! internalVarIndex ;    while      $,$ ;    end repeat ;  end select ;  $)$ ;  @uint inputAndInternalVariablesCount := [translationVector length] ;  if inputAndInternalVariablesCount != machineInputAndInternalVariableCount then    error here : "The '$" . [machineIdentifier value] . "' machine defines " . [machineInputAndInternalVariableCount string]    . " input and internal variable(s), but this operand defines " . [inputAndInternalVariablesCount string] . " input and internal variable(s)" ;  end if ;#--- Parse output variables  $($ ;  repeat    @lstring outputVar ;    $identifier$ ? outputVar ;    @luint outputVarIndex ;    search ioVarMap.searchKey outputVar () -> outputVarIndex ;    translationVector += !outputVarIndex ;  while    $,$ ;  end repeat ;  $)$ ;  @uint allVariablesCount := [translationVector length] ;  @uint machineAllVariablesCount := [machineVariablesMap count] ;  if allVariablesCount != machineAllVariablesCount then    error here : "The '$" . [machineIdentifier value] . "' machine defines " . [machineAllVariablesCount string]    . " variables, but this operand defines " . [allVariablesCount string] . " variables" ;  end if ;  outDefinition := [@C_importMachine new ![indexOfImportedMachine value] !translationVector] ;end rule ;

#---------------------------------------------------------------------------*#         EXPLICIT AUTOMATON                                                *#---------------------------------------------------------------------------*

rule <explicit_automaton>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap variablesMap  !@AC_machineDefinition outDefinition:  @M_stateMap statesMap [empty] ;  @L_stateDefinition stateDefinitionList [empty] ;  $auto$ ;  ${$ ;#--- States declaration  $state$ ;  repeat    @lstring stateName ;    $identifier$ ? stateName ;    insert statesMap.insertKey stateName () ;  while    $,$ ;  end repeat ;  $;$ ;#--- Initial states  @L_statesDefinitionList initialStatesDefinitionList [empty] ;  $first$ ;  repeat    @lstring initialState ;    $identifier$ ? initialState ;    @luint initialStateIndex ;    search statesMap.searchKey initialState () -> initialStateIndex ;    initialStatesDefinitionList += !initialStateIndex !here ;  while    $,$ ;  end repeat ;  $;$ ;#--- terminal states  @L_statesDefinitionList terminalStatesDefinitionList [empty] ;  select  or    $last$ ;    repeat      @lstring terminalState ;      $identifier$ ? terminalState ;      @luint terminalStateIndex ;      search statesMap.searchKey terminalState () -> terminalStateIndex ;      terminalStatesDefinitionList += ! terminalStateIndex !here ;    while      $,$ ;    end repeat ;    $;$ ;  end select ;#--- Parse state definitions  @M_stateMap stateDefinitionMap [empty] ;  repeat  #--- Current state    @lstring stateName ;    $identifier$ ? stateName ;    @luint stateIndex ;    search statesMap.searchKey stateName () -> stateIndex ;    insert stateDefinitionMap.defineState stateName () ;    $:$ ;  #--- State input expression    @AC_boolExpression stateExpression ;    <io_bool_expression> !?ioMachinesMap !?variablesMap ?stateExpression ;    @location endOfStateExpression := here ;    ${$ ;  #--- Parse state transition    @L_transitionDefinition transitionsList [empty] ;    repeat    while      @AC_boolExpression transitionInputExpression ;      <io_bool_expression> !?ioMachinesMap !?variablesMap ?transitionInputExpression ;      @location endOfExpression := here ;      $goto$ ;      @lstring targetStateName ;      $identifier$ ? targetStateName ;      @luint targetStateIndex ;      search statesMap.searchKey targetStateName () -> targetStateIndex ;      transitionsList += !transitionInputExpression !endOfExpression !targetStateIndex ;      $;$ ;    end repeat ;    $}$ ;    stateDefinitionList += !stateIndex !stateExpression !endOfStateExpression                           !transitionsList ;  while  end repeat ;#--- Check all states are defined  foreach statesMap (??@lstring kStateName) :    if not [stateDefinitionMap hasKey ! kStateName] then      error here : "'" . [kStateName value] . "' state is not described" ;    end if ;  end foreach ;#--- End of input source  $}$ ;  outDefinition := [@C_explicitAutomatonDefinition new !statesMap !initialStatesDefinitionList !terminalStatesDefinitionList !stateDefinitionList !here] ;end rule ;

#---------------------------------------------------------------------------*

end syntax ;#---------------------------------------------------------------------------*#                                                                           *#   C O M M A N D    L I N E    O P T I O N S                               *#                                                                           *#---------------------------------------------------------------------------*option sara_cli_options :  @bool displayBDDvaluesCount : 'c', "display-bdd-values-count" -> "displays values count for every BDD" ;  @bool displayBDDvalues : 'v', "display-bdd-values" -> "displays values for every BDD" ;end option ;
#---------------------------------------------------------------------------*#                                                                           *#   G R A M M A R                                                           *#                                                                           *#---------------------------------------------------------------------------*grammar sara_grammar "LL1" :  import lexique sara_scanner ;  import option sara_cli_options ;  import syntax sara_parser ;  start <start_symbol> ;end grammar ;
#---------------------------------------------------------------------------*#                                                                           *#   C O C O A                                                               *#                                                                           *#---------------------------------------------------------------------------*

cocoa cocoa_sara : program "sara" ; import grammar sara_grammar ;end cocoa ;#---------------------------------------------------------------------------*#                                                                           *#   P R O G R A M                                                           *#                                                                           *#---------------------------------------------------------------------------*program sara_main "version 0.3.0" . "sara" :  import grammar sara_grammar ;#--- max error and warning count  error 100 ;  warning 100 ;end program ;#--------------------------------------------------------------------------------*