#---------------------------------------------------------------------------*#                                                                           *#   L E X I Q U E                                                           *#                                                                           *#---------------------------------------------------------------------------*lexique sara_scanner :header "galgas/F_LexicalActions.h" ;
@lstring identifierString ;@luint ulongValue ;
style identifier -> "Identifiers" ;style keyWords -> "Key words" ;style machineNameStyle -> "Machine names" ;style delimitors -> "Delimitors" ;style integer_csts -> "Integer constants" ;style stringStyle -> "Character strings" ;# -------------------------- identifier or key word --------------------# keywords can be written in lower# for identifiers, case is significant$identifier$ ! identifierString error message "an identifier" style identifier ;list keyWordList error message "the '" . * . "' key word" style keyWords : "auto", "state", "first", "last", "goto", "timer", "all", "none", "check", "nolast", "modalcomp", "exclude", "to", "scenario", "trans", "ite_cache", "and_cache", "map", "bdd", "use_and", "use_ite", "use_and_ite" ;rule 'a'->'z' | 'A'->'Z' :  repeat    enterCharacterIntoString (identifierString, *) ;  while 'a'->'z' | 'A'->'Z' | '_' | '0'->'9' :  end repeat ;  send search identifierString in keyWordList default $identifier$ ;end rule ;
# -------------------------- Delimitors -------------------------------list delimitorsList error message "the '" . * . "' delimitor" style delimitors :  ",", ";", ":", "{", "}", "->", "&", "~", "?", "|", "(", ")", ":=", "^", "=", "*", "@", "**" ;rule list delimitorsList ;
# -------------------- Characters string --------------------------------------$literal_string$ ! identifierString error message "a character string constant \"...\"" style stringStyle ;message incorrectStringEnd : "string does not end with '\"'" ;message incorrectCharInString : "this character cannot appear within a string" ;
rule '"' :  repeat  while '\\' :    select    when 'n' :      enterCharacterIntoString (identifierString, '\n') ;    when '\\' :      enterCharacterIntoString (identifierString, '\\') ;    when '"' :      enterCharacterIntoString (identifierString, '"') ;    default      error incorrectCharInString ;    end select ;   while ' ' | '!' | '#'-> '\127' :    enterCharacterIntoString (identifierString, *) ;  end repeat ;  select  when '"' :    send $literal_string$ ;  default    error incorrectStringEnd ;  end select ;end rule ;
# -------------------------- Machine name -----------------------------$machineIdf$ ! identifierString error message "a machine name ($...)" style machineNameStyle ;message incorrectMachineNameBeginning : "incorrect machine name beginning" ;rule '$' :  select  when 'a'->'z' | 'A'->'Z' | '_' :    repeat      enterCharacterIntoString (identifierString, *) ;    while 'a'->'z' | 'A'->'Z' | '_' | '0'->'9' :    end repeat ;  default    error incorrectMachineNameBeginning ;  end select ;  send $machineIdf$ ; end rule ;#------------------------------- Decimal positive number ------------------$literal_integer$ ! ulongValue error message "a decimal number" style integer_csts ;message decimalNumberTooLarge : "decimal number too large" ;message internalError : "internal error" ;rule '0'->'9' :  enterDigitIntoUlong (ulongValue, *) error decimalNumberTooLarge, internalError ;  repeat  while '0'->'9' :    enterDigitIntoUlong (ulongValue, *) error decimalNumberTooLarge, internalError ;  while '_' :  end repeat ;  send $literal_integer$ ;end rule ;#--- separators  rule '\1' -> ' ' :  end rule ;
#------------------------------------ Comment ----------------------------message incorrectEndOfComment : "incorrect end of comment" ;rule '#' :  repeat  while '\1' ->'\t' | '\v'-> '\255' :  end repeat ;  select  when '\n' :  default    error incorrectEndOfComment ;  end select ;end rule ;end lexique ;#---------------------------------------------------------------------------*#                                                                           *#   S E M A N T I C S                                                       *#                                                                           *#---------------------------------------------------------------------------*semantics sara_semantics :  map @M_variablesMap    insert insertKey error message "the '" . * . "' variable has been already declared" ;    search searchKey error message "the '" . * . "' variable is not declared" ;    key @lstring ;  end map ;  map @M_stateMap    insert insertKey error message "the '" . * . "' state has been already declared" ;    insert defineState error message "the '" . * . "' state has been already defined" ;    search searchKey error message "the '" . * . "' state is not declared" ;    key @lstring ;  end map ;
#---------------------------------------------------------------------------*  abstract class @AC_expression    include header ;  end class ;
  class @C_andExpression extends @AC_expression    @AC_expression mLeftExpression ;    @AC_expression mRightExpression ;  end class ;    class @C_orExpression extends @AC_expression     @AC_expression mLeftExpression ;    @AC_expression mRightExpression ;  end class ;    class @C_xorExpression extends @AC_expression     @AC_expression mLeftExpression ;    @AC_expression mRightExpression ;  end class ;    class @C_impliesExpression extends @AC_expression     @AC_expression mLeftExpression ;    @AC_expression mRightExpression ;  end class ;    class @C_equalExpression extends @AC_expression     @AC_expression mLeftExpression ;    @AC_expression mRightExpression ;  end class ;    class @C_notExpression extends @AC_expression     @AC_expression mExpression ;  end class ;      class @C_VariableExpression extends @AC_expression     @luint mInputVarIndex ;  end class ;
  class @C_trueExpression extends @AC_expression   end class ;
  class @C_falseExpression extends @AC_expression   end class ;
#---------------------------------------------------------------------------*
list @L_transitionDefinition  @AC_expression mActionExpression ;  @location mEndOfExpression ;  @luint mTargetStateIndex ;end list ;list @L_stateDefinition  @luint mStateIndex ;  @AC_expression mStateExpression ;  @location mEndOfStateExpression ;  @L_transitionDefinition mTransitionsList ;end list ;
#---------------------------------------------------------------------------*
list @L_statesDefinitionList  @luint mStateIndex ;  @location mStateLocation ;end list ;
#---------------------------------------------------------------------------*
abstract class @AC_machineDefinition  include header ; end class ;
map @M_modesMap  insert insertKey error message "the '" . * . "' mode has been already declared" ;  search searchKey error message "the '" . * . "' mode is not declared" ;  key @lstring ;  @AC_machineDefinition mModeDefinition ;end map ;list @L_exclusionListForModes  @luint mExcludedSourceMode ;  @luint mExcludedTargetMode ;end list ;class @C_modalCompositionComponent extends @AC_machineDefinition  @M_modesMap mModeMap ;  @L_exclusionListForModes mExclusionList ;end class ;
class @C_trans extends @AC_machineDefinition  @AC_expression mSourceStateExpression ;  @AC_expression mTargetStateExpression ;end class ;
list @L_translationVector  @luint mTargetSlot ;end list ;  class @C_importMachine extends @AC_machineDefinition  @uint mIndexOfImportedMachine ;  @L_translationVector mTranslationVector ;end class ;
class @C_explicitAutomatonDefinition extends @AC_machineDefinition  @M_stateMap mStatesMap ;  @L_statesDefinitionList mInitialStatesDefinitionList ;  @L_statesDefinitionList mTerminalStatesDefinitionList ;  @L_stateDefinition mStateDefinitionList ;  @location mEndOfDefinition ;end class ;
class @C_variableDefinition extends @AC_machineDefinition  @luint mInputOutputVariableIndex ;end class ;
class @C_existsDefinition extends @AC_machineDefinition  @uint mPreviousVariableCount ;  @uint mTotalVariableCount ;  @AC_machineDefinition mOperand ;end class ;
class @C_andComposition extends @AC_machineDefinition  @AC_machineDefinition mLeftOperand ;  @AC_machineDefinition mRightOperand ;end class ;
class @C_orComposition extends @AC_machineDefinition  @AC_machineDefinition mLeftOperand ;  @AC_machineDefinition mRightOperand ;end class ;
class @C_equalComposition extends @AC_machineDefinition  @AC_machineDefinition mLeftOperand ;  @AC_machineDefinition mRightOperand ;end class ;
class @C_xorComposition extends @AC_machineDefinition  @AC_machineDefinition mLeftOperand ;  @AC_machineDefinition mRightOperand ;end class ;
class @C_impliesComposition extends @AC_machineDefinition  @AC_machineDefinition mLeftOperand ;  @AC_machineDefinition mRightOperand ;end class ;
class @C_strongModalComposition extends @AC_machineDefinition  @AC_machineDefinition mLeftOperand ;  @location mErrorLocation ;  @AC_machineDefinition mRightOperand ;end class ;
class @C_weakModalComposition extends @AC_machineDefinition  @AC_machineDefinition mLeftOperand ;  @location mErrorLocation ;  @AC_machineDefinition mRightOperand ;end class ;
class @C_notComposition extends @AC_machineDefinition  @AC_machineDefinition mOperand ;end class ;
class @C_fullSaturationOperation extends @AC_machineDefinition  @AC_machineDefinition mOperand ;end class ;
class @C_suppressTerminalStatesOperation extends @AC_machineDefinition  @AC_machineDefinition mOperand ;end class ;
#---------------------------------------------------------------------------*
abstract class @AC_job  include header ;end class ; class @C_machineCheck extends @AC_job  @luint mMachineIndex ;end class ;
class @C_machineComponent extends @AC_job  @lstring mMachineName ;  @luint mMachineIndex ;  @uint mInputVariableCount ;  @uint mInputAndInternalVariableCount ;  @M_variablesMap mVariablesMap ;  @AC_machineDefinition mDefinition ;end class ;
list @L_inputConfigurationForScenario  @luint mInputValue ;end list ;list @L_inputScenario  @L_inputConfigurationForScenario mInputConfiguration ;end list ;list @L_scenarioList  @lstring mScenarioTitle ;  @L_inputScenario mInputScenario ;end list ;class @C_scenarioComponent extends @AC_job  @luint mMachineIndex ;  @uint mInputVariableCount ;  @uint mInputAndInternalVariableCount ;  @M_variablesMap mVariablesMap ;  @L_scenarioList mScenarioList ;end class ;
class @typeUse_AND extends @AC_jobend class ;class @typeUse_ITE extends @AC_jobend class ;class @typeUse_AND_ITE extends @AC_jobend class ;class @typeResize_AND_cache extends @AC_job  @luint mNewSize ;end class ;class @typeResize_ITE_cache extends @AC_job  @luint mNewSize ;end class ;class @typeResizeMap extends @AC_job  @luint mNewSize ;end class ;class @typeDisplayBDDstats extends @AC_jobend class ;#---------------------------------------------------------------------------*
list @L_jobList  @AC_job mComponent ;end list ;
#---------------------------------------------------------------------------*
map @M_machinesMap  insert insertKey error message "the '" . * . "' machine has been already declared" ;  search searchKey error message "the '" . * . "' machine is not defined" ;  key @lstring ;  @uint mInputVariableCount ;  @uint mInputAndInternalVariableCount ;  @M_variablesMap mVariablesMap ;end map ;
#---------------------------------------------------------------------------*end semantics ;#---------------------------------------------------------------------------*#                                                                           *#   S Y N T A X                                                             *#                                                                           *#---------------------------------------------------------------------------*syntax sara_parser :import lexique sara_scanner ;import semantics sara_semantics ;rule <start_symbol> ;rule <explicit_automaton>  ?!@M_variablesMap outputVariableMap  !@AC_machineDefinition outDefinition;rule <definition_expression>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap outputVariableMap  !@AC_machineDefinition outDefinition;rule <definition_expression_term>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap outputVariableMap  !@AC_machineDefinition outDefinition;rule <definition_expression_factor>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap outputVariableMap  !@AC_machineDefinition outDefinition;rule <component>  ?!@M_machinesMap ioMachinesMap  ?!@L_jobList ioJobList;rule <io_expression>  ?!@M_variablesMap ioVarMap  !@AC_expression outExpression;rule <io_and_expression>   ?!@M_variablesMap ioVarMap  !@AC_expression outExpression;rule <io_primary>   ?!@M_variablesMap ioVarMap  !@AC_expression outExpression;action performComputations  ?!@L_jobList ioJobList;#---------------------------------------------------------------------------*rule <start_symbol>:  @L_jobList componentsMap [empty] ;  @M_machinesMap machinesMap [empty] ;  repeat    <component> !?machinesMap !?componentsMap ;  while  end repeat ;  action performComputations !? componentsMap ;end rule ; #---------------------------------------------------------------------------*
rule <component>  ?!@M_machinesMap ioMachinesMap  ?!@L_jobList ioJobList:  @M_variablesMap variablesMap [empty] ;  @M_stateMap statesMap [empty] ;  @L_stateDefinition stateDefinitionList [empty] ;#--- Machine name  $check$ ;  @lstring machineName ;  $machineIdf$ ? machineName ;  $;$ ;#--- Insert machine into machine map  @luint machineIndex ;  search ioMachinesMap.searchKey machineName (...) -> machineIndex ;#--- Insert into component map  @AC_job job := [@C_machineCheck new !machineIndex] ; ioJobList += !job ;end rule ;
#---------------------------------------------------------------------------*
rule <component>  ?!@M_machinesMap unused ioMachinesMap  ?!@L_jobList ioJobList:  $use_and$ ;  $;$ ;  @AC_job job := [@typeUse_AND new] ;  ioJobList += !job ;end rule ;
#---------------------------------------------------------------------------*
rule <component>  ?!@M_machinesMap unused ioMachinesMap  ?!@L_jobList ioJobList:  $use_ite$ ;  $;$ ;  @AC_job job := [@typeUse_ITE new] ;  ioJobList += !job ;end rule ;
#---------------------------------------------------------------------------*
rule <component>  ?!@M_machinesMap unused ioMachinesMap  ?!@L_jobList ioJobList:  $use_and_ite$ ;  $;$ ;  @AC_job job := [@typeUse_AND_ITE new] ;  ioJobList += !job ;end rule ;#---------------------------------------------------------------------------*
rule <component>  ?!@M_machinesMap unused ioMachinesMap  ?!@L_jobList ioJobList:  $and_cache$ ;  @luint size ;  $literal_integer$ ? size ;  $;$ ;  @AC_job job := [@typeResize_AND_cache new !size] ;  ioJobList += !job ;end rule ;#---------------------------------------------------------------------------*
rule <component>  ?!@M_machinesMap unused ioMachinesMap  ?!@L_jobList ioJobList:  $ite_cache$ ;  @luint size ;  $literal_integer$ ? size ;  $;$ ;  @AC_job job := [@typeResize_ITE_cache new !size] ;  ioJobList += !job ;end rule ;#---------------------------------------------------------------------------*
rule <component>  ?!@M_machinesMap unused ioMachinesMap  ?!@L_jobList ioJobList:  $map$ ;  @luint size ;  $literal_integer$ ? size ;  $;$ ;  @AC_job job := [@typeResizeMap new !size] ;  ioJobList += !job ;end rule ;
#---------------------------------------------------------------------------*
rule <component>  ?!@M_machinesMap unused ioMachinesMap  ?!@L_jobList ioJobList:  $bdd$ ;  $;$ ;  @AC_job job := [@typeDisplayBDDstats new] ;  ioJobList += !job ;end rule ;
#---------------------------------------------------------------------------*
rule <component>  ?!@M_machinesMap ioMachinesMap  ?!@L_jobList ioJobList:  @M_variablesMap variablesMap [empty] ;  @M_stateMap statesMap [empty] ;  @L_stateDefinition stateDefinitionList [empty] ;#--- Machine name  @lstring machineName ;  $machineIdf$ ? machineName ;  $($ ;#--- Parse input variables  repeat    @lstring inputVarName ;    $identifier$ ? inputVarName ;    insert variablesMap.insertKey inputVarName () ;  while    $,$ ;  end repeat ;  @uint inputVariablesCount := [variablesMap length] ;  $)$ ;#--- Parse internal variables  $($ ;  select  or    repeat      @lstring outputVarName ;      $identifier$ ? outputVarName ;      insert variablesMap.insertKey outputVarName () ;    while      $,$ ;    end repeat ;  end select ;  $)$ ;  @uint inputAndInternalVariablesCount := [variablesMap length] ;#--- Parse output variables  $($ ;  repeat    @lstring outputVarName ;    $identifier$ ? outputVarName ;    insert variablesMap.insertKey outputVarName () ;  while    $,$ ;  end repeat ;  $)$ ;  $:=$ ;#--- Machine definition  @AC_machineDefinition definition ;  <definition_expression> !?ioMachinesMap !?variablesMap ?definition ;#--- Insert machine into machine map  @luint machineIndex ;  insert ioMachinesMap.insertKey machineName (!inputVariablesCount !inputAndInternalVariablesCount !variablesMap) -> machineIndex ;#--- Insert into component map  @AC_job machine := [@C_machineComponent new !machineName !machineIndex !inputVariablesCount !inputAndInternalVariablesCount !variablesMap !definition] ; ioJobList += !machine ;  $;$ ;end rule ;
#---------------------------------------------------------------------------*
rule <component>  ?!@M_machinesMap ioMachinesMap  ?!@L_jobList ioJobList:  $scenario$ ;  @M_variablesMap variablesMap [empty] ;  @M_stateMap statesMap [empty] ;  @L_stateDefinition stateDefinitionList [empty] ;#--- Machine name  @lstring machineName ;  $machineIdf$ ? machineName ;#--- Search machine from machine map  @luint machineIndex ;  @uint inputVariablesCountFromDefinition ;  @uint inputAndInternalVariablesCountFromDefinition ;  @M_variablesMap variablesMapFromDefinition ;  search ioMachinesMap.searchKey machineName (?inputVariablesCountFromDefinition ?inputAndInternalVariablesCountFromDefinition ?variablesMapFromDefinition) -> machineIndex ;#--- Parse input variables  $($ ;  repeat    @lstring inputVarName ;    $identifier$ ? inputVarName ;    insert variablesMap.insertKey inputVarName () ;  while    $,$ ;  end repeat ;  @uint inputVariablesCount := [variablesMap length] ;  $)$ ;#--- Check correct number of input variables  if inputVariablesCountFromDefinition != inputVariablesCount then    error here : "This declaration names " . [inputVariablesCount string]      . " input variable(s), but machine definition names " . [inputVariablesCountFromDefinition string] . " input variable(s)" ;  end if ;#--- Parse internal variables  $($ ;  select  or    repeat      @lstring outputVarName ;      $identifier$ ? outputVarName ;      insert variablesMap.insertKey outputVarName () ;    while      $,$ ;    end repeat ;  end select ;  $)$ ;#--- Check correct number of internal variables  @uint inputAndInternalVariablesCount := [variablesMap length] ;  if inputAndInternalVariablesCountFromDefinition != inputAndInternalVariablesCount then    error here : "This declaration names " . [inputAndInternalVariablesCount string]      . " input and internal variable(s), but machine definition names " . [inputAndInternalVariablesCountFromDefinition string] . " input and internal variable(s)" ;  end if ;#--- Parse output variables  $($ ;  repeat    @lstring outputVarName ;    $identifier$ ? outputVarName ;    insert variablesMap.insertKey outputVarName () ;  while    $,$ ;  end repeat ;  $)$ ;#--- Check correct number of internal variables  @uint outputVariablesCount := [variablesMap length] ;  @uint outputVariablesCountFromDefinition := [variablesMapFromDefinition length] ;  if outputVariablesCountFromDefinition != outputVariablesCount then    error here : "This declaration names " . [outputVariablesCount string]      . " variables, but machine definition names " . [outputVariablesCountFromDefinition string] . " variables" ;  end if ;  ${$ ;  @L_scenarioList scenarioList [empty] ;  repeat    @lstring scenarioTitle ;    $literal_string$ ? scenarioTitle ;    @L_inputScenario inputScenario [empty] ;    repeat      $:$ ;      @L_inputConfigurationForScenario inputConfigurationForScenario [empty] ;      repeat       @luint v ;       $literal_integer$  ? v ;       if [v value] > 1 then         error v : "this value is not a  binary digit" ;       end if ;       inputConfigurationForScenario += !v ;      while       $,$ ;      end repeat ;      if inputVariablesCount != [inputConfigurationForScenario length] then        error here : "this input configuration names " . [[inputConfigurationForScenario length] string] . " input variable(s), instead of " . [inputVariablesCount string] ;      end if ;      inputScenario += !inputConfigurationForScenario ;    while    end repeat ;    $;$ ;    scenarioList += !scenarioTitle !inputScenario ;  while  end repeat ;  $}$ ;#--- Insert job into job list  @AC_job machine := [@C_scenarioComponent new !machineIndex !inputVariablesCount !inputAndInternalVariablesCount !variablesMap !scenarioList] ; ioJobList += !machine ;end rule ;
#---------------------------------------------------------------------------*
rule <io_expression>  ?!@M_variablesMap ioVarMap  !@AC_expression outExpression:  <io_and_expression> !?ioVarMap ? outExpression ;  repeat  while    $|$ ;    @AC_expression rightExpression ;    <io_and_expression>  !? ioVarMap ? rightExpression ;    outExpression := [@C_orExpression new ! outExpression ! rightExpression] ;  while    $^$ ;    @AC_expression rightExpression ;    <io_and_expression>  !? ioVarMap ? rightExpression ;    outExpression := [@C_xorExpression new ! outExpression ! rightExpression] ;  while    $->$ ;    @AC_expression rightExpression ;    <io_and_expression> !? ioVarMap ? rightExpression ;    outExpression := [@C_impliesExpression new ! outExpression ! rightExpression] ;  while    $=$ ;    @AC_expression rightExpression ;    <io_and_expression> !? ioVarMap ? rightExpression ;    outExpression := [@C_equalExpression new ! outExpression ! rightExpression] ;  end repeat ;end rule ;
#---------------------------------------------------------------------------*
rule <io_and_expression>   ?!@M_variablesMap ioVarMap  !@AC_expression outExpression:  <io_primary>  !? ioVarMap ? outExpression ;  repeat  while    $&$ ;    @AC_expression rightExpression ;    <io_primary> !? ioVarMap ? rightExpression ;    outExpression := [@C_andExpression new ! outExpression !rightExpression] ;  end repeat ;end rule ;
#---------------------------------------------------------------------------*
rule <io_primary>   ?!@M_variablesMap ioVarMap  !@AC_expression outExpression:  $($ ;  <io_expression> !? ioVarMap ? outExpression ;  $)$ ;end rule ;
#---------------------------------------------------------------------------*
rule <io_primary>   ?!@M_variablesMap ioVarMap  !@AC_expression outExpression:  @lstring inputVarName ;  $identifier$ ? inputVarName ;  @luint inputVarIndex ;  search ioVarMap.searchKey inputVarName () -> inputVarIndex ;  outExpression := [@C_VariableExpression new !inputVarIndex] ;end rule ;
#---------------------------------------------------------------------------*
rule <io_primary>   ?!@M_variablesMap ioVarMap  !@AC_expression outExpression:  $~$ ;  @AC_expression expression ;  <io_primary>  !?ioVarMap ? expression ;  outExpression := [@C_notExpression new ! expression] ;end rule ;
#---------------------------------------------------------------------------*
rule <io_primary>   ?!@M_variablesMap unused ioVarMap  !@AC_expression outExpression:  $none$ ;  outExpression := [@C_falseExpression new] ;end rule ;
#---------------------------------------------------------------------------*
rule <io_primary>   ?!@M_variablesMap unused ioVarMap  !@AC_expression outExpression:  $all$ ;  outExpression := [@C_trueExpression new] ;end rule ;
#---------------------------------------------------------------------------*#         DEFINITION EXPRESSION                                             *#---------------------------------------------------------------------------*
rule <definition_expression>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap variablesMap  !@AC_machineDefinition outDefinition:  <definition_expression_term> !?ioMachinesMap !?variablesMap ?outDefinition ;  repeat  while    $|$ ;    @AC_machineDefinition leftOperand := outDefinition ;    @AC_machineDefinition rightOperand ;    <definition_expression_term> !?ioMachinesMap !?variablesMap ?rightOperand ;    outDefinition := [@C_orComposition new !leftOperand !rightOperand] ;  while    $^$ ;    @AC_machineDefinition leftOperand := outDefinition ;    @AC_machineDefinition rightOperand ;    <definition_expression_term> !?ioMachinesMap !?variablesMap ?rightOperand ;    outDefinition := [@C_xorComposition new !leftOperand !rightOperand] ;  while    $->$ ;    @AC_machineDefinition leftOperand := outDefinition ;    @AC_machineDefinition rightOperand ;    <definition_expression_term> !?ioMachinesMap !?variablesMap ?rightOperand ;    outDefinition := [@C_impliesComposition new !leftOperand !rightOperand] ;  while    $=$ ;    @AC_machineDefinition leftOperand := outDefinition ;    @AC_machineDefinition rightOperand ;    <definition_expression_term> !?ioMachinesMap !?variablesMap ?rightOperand ;    outDefinition := [@C_equalComposition new !leftOperand !rightOperand] ;  end repeat ;end rule ;
#---------------------------------------------------------------------------*
rule <definition_expression_term>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap variablesMap  !@AC_machineDefinition outDefinition:  <definition_expression_factor> !?ioMachinesMap !? variablesMap ?outDefinition ;  repeat  while    $*$ ;    @location errorLocation := here ;    @AC_machineDefinition leftOperand := outDefinition ;    @AC_machineDefinition rightOperand ;    <definition_expression_factor> !?ioMachinesMap !? variablesMap ?rightOperand ;    outDefinition := [@C_strongModalComposition new !leftOperand !errorLocation !rightOperand] ;  while    $**$ ;    @location errorLocation := here ;    @AC_machineDefinition leftOperand := outDefinition ;    @AC_machineDefinition rightOperand ;    <definition_expression_factor> !?ioMachinesMap !? variablesMap ?rightOperand ;    outDefinition := [@C_weakModalComposition new !leftOperand !errorLocation !rightOperand] ;  while    $&$ ;    @AC_machineDefinition leftOperand := outDefinition ;    @AC_machineDefinition rightOperand ;    <definition_expression_factor> !?ioMachinesMap !? variablesMap ?rightOperand ;    outDefinition := [@C_andComposition new !leftOperand !rightOperand] ;  end repeat ;end rule ;
#---------------------------------------------------------------------------*
rule <definition_expression_factor>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap variablesMap  !@AC_machineDefinition outDefinition:  select    <explicit_automaton> !?variablesMap ?outDefinition ;  or    $($ ;    <definition_expression> !?ioMachinesMap !? variablesMap ?outDefinition ;    $)$ ;  or    @M_variablesMap extendedVariablesMap := variablesMap ;    @uint previousVariableCount := [extendedVariablesMap length] ;    $?$ ;    repeat      @lstring variableName ;      $identifier$ ? variableName ;      insert extendedVariablesMap.insertKey variableName () ;    while      $,$ ;    end repeat ;    @uint actualVariableCount := [extendedVariablesMap length] ;    $($ ;    @AC_machineDefinition def ;    <definition_expression> !?ioMachinesMap !?extendedVariablesMap ?def ;    $)$ ;    outDefinition := [@C_existsDefinition new !previousVariableCount !actualVariableCount !def] ;  or    $~$ ;    @AC_machineDefinition def ;    <definition_expression_factor> !?ioMachinesMap !? variablesMap ?def ;    outDefinition := [@C_notComposition new !def] ;  or    $@$ ;    @AC_machineDefinition def ;    <definition_expression_factor> !?ioMachinesMap !? variablesMap ?def ;    outDefinition := [@C_fullSaturationOperation new !def] ;  or    $nolast$ ;    $($ ;    @AC_machineDefinition def ;    <definition_expression> !?ioMachinesMap !? variablesMap ?def ;    outDefinition := [@C_suppressTerminalStatesOperation new !def] ;    $)$ ;  or    $modalcomp$ ;    @M_modesMap modeMap [empty] ;    @L_exclusionListForModes exclusionList [empty] ;    ${$ ;    repeat      @lstring modeName ;      $identifier$ ? modeName ;      $:$ ;      @AC_machineDefinition def ;      <definition_expression> !?ioMachinesMap !?variablesMap ?def ;      insert modeMap.insertKey modeName (!def) ;      $;$ ;    while    end repeat ;    repeat    while      $exclude$ ;      @lstring sourceModeName ;      $identifier$ ? sourceModeName ;      @luint sourceModeIndex ;      search modeMap.searchKey sourceModeName (...) -> sourceModeIndex ;      $to$ ;      @lstring targetModeName ;      $identifier$ ? targetModeName ;      @luint targetModeIndex ;      search modeMap.searchKey targetModeName (...) -> targetModeIndex ;      $;$ ;      if [sourceModeIndex value] == [targetModeIndex value] then        warning targetModeIndex : "unuseful exclude: 'modalcomp' operator never adds transitions from terminal states to initial states of the same mode" ;      else        exclusionList += !sourceModeIndex !targetModeIndex ;      end if ;    end repeat ;    $}$ ;    outDefinition := [@C_modalCompositionComponent new !modeMap !exclusionList] ;  or    $trans$ ;    ${$ ;    @AC_expression sourceExpression ;    <io_expression> !? variablesMap ?sourceExpression ;    $to$ ;    @AC_expression targetExpression ;    <io_expression> !? variablesMap ?targetExpression ;    $}$ ;    outDefinition := [@C_trans new !sourceExpression !targetExpression] ;  or    @lstring variableName ;    $identifier$ ? variableName ;    @luint varIndex ;    search variablesMap.searchKey variableName () -> varIndex ;    outDefinition := [@C_variableDefinition new !varIndex] ;  end select ;end rule ;
#---------------------------------------------------------------------------*
rule <definition_expression_factor>  ?!@M_machinesMap ioMachinesMap  ?!@M_variablesMap ioVarMap  !@AC_machineDefinition outDefinition:  @lstring machineIdentifier ;  $machineIdf$ ? machineIdentifier ;  @uint machineInputVariableCount ;  @uint machineInputAndInternalVariableCount ;  @M_variablesMap machineVariablesMap ;  @luint indexOfImportedMachine ;  search ioMachinesMap.searchKey machineIdentifier (?machineInputVariableCount ?machineInputAndInternalVariableCount ?machineVariablesMap) -> indexOfImportedMachine ;  @L_translationVector translationVector [empty] ;#--- Parse input variables  $($ ;  repeat    @lstring inputVar ;    $identifier$ ? inputVar ;    @luint inputVarIndex ;    search ioVarMap.searchKey inputVar () -> inputVarIndex ;    translationVector += !inputVarIndex ;  while    $,$ ;  end repeat ;  $)$ ;  @uint inputVariablesCount := [translationVector length] ;  if inputVariablesCount != machineInputVariableCount then    error here : "The '$" . [machineIdentifier value] . "' machine defines " . [machineInputVariableCount string]    . " input variable(s), but this operand defines " . [inputVariablesCount string] . " input variable(s)" ;  end if ;#--- Parse internal variables  $($ ;  select  or    repeat      @lstring internalVar ;      $identifier$ ? internalVar ;      @luint internalVarIndex ;      search ioVarMap.searchKey internalVar () -> internalVarIndex ;      translationVector += ! internalVarIndex ;    while      $,$ ;    end repeat ;  end select ;  $)$ ;  @uint inputAndInternalVariablesCount := [translationVector length] ;  if inputAndInternalVariablesCount != machineInputAndInternalVariableCount then    error here : "The '$" . [machineIdentifier value] . "' machine defines " . [machineInputAndInternalVariableCount string]    . " input and internal variable(s), but this operand defines " . [inputAndInternalVariablesCount string] . " input and internal variable(s)" ;  end if ;#--- Parse output variables  $($ ;  repeat    @lstring outputVar ;    $identifier$ ? outputVar ;    @luint outputVarIndex ;    search ioVarMap.searchKey outputVar () -> outputVarIndex ;    translationVector += !outputVarIndex ;  while    $,$ ;  end repeat ;  $)$ ;  @uint allVariablesCount := [translationVector length] ;  @uint machineAllVariablesCount := [machineVariablesMap length] ;  if allVariablesCount != machineAllVariablesCount then    error here : "The '$" . [machineIdentifier value] . "' machine defines " . [machineAllVariablesCount string]    . " variables, but this operand defines " . [allVariablesCount string] . " variables" ;  end if ;  outDefinition := [@C_importMachine new ![indexOfImportedMachine value] !translationVector] ;end rule ;
#---------------------------------------------------------------------------*#         EXPLICIT AUTOMATON                                                *#---------------------------------------------------------------------------*
rule <explicit_automaton>  ?!@M_variablesMap variablesMap  !@AC_machineDefinition outDefinition:  @M_stateMap statesMap [empty] ;  @L_stateDefinition stateDefinitionList [empty] ;  $auto$ ;  ${$ ;#--- States declaration  $state$ ;  repeat    @lstring stateName ;    $identifier$ ? stateName ;    insert statesMap.insertKey stateName () ;  while    $,$ ;  end repeat ;  $;$ ;#--- Initial states  @L_statesDefinitionList initialStatesDefinitionList [empty] ;  $first$ ;  repeat    @lstring initialState ;    $identifier$ ? initialState ;    @luint initialStateIndex ;    search statesMap.searchKey initialState () -> initialStateIndex ;    initialStatesDefinitionList += !initialStateIndex !here ;  while    $,$ ;  end repeat ;  $;$ ;#--- terminal states  @L_statesDefinitionList terminalStatesDefinitionList [empty] ;  select  or    $last$ ;    repeat      @lstring terminalState ;      $identifier$ ? terminalState ;      @luint terminalStateIndex ;      search statesMap.searchKey terminalState () -> terminalStateIndex ;      terminalStatesDefinitionList += ! terminalStateIndex !here ;    while      $,$ ;    end repeat ;    $;$ ;  end select ;#--- Parse state definitions  @M_stateMap stateDefinitionMap [empty] ;  repeat  #--- Current state    @lstring stateName ;    $identifier$ ? stateName ;    @luint stateIndex ;    search statesMap.searchKey stateName () -> stateIndex ;    insert stateDefinitionMap.defineState stateName () ;    $:$ ;  #--- State input expression    @AC_expression stateExpression ;    <io_expression> !?variablesMap ?stateExpression ;    @location endOfStateExpression := here ;    ${$ ;  #--- Parse state transition    @L_transitionDefinition transitionsList [empty] ;    repeat    while      @AC_expression transitionInputExpression ;      <io_expression>  !?variablesMap ?transitionInputExpression ;      @location endOfExpression := here ;      $goto$ ;      @lstring targetStateName ;      $identifier$ ? targetStateName ;      @luint targetStateIndex ;      search statesMap.searchKey targetStateName () -> targetStateIndex ;      transitionsList += !transitionInputExpression !endOfExpression !targetStateIndex ;      $;$ ;    end repeat ;    $}$ ;    stateDefinitionList += !stateIndex !stateExpression !endOfStateExpression                           !transitionsList ;  while  end repeat ;#--- Check all states are defined  foreach map statesMap ??@lstring kStateName () :    if not [stateDefinitionMap hasKey ! kStateName] then      error here : "'" . [kStateName value] . "' state is not described" ;    end if ;  end foreach ;#--- End of input source  $}$ ;  outDefinition := [@C_explicitAutomatonDefinition new !statesMap !initialStatesDefinitionList !terminalStatesDefinitionList !stateDefinitionList !here] ;end rule ;
#---------------------------------------------------------------------------*
end syntax ;#---------------------------------------------------------------------------*#                                                                           *#   C O M M A N D    L I N E    O P T I O N S                               *#                                                                           *#---------------------------------------------------------------------------*option sara_cli_options :  @bool displayBDDvaluesCount : 'c', "display-bdd-values-count" -> "displays values count for every BDD" ;  @bool displayBDDvalues : 'v', "display-bdd-values" -> "displays values for every BDD" ;end option ;
#---------------------------------------------------------------------------*#                                                                           *#   G R A M M A R                                                           *#                                                                           *#---------------------------------------------------------------------------*grammar sara_grammar "LL1" :  import lexique sara_scanner ;  import option sara_cli_options ;  import syntax sara_parser ;  start <start_symbol> ;end grammar ;
#---------------------------------------------------------------------------*#                                                                           *#   C O C O A                                                               *#                                                                           *#---------------------------------------------------------------------------*
cocoa cocoa_sara : program "sara" ; import grammar sara_grammar ;end cocoa ;#---------------------------------------------------------------------------*#                                                                           *#   P R O G R A M                                                           *#                                                                           *#---------------------------------------------------------------------------*program sara_main "version 0.1.1" . "sara" :  import grammar sara_grammar ;#--- max error and warning count  error 100 ;  warning 100 ;end program ;#--------------------------------------------------------------------------------*