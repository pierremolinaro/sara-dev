#---------------------------------------------------------------------------*
#                                                                           *
#   S Y N T A X                                                             *
#                                                                           *
#---------------------------------------------------------------------------*

syntax sara_parser :
with "sara_scanner.gLexique" ;
import lexique sara_scanner in "sara_scanner.gLexique" ;
import semantics sara_semantics in "sara_semantics.gSemantics" ;
import "sara_semantics.gSemantics" ;

nonterminal <start_symbol> ;

nonterminal <modalcompadd_definition>
  ??@semanticContext inSemanticContext
  ?!@M_variablesMap outputVariableMap
  !@M_modesMap outModeMap
  !@ListForModes outInclusionList
;

nonterminal <modalcompsub_definition>
  ??@semanticContext inSemanticContext
  ?!@M_variablesMap outputVariableMap
  !@M_modesMap outModeMap
  !@ListForModes outExclusionList
;

nonterminal <explicit_automaton>
  ??@semanticContext inSemanticContext
  ?!@M_variablesMap outputVariableMap
  !@AC_machineDefinition outDefinition
;
nonterminal <definition_expression>
  ??@semanticContext inSemanticContext
  ?!@M_variablesMap outputVariableMap
  !@AC_machineDefinition outDefinition
;
nonterminal <definition_expression_term>
  ??@semanticContext inSemanticContext
  ?!@M_variablesMap outputVariableMap
  !@AC_machineDefinition outDefinition
;
nonterminal <definition_expression_factor>
  ??@semanticContext inSemanticContext
  ?!@M_variablesMap outputVariableMap
  !@AC_machineDefinition outDefinition
;
nonterminal <component>
  ?!@semanticContext ioSemanticContext
;

nonterminal <io_bool_expression>
  ??@semanticContext inSemanticContext
  ?!@M_variablesMap ioVarMap
  !@AC_boolExpression outExpression
;
nonterminal <io_and_expression> 
  ??@semanticContext inSemanticContext
  ?!@M_variablesMap ioVarMap
  !@AC_boolExpression outExpression
;
nonterminal <io_primary> 
  ??@semanticContext inSemanticContext
  ?!@M_variablesMap ioVarMap
  !@AC_boolExpression outExpression
;
extern routine performComputations
  ??@L_jobList ioJobList
;

#---------------------------------------------------------------------------*

rule <start_symbol>
:
  @semanticContext semanticContext [new
    ![@L_jobList emptyList]
    ![@M_machinesMap emptyMap]
  ] ;
  repeat
    <component> !?semanticContext ;
  while
  end repeat ;
  performComputations ![semanticContext componentsMap] ;
end rule ;
 
#---------------------------------------------------------------------------*

rule <component>
  ?!@semanticContext ioSemanticContext
:
  @M_variablesMap variablesMap [emptyMap] ;
  @M_stateMap statesMap [emptyMap] ;
  @L_stateDefinition stateDefinitionList [emptyList] ;
#--- Machine name
  $state$ ;
  $display$ ;
  @lstring machineName ;
  $machineIdf$ ? machineName ;
  $;$ ;
#--- Insert machine into machine map
  @uint machineIndex ;
  [[ioSemanticContext machinesMap] searchKey !machineName ?machineIndex ?* ?* ?*] ;
#--- Insert into component map
  @AC_job job := [@C_machineDisplayStates new !machineIndex] ;
  ioSemanticContext->componentsMap += !job ;
end rule ;

#---------------------------------------------------------------------------*

rule <component>
  ?!@semanticContext ioSemanticContext
:
  @M_variablesMap variablesMap [emptyMap] ;
  @M_stateMap statesMap [emptyMap] ;
  @L_stateDefinition stateDefinitionList [emptyList] ;
#--- Machine name
  $trans$ ;
  $display$ ;
  @lstring machineName ;
  $machineIdf$ ? machineName ;
  $;$ ;
#--- Insert machine into machine map
  @uint machineIndex ;
  [[ioSemanticContext machinesMap] searchKey !machineName ?machineIndex ?* ?* ?*] ;
#--- Insert into component map
  @AC_job job := [@C_machineDisplayTransitions new !machineIndex] ;
  ioSemanticContext->componentsMap += !job ;
end rule ;

#---------------------------------------------------------------------------*

rule <component>
  ?!@semanticContext ioSemanticContext
:
  @M_variablesMap variablesMap [emptyMap] ;
  @M_stateMap statesMap [emptyMap] ;
  @L_stateDefinition stateDefinitionList [emptyList] ;
#--- Machine name
  $first$ ;
  $state$ ;
  $display$ ;
  @lstring machineName ;
  $machineIdf$ ? machineName ;
  $;$ ;
#--- Insert machine into machine map
  @uint machineIndex ;
  [[ioSemanticContext machinesMap] searchKey !machineName ?machineIndex ?* ?* ?*] ;
#--- Insert into component map
  @AC_job job := [@C_machineDisplayInitialStates new !machineIndex] ;
  ioSemanticContext->componentsMap += !job ;
end rule ;

#---------------------------------------------------------------------------*

rule <component>
  ?!@semanticContext ioSemanticContext
:
  @M_variablesMap variablesMap [emptyMap] ;
  @M_stateMap statesMap [emptyMap] ;
  @L_stateDefinition stateDefinitionList [emptyList] ;
#--- Machine name
  $last$ ;
  $state$ ;
  $display$ ;
  @lstring machineName ;
  $machineIdf$ ? machineName ;
  $;$ ;
#--- Insert machine into machine map
  @uint machineIndex ;
  [[ioSemanticContext machinesMap] searchKey !machineName ?machineIndex ?* ?* ?*] ;
#--- Insert into component map
  @AC_job job := [@C_machineDisplayTerminalStates new !machineIndex] ;
  ioSemanticContext->componentsMap += !job ;
end rule ;

#---------------------------------------------------------------------------*

rule <component>
  ?!@semanticContext ioSemanticContext
:
  @M_variablesMap variablesMap [emptyMap] ;
  @M_stateMap statesMap [emptyMap] ;
  @L_stateDefinition stateDefinitionList [emptyList] ;
#--- Machine name
  $check$ ;
  @lstring machineName ;
  $machineIdf$ ? machineName ;
  $;$ ;
#--- Insert machine into machine map
  @uint machineIndex ;
  [[ioSemanticContext machinesMap] searchKey !machineName ?machineIndex ?* ?* ?*] ;
#--- Insert into component map
  @AC_job job := [@C_machineCheck new !machineIndex !false] ;
  ioSemanticContext->componentsMap += !job ;
end rule ;

#---------------------------------------------------------------------------*

rule <component>
  ?!@semanticContext ioSemanticContext
:
  @M_variablesMap variablesMap [emptyMap] ;
  @M_stateMap statesMap [emptyMap] ;
  @L_stateDefinition stateDefinitionList [emptyList] ;
#--- Machine name
  $checkidentical$ ;
  @lstring machineName1 ;
  $machineIdf$ ? machineName1 ;
  $,$ ;
  @lstring machineName2 ;
  $machineIdf$ ? machineName2 ;
  $;$ ;
#--- Insert machine into machine map
  @uint machineIndex1 ;
  [[ioSemanticContext machinesMap] searchKey !machineName1 ?machineIndex1 ?* ?* ?*] ;
#--- Insert machine into machine map
  @uint machineIndex2 ;
  [[ioSemanticContext machinesMap] searchKey !machineName2 ?machineIndex2 ?* ?* ?*] ;
#--- Insert into component map
  @AC_job job := [@C_machineCheckIdentical new !machineIndex1 !machineIndex2] ;
  ioSemanticContext->componentsMap += !job ;
end rule ;

#---------------------------------------------------------------------------*

rule <component>
  ?!@semanticContext ioSemanticContext
:
  @M_variablesMap variablesMap [emptyMap] ;
  @M_stateMap statesMap [emptyMap] ;
  @L_stateDefinition stateDefinitionList [emptyList] ;
#--- Machine name
  $checkbool$ ;
  @lstring machineName ;
  $machineIdf$ ? machineName ;
  $;$ ;
#--- Insert machine into machine map
  @uint machineIndex ;
  [[ioSemanticContext machinesMap] searchKey !machineName ?machineIndex ?* ?* ?*] ;
#--- Insert into component map
  @AC_job job := [@C_machineCheck new !machineIndex !true] ;
  ioSemanticContext->componentsMap += !job ;
end rule ;

#---------------------------------------------------------------------------*

rule <component>
  ?!@semanticContext ioSemanticContext
:
  $use_and$ ;
  $;$ ;
  @AC_job job := [@typeUse_AND new] ;
  ioSemanticContext->componentsMap += !job ;
end rule ;

#---------------------------------------------------------------------------*

rule <component>
  ?!@semanticContext ioSemanticContext
:
  $use_ite$ ;
  $;$ ;
  @AC_job job := [@typeUse_ITE new] ;
  ioSemanticContext->componentsMap += !job ;
end rule ;

#---------------------------------------------------------------------------*

rule <component>
  ?!@semanticContext ioSemanticContext
:
  $use_and_ite$ ;
  $;$ ;
  @AC_job job := [@typeUse_AND_ITE new] ;
  ioSemanticContext->componentsMap += !job ;
end rule ;

#---------------------------------------------------------------------------*

rule <component>
  ?!@semanticContext ioSemanticContext
:
  $and_cache$ ;
  @luint size ;
  $literal_integer$ ? size ;
  $;$ ;
  @AC_job job := [@typeResize_AND_cache new !size] ;
  ioSemanticContext->componentsMap += !job ;
end rule ;

#---------------------------------------------------------------------------*
rule <component>
  ?!@semanticContext ioSemanticContext
:
  $ite_cache$ ;
  @luint size ;
  $literal_integer$ ? size ;
  $;$ ;
  @AC_job job := [@typeResize_ITE_cache new !size] ;
  ioSemanticContext->componentsMap += !job ;
end rule ;

#---------------------------------------------------------------------------*

rule <component>
  ?!@semanticContext ioSemanticContext
:
  $map$ ;
  @luint size ;
  $literal_integer$ ? size ;
  $;$ ;
  @AC_job job := [@typeResizeMap new !size] ;
  ioSemanticContext->componentsMap += !job ;
end rule ;

#---------------------------------------------------------------------------*

rule <component>
  ?!@semanticContext ioSemanticContext
:
  $bdd$ ;
  $;$ ;
  @AC_job job := [@typeDisplayBDDstats new] ;
  ioSemanticContext->componentsMap += !job ;
end rule ;

#---------------------------------------------------------------------------*

rule <component>
  ?!@semanticContext ioSemanticContext
:
  @M_variablesMap variablesMap [emptyMap] ;
  @M_stateMap statesMap [emptyMap] ;
  @L_stateDefinition stateDefinitionList [emptyList] ;
#--- Machine name
  @lstring machineName ;
  $machineIdf$ ? machineName ;
  $($ ;
#--- Parse input variables
  repeat
    @lstring inputVarName ;
    $identifier$ ? inputVarName ;
    [!?variablesMap insertKey !inputVarName ![variablesMap count]] ;
  while
    $,$ ;
  end repeat ;
  @uint inputVariablesCount := [variablesMap count] ;
  $)$ ;
#--- Parse internal variables
  $($ ;
  select
  or
    repeat
      @lstring outputVarName ;
      $identifier$ ? outputVarName ;
      [!?variablesMap insertKey !outputVarName ![variablesMap count]] ;
    while
      $,$ ;
    end repeat ;
  end select ;
  $)$ ;
  @uint inputAndInternalVariablesCount := [variablesMap count] ;
#--- Parse output variables
  $($ ;
  repeat
    @lstring outputVarName ;
    $identifier$ ? outputVarName ;
    [!?variablesMap insertKey !outputVarName ![variablesMap count]] ;
  while
    $,$ ;
  end repeat ;
  $)$ ;
  $:=$ ;
#--- Machine definition
  @AC_machineDefinition definition ;
  <definition_expression> !ioSemanticContext !?variablesMap ?definition ;
#--- Insert machine into machine map
  const @uint machineIndex := [[ioSemanticContext machinesMap] count] ;
  [!?ioSemanticContext->machinesMap insertKey !machineName !machineIndex !inputVariablesCount !inputAndInternalVariablesCount !variablesMap] ;
#--- Insert into component map
  @AC_job machine := [@C_machineComponent new !machineName !machineIndex !inputVariablesCount !inputAndInternalVariablesCount !variablesMap !definition] ;
  ioSemanticContext->componentsMap += !machine ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*

rule <component>
  ?!@semanticContext ioSemanticContext
:
  @M_variablesMap variablesMap [emptyMap] ;
  @M_stateMap statesMap [emptyMap] ;
  @L_stateDefinition stateDefinitionList [emptyList] ;
#--- Machine name
  $modalcompadd$ ;
  @lstring machineName ;
  $machineIdf$ ? machineName ;
  $($ ;
#--- Parse input variables
  repeat
    @lstring inputVarName ;
    $identifier$ ? inputVarName ;
    [!?variablesMap insertKey !inputVarName ![variablesMap count]] ;
  while
    $,$ ;
  end repeat ;
  @uint inputVariablesCount := [variablesMap count] ;
  $)$ ;
#--- Parse internal variables
  $($ ;
  select
  or
    repeat
      @lstring outputVarName ;
      $identifier$ ? outputVarName ;
      [!?variablesMap insertKey !outputVarName ![variablesMap count]] ;
    while
      $,$ ;
    end repeat ;
  end select ;
  $)$ ;
  @uint inputAndInternalVariablesCount := [variablesMap count] ;
#--- Parse output variables
  $($ ;
  repeat
    @lstring outputVarName ;
    $identifier$ ? outputVarName ;
    [!?variablesMap insertKey !outputVarName ![variablesMap count]] ;
  while
    $,$ ;
  end repeat ;
  $)$ ;
  $:=$ ;
#--- Machine definition
  @M_modesMap modeMap ;
  @ListForModes inclusionList ;
  <modalcompadd_definition>
    !ioSemanticContext
    !?variablesMap
    ?modeMap
    ?inclusionList
  ;
#--- Insert machine into machine map
  const @uint machineIndex := [[ioSemanticContext machinesMap] count] ;
  [!?ioSemanticContext->machinesMap insertKey !machineName !machineIndex !inputVariablesCount !inputAndInternalVariablesCount !variablesMap] ;
#--- Insert into component map
  @AC_job machine := [@C_machineDefinedByAdditiveModalComp new
   !machineName
   !machineIndex
   !inputVariablesCount
   !inputAndInternalVariablesCount
   !variablesMap
   !modeMap
   !inclusionList
  ] ;
  ioSemanticContext->componentsMap += !machine ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*

rule <component>
  ?!@semanticContext ioSemanticContext
:
  @M_variablesMap variablesMap [emptyMap] ;
  @M_stateMap statesMap [emptyMap] ;
  @L_stateDefinition stateDefinitionList [emptyList] ;
#--- Machine name
  $modalcompsub$ ;
  @lstring machineName ;
  $machineIdf$ ? machineName ;
  $($ ;
#--- Parse input variables
  repeat
    @lstring inputVarName ;
    $identifier$ ? inputVarName ;
    [!?variablesMap insertKey !inputVarName ![variablesMap count]] ;
  while
    $,$ ;
  end repeat ;
  @uint inputVariablesCount := [variablesMap count] ;
  $)$ ;
#--- Parse internal variables
  $($ ;
  select
  or
    repeat
      @lstring outputVarName ;
      $identifier$ ? outputVarName ;
      [!?variablesMap insertKey !outputVarName ![variablesMap count]] ;
    while
      $,$ ;
    end repeat ;
  end select ;
  $)$ ;
  @uint inputAndInternalVariablesCount := [variablesMap count] ;
#--- Parse output variables
  $($ ;
  repeat
    @lstring outputVarName ;
    $identifier$ ? outputVarName ;
    [!?variablesMap insertKey !outputVarName ![variablesMap count]] ;
  while
    $,$ ;
  end repeat ;
  $)$ ;
  $:=$ ;
#--- Machine definition
  @M_modesMap modeMap ;
  @ListForModes exclusionList ;
  <modalcompsub_definition>
    !ioSemanticContext
    !?variablesMap
    ?modeMap
    ?exclusionList
  ;
#--- Insert machine into machine map
  const @uint machineIndex := [[ioSemanticContext machinesMap] count] ;
  [!?ioSemanticContext->machinesMap insertKey !machineName !machineIndex !inputVariablesCount !inputAndInternalVariablesCount !variablesMap] ;
#--- Insert into component map
  @AC_job machine := [@C_machineDefinedBySubstractiveModalComp new
   !machineName
   !machineIndex
   !inputVariablesCount
   !inputAndInternalVariablesCount
   !variablesMap
   !modeMap
   !exclusionList
  ] ;
  ioSemanticContext->componentsMap += !machine ;
  $;$ ;
end rule ;
#---------------------------------------------------------------------------*
rule <component>
  ?!@semanticContext ioSemanticContext
:
  $scenario$ ;
  @M_variablesMap variablesMap [emptyMap] ;
  @M_stateMap statesMap [emptyMap] ;
  @L_stateDefinition stateDefinitionList [emptyList] ;
#--- Machine name
  @lstring machineName ;
  $machineIdf$ ? machineName ;
#--- Search machine from machine map
  @uint machineIndex ;
  @uint inputVariablesCountFromDefinition ;
  @uint inputAndInternalVariablesCountFromDefinition ;
  @M_variablesMap variablesMapFromDefinition ;
  [[ioSemanticContext machinesMap] searchKey !machineName ?machineIndex ?inputVariablesCountFromDefinition ?inputAndInternalVariablesCountFromDefinition ?variablesMapFromDefinition] ;
#--- Parse input variables
  $($ ;
  repeat
    @lstring inputVarName ;
    $identifier$ ? inputVarName ;
    [!?variablesMap insertKey !inputVarName ![variablesMap count]] ;
  while
    $,$ ;
  end repeat ;
  @uint inputVariablesCount := [variablesMap count] ;
  $)$ ;
#--- Check correct number of input variables
  if inputVariablesCountFromDefinition != inputVariablesCount then
    error here : "This declaration names " . [inputVariablesCount string]
      . " input variable(s), but machine definition names " . [inputVariablesCountFromDefinition string] . " input variable(s)" ;
  end if ;
#--- Parse internal variables
  $($ ;
  select
  or
    repeat
      @lstring outputVarName ;
      $identifier$ ? outputVarName ;
      [!?variablesMap insertKey !outputVarName ![variablesMap count]] ;
    while
      $,$ ;
    end repeat ;
  end select ;
  $)$ ;
#--- Check correct number of internal variables
  @uint inputAndInternalVariablesCount := [variablesMap count] ;
  if inputAndInternalVariablesCountFromDefinition != inputAndInternalVariablesCount then
    error here : "This declaration names " . [inputAndInternalVariablesCount string]
      . " input and internal variable(s), but machine definition names " . [inputAndInternalVariablesCountFromDefinition string] . " input and internal variable(s)" ;
  end if ;
#--- Parse output variables
  $($ ;
  repeat
    @lstring outputVarName ;
    $identifier$ ? outputVarName ;
    [!?variablesMap insertKey !outputVarName ![variablesMap count]] ;
  while
    $,$ ;
  end repeat ;
  $)$ ;
#--- Check correct number of internal variables
  @uint outputVariablesCount := [variablesMap count] ;
  @uint outputVariablesCountFromDefinition := [variablesMapFromDefinition count] ;
  if outputVariablesCountFromDefinition != outputVariablesCount then
    error here : "This declaration names " . [outputVariablesCount string]
      . " variables, but machine definition names " . [outputVariablesCountFromDefinition string] . " variables" ;
  end if ;
  ${$ ;
  @L_scenarioList scenarioList [emptyList] ;
  repeat
    @lstring scenarioTitle ;
    $literal_string$ ? scenarioTitle ;
    @L_inputScenario inputScenario [emptyList] ;
    repeat
      $:$ ;
      @L_inputConfigurationForScenario inputConfigurationForScenario [emptyList] ;
      repeat
       @luint v ;
       $literal_integer$  ? v ;
       if [v uint] > 1 then
         error v : "this value is not a  binary digit" ;
       end if ;
       inputConfigurationForScenario += !v ;
      while
       $,$ ;
      end repeat ;
      if inputVariablesCount != [inputConfigurationForScenario length] then
        error here : "this input configuration names " . [[inputConfigurationForScenario length] string] . " input variable(s), instead of " . [inputVariablesCount string] ;
      end if ;
      inputScenario += !inputConfigurationForScenario ;
    while
    end repeat ;
    $;$ ;
    scenarioList += !scenarioTitle !inputScenario ;
  while
  end repeat ;
  $}$ ;
#--- Insert job into job list
  @AC_job machine := [@C_scenarioComponent new !machineIndex !inputVariablesCount !inputAndInternalVariablesCount !variablesMap !scenarioList] ;
  ioSemanticContext->componentsMap += !machine ;
end rule ;

#---------------------------------------------------------------------------*

rule <io_bool_expression>
  ??@semanticContext inSemanticContext
  ?!@M_variablesMap ioVarMap
  !@AC_boolExpression outExpression
:
  <io_and_expression> !inSemanticContext !?ioVarMap ?outExpression ;
  repeat
  while
    $|$ ;
    @AC_boolExpression rightExpression ;
    <io_and_expression> !inSemanticContext !?ioVarMap ?rightExpression ;
    outExpression := [@C_orExpression new ! outExpression ! rightExpression] ;
  while
    $^$ ;
    @AC_boolExpression rightExpression ;
    <io_and_expression> !inSemanticContext !?ioVarMap ?rightExpression ;
    outExpression := [@C_xorExpression new ! outExpression ! rightExpression] ;
  while
    $->$ ;
    @AC_boolExpression rightExpression ;
    <io_and_expression> !inSemanticContext !?ioVarMap ?rightExpression ;
    outExpression := [@C_impliesExpression new ! outExpression ! rightExpression] ;
  while
    $=$ ;
    @AC_boolExpression rightExpression ;
    <io_and_expression> !inSemanticContext !?ioVarMap ?rightExpression ;
    outExpression := [@C_equalExpression new ! outExpression ! rightExpression] ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*

rule <io_and_expression> 
  ??@semanticContext inSemanticContext
  ?!@M_variablesMap ioVarMap
  !@AC_boolExpression outExpression
:
  <io_primary> !inSemanticContext !?ioVarMap ?outExpression ;
  repeat
  while
    $&$ ;
    @AC_boolExpression rightExpression ;
    <io_primary> !inSemanticContext !?ioVarMap ?rightExpression ;
    outExpression := [@C_andExpression new ! outExpression !rightExpression] ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*

rule <io_primary> 
  ??@semanticContext inSemanticContext
  ?!@M_variablesMap ioVarMap
  !@AC_boolExpression outExpression
:
  $($ ;
  <io_bool_expression> !inSemanticContext !?ioVarMap ?outExpression ;
  $)$ ;
end rule ;

#---------------------------------------------------------------------------*

rule <io_primary> 
  ??@semanticContext unused inSemanticContext
  ?!@M_variablesMap ioVarMap
  !@AC_boolExpression outExpression
:
  @lstring inputVarName ;
  $identifier$ ? inputVarName ;
  @uint inputVarIndex ;
  [ioVarMap searchKey!inputVarName ?inputVarIndex] ;
  outExpression := [@C_VariableExpression new !inputVarIndex] ;
end rule ;

#---------------------------------------------------------------------------*

rule <io_primary> 
  ??@semanticContext inSemanticContext
  ?!@M_variablesMap ioVarMap
  !@AC_boolExpression outExpression
:
  $~$ ;
  @AC_boolExpression expression ;
  <io_primary> !inSemanticContext !?ioVarMap ? expression ;
  outExpression := [@C_notExpression new ! expression] ;
end rule ;

#---------------------------------------------------------------------------*

rule <io_primary> 
  ??@semanticContext unused inSemanticContext
  ?!@M_variablesMap unused ioVarMap
  !@AC_boolExpression outExpression
:
  $false$ ;
  outExpression := [@C_falseExpression new] ;
end rule ;

#---------------------------------------------------------------------------*

rule <io_primary> 
  ??@semanticContext unused inSemanticContext
  ?!@M_variablesMap unused ioVarMap
  !@AC_boolExpression outExpression
:
  $true$ ;
  outExpression := [@C_trueExpression new] ;
end rule ;

#---------------------------------------------------------------------------*

rule <io_primary> 
  ??@semanticContext inSemanticContext
  ?!@M_variablesMap ioVarMap
  !@AC_boolExpression outExpression
:
  @lstring machineIdentifier ;
  $machineIdf$ ? machineIdentifier ;
  @uint machineInputVariableCount ;
  @uint machineInputAndInternalVariableCount ;
  @M_variablesMap machineVariablesMap ;
  @uint indexOfImportedMachine ;
  [[inSemanticContext machinesMap] searchKey !machineIdentifier ?indexOfImportedMachine ?machineInputVariableCount ?machineInputAndInternalVariableCount ?machineVariablesMap] ;
  @L_translationVector translationVector [emptyList] ;
#--- Parse input variables
  $($ ;
  repeat
    @lstring inputVar ;
    $identifier$ ? inputVar ;
    @uint inputVarIndex ;
    [ioVarMap searchKey !inputVar ?inputVarIndex] ;
    translationVector += !inputVarIndex ;
  while
    $,$ ;
  end repeat ;
  $)$ ;
  @uint inputVariablesCount := [translationVector length] ;
  if inputVariablesCount != machineInputVariableCount then
    error here : "The '$" . machineIdentifier . "' machine defines " . [machineInputVariableCount string]
    . " input variable(s), but this operand defines " . [inputVariablesCount string] . " input variable(s)" ;
  end if ;
#--- Parse internal variables
  $($ ;
  select
  or
    repeat
      @lstring internalVar ;
      $identifier$ ? internalVar ;
      @uint internalVarIndex ;
      [ioVarMap searchKey !internalVar ?internalVarIndex] ;
      translationVector += ! internalVarIndex ;
    while
      $,$ ;
    end repeat ;
  end select ;
  $)$ ;
  @uint inputAndInternalVariablesCount := [translationVector length] ;
  if inputAndInternalVariablesCount != machineInputAndInternalVariableCount then
    error here : "The '$" . [machineIdentifier string] . "' machine defines " . [machineInputAndInternalVariableCount string]
    . " input and internal variable(s), but this operand defines " . [inputAndInternalVariablesCount string] . " input and internal variable(s)" ;
  end if ;
#--- Parse output variables
  $($ ;
  repeat
    @lstring outputVar ;
    $identifier$ ? outputVar ;
    @uint outputVarIndex ;
    [ioVarMap searchKey !outputVar ?outputVarIndex] ;
    translationVector += !outputVarIndex ;
  while
    $,$ ;
  end repeat ;
  $)$ ;
  @uint allVariablesCount := [translationVector length] ;
  @uint machineAllVariablesCount := [machineVariablesMap count] ;
  if allVariablesCount != machineAllVariablesCount then
    error here : "The '$" . [machineIdentifier string] . "' machine defines " . [machineAllVariablesCount string]
    . " variables, but this operand defines " . [allVariablesCount string] . " variables" ;
  end if ;
  outExpression := [@C_importBoolMachine new
    !indexOfImportedMachine
    ![machineIdentifier location]
    !translationVector]
  ;
end rule ;

#---------------------------------------------------------------------------*
#         DEFINITION EXPRESSION                                             *
#---------------------------------------------------------------------------*

rule <definition_expression>
  ??@semanticContext inSemanticContext
  ?!@M_variablesMap variablesMap
  !@AC_machineDefinition outDefinition
:
  <definition_expression_term> !inSemanticContext !?variablesMap ?outDefinition ;
  repeat
  while
    $+$ ;
    @AC_machineDefinition leftOperand := outDefinition ;
    @AC_machineDefinition rightOperand ;
    <definition_expression_term> !inSemanticContext !? variablesMap ?rightOperand ;
    outDefinition := [@C_orComposition new !leftOperand !rightOperand] ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*

rule <definition_expression_term>
  ??@semanticContext inSemanticContext
  ?!@M_variablesMap variablesMap
  !@AC_machineDefinition outDefinition
:
  <definition_expression_factor> !inSemanticContext !? variablesMap ?outDefinition ;
  repeat
  while
    $*$ ;
    @location errorLocation := here ;
    @AC_machineDefinition leftOperand := outDefinition ;
    @AC_machineDefinition rightOperand ;
    <definition_expression_factor> !inSemanticContext !? variablesMap ?rightOperand ;
    outDefinition := [@C_strongModalComposition new !leftOperand !errorLocation !rightOperand] ;
  while
    $**$ ;
    @location errorLocation := here ;
    @AC_machineDefinition leftOperand := outDefinition ;
    @AC_machineDefinition rightOperand ;
    <definition_expression_factor> !inSemanticContext !? variablesMap ?rightOperand ;
    outDefinition := [@C_weakModalComposition new !leftOperand !errorLocation !rightOperand] ;
  while
    $||$ ;
    @AC_machineDefinition leftOperand := outDefinition ;
    @AC_machineDefinition rightOperand ;
    <definition_expression_factor> !inSemanticContext !? variablesMap ?rightOperand ;
    outDefinition := [@C_parallelComposition new !leftOperand !rightOperand] ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*

rule <modalcompadd_definition>
  ??@semanticContext inSemanticContext
  ?!@M_variablesMap variablesMap
  !@M_modesMap outModeMap
  !@ListForModes outInclusionList
:
  outModeMap := [@M_modesMap emptyMap] ;
  outInclusionList := [@ListForModes emptyList] ;
  repeat
    @lstring modeName ;
    $identifier$ ? modeName ;
    $:$ ;
    @AC_machineDefinition def ;
    <definition_expression> !inSemanticContext !?variablesMap ?def ;
    [!?outModeMap insertKey !modeName ![outModeMap count] !def] ;
    $;$ ;
  while
  end repeat ;
  repeat
  while
    $include$ ;
    @lstring sourceModeName ;
    $identifier$ ? sourceModeName ;
    @uint sourceModeIndex ;
    [outModeMap searchKey !sourceModeName ?sourceModeIndex ?*] ;
    $to$ ;
    @lstring targetModeName ;
    $identifier$ ? targetModeName ;
    @uint targetModeIndex ;
    [outModeMap searchKey !targetModeName ?targetModeIndex ?*] ;
    $;$ ;
    if sourceModeIndex == targetModeIndex then
      warning targetModeName : "unuseful include: 'modalcompadd' operator never adds transitions from terminal states to initial states of the same mode" ;
    else
      outInclusionList += !sourceModeIndex !targetModeIndex ;
    end if ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*

rule <modalcompsub_definition>
  ??@semanticContext inSemanticContext
  ?!@M_variablesMap variablesMap
  !@M_modesMap outModeMap
  !@ListForModes outExclusionList
:
  outModeMap := [@M_modesMap emptyMap] ;
  outExclusionList := [@ListForModes emptyList] ;
  repeat
    @lstring modeName ;
    $identifier$ ? modeName ;
    $:$ ;
    @AC_machineDefinition def ;
    <definition_expression> !inSemanticContext !?variablesMap ?def ;
    [!?outModeMap insertKey !modeName ![outModeMap count] !def] ;
    $;$ ;
  while
  end repeat ;
  repeat
  while
    $exclude$ ;
    @lstring sourceModeName ;
    $identifier$ ? sourceModeName ;
    @uint sourceModeIndex ;
    [outModeMap searchKey !sourceModeName ?sourceModeIndex ?*] ;
    $to$ ;
    @lstring targetModeName ;
    $identifier$ ? targetModeName ;
    @uint targetModeIndex ;
    [outModeMap searchKey !targetModeName ?targetModeIndex ?*] ;
    $;$ ;
    if sourceModeIndex == targetModeIndex then
      warning targetModeName : "unuseful include: 'modalcompadd' operator never adds transitions from terminal states to initial states of the same mode" ;
    else
      outExclusionList += !sourceModeIndex !targetModeIndex ;
    end if ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*

rule <definition_expression_factor>
  ??@semanticContext inSemanticContext
  ?!@M_variablesMap variablesMap
  !@AC_machineDefinition outDefinition
:
  select
    <explicit_automaton> !inSemanticContext !?variablesMap ?outDefinition ;
  or
    $($ ;
    <definition_expression> !inSemanticContext !? variablesMap ?outDefinition ;
    $)$ ;
  or
    @M_variablesMap extendedVariablesMap := variablesMap ;
    @uint previousVariableCount := [extendedVariablesMap count] ;
    $?$ ;
    repeat
      @lstring variableName ;
      $identifier$ ? variableName ;
      [!?extendedVariablesMap insertKey !variableName ![extendedVariablesMap count]] ;
    while
      $,$ ;
    end repeat ;
    @uint actualVariableCount := [extendedVariablesMap count] ;
    $($ ;
    @AC_machineDefinition def ;
    <definition_expression> !inSemanticContext !?extendedVariablesMap ?def ;
    $)$ ;
    outDefinition := [@C_existsDefinition new !previousVariableCount !actualVariableCount !def] ;
  or
    @M_variablesMap extendedVariablesMap := variablesMap ;
    @uint previousVariableCount := [extendedVariablesMap count] ;
    $!$ ;
    repeat
      @lstring variableName ;
      $identifier$ ? variableName ;
      [!?extendedVariablesMap insertKey !variableName ![extendedVariablesMap count]] ;
    while
      $,$ ;
    end repeat ;
    @uint actualVariableCount := [extendedVariablesMap count] ;
    $($ ;
    @AC_machineDefinition def ;
    <definition_expression> !inSemanticContext !?extendedVariablesMap ?def ;
    $)$ ;
    outDefinition := [@C_forallDefinition new !previousVariableCount !actualVariableCount !def] ;
  or
    $bool$ ;
    ${$ ;
    @AC_boolExpression def ;
    <io_bool_expression> !inSemanticContext !?variablesMap ?def ;
    outDefinition := [@C_boolToSeqExpression new !def] ;
    $}$ ;
  or
    $@$ ;
    @AC_machineDefinition def ;
    <definition_expression_factor> !inSemanticContext !? variablesMap ?def ;
    outDefinition := [@C_fullSaturationOperation new !def] ;
  or
    $~$ ;
    @AC_machineDefinition def ;
    <definition_expression_factor> !inSemanticContext !? variablesMap ?def ;
    outDefinition := [@C_complementationOperation new !def] ;
  or
    $nofirst$ ;
    $($ ;
    @AC_machineDefinition def ;
    <definition_expression> !inSemanticContext !? variablesMap ?def ;
    outDefinition := [@C_suppressInitialStatesOperation new !def] ;
    $)$ ;
  or
    $nolast$ ;
    $($ ;
    @AC_machineDefinition def ;
    <definition_expression> !inSemanticContext !? variablesMap ?def ;
    outDefinition := [@C_suppressTerminalStatesOperation new !def] ;
    $)$ ;
  or
    $modalcompadd$ ;
    ${$ ;
    @M_modesMap modeMap ;
    @ListForModes inclusionList ;
    <modalcompadd_definition>
      !inSemanticContext
      !?variablesMap
      ?modeMap
      ?inclusionList
    ;
    $}$ ;
    outDefinition := [@C_additiveModalCompositionComponent new !modeMap !inclusionList] ;
  or
    $modalcompsub$ ;
    ${$ ;
    @M_modesMap modeMap ;
    @ListForModes exclusionList ;
    <modalcompsub_definition>
      !inSemanticContext
      !?variablesMap
      ?modeMap
      ?exclusionList
    ;
    $}$ ;
    outDefinition := [@C_substractiveModalCompositionComponent new !modeMap !exclusionList] ;
  or
    $trans$ ;
    ${$ ;
    @AC_boolExpression sourceExpression ;
    <io_bool_expression> !inSemanticContext !?variablesMap ?sourceExpression ;
    $to$ ;
    @AC_boolExpression targetExpression ;
    <io_bool_expression> !inSemanticContext !?variablesMap ?targetExpression ;
    $}$ ;
    outDefinition := [@C_trans new !sourceExpression !targetExpression] ;
  end select ;
end rule ;

#---------------------------------------------------------------------------*

rule <definition_expression_factor>
  ??@semanticContext inSemanticContext
  ?!@M_variablesMap ioVarMap
  !@AC_machineDefinition outDefinition
:
  @lstring machineIdentifier ;
  $machineIdf$ ? machineIdentifier ;
  @uint machineInputVariableCount ;
  @uint machineInputAndInternalVariableCount ;
  @M_variablesMap machineVariablesMap ;
  @uint indexOfImportedMachine ;
  [[inSemanticContext machinesMap] searchKey !machineIdentifier ?indexOfImportedMachine ?machineInputVariableCount ?machineInputAndInternalVariableCount ?machineVariablesMap] ;
  @L_translationVector translationVector [emptyList] ;
#--- Parse input variables
  $($ ;
  repeat
    @lstring inputVar ;
    $identifier$ ? inputVar ;
    @uint inputVarIndex ;
    [ioVarMap searchKey !inputVar ?inputVarIndex] ;
    translationVector += !inputVarIndex ;
  while
    $,$ ;
  end repeat ;
  $)$ ;
  @uint inputVariablesCount := [translationVector length] ;
  if inputVariablesCount != machineInputVariableCount then
    error here : "The '$" . [machineIdentifier string] . "' machine defines " . [machineInputVariableCount string]
    . " input variable(s), but this operand defines " . [inputVariablesCount string] . " input variable(s)" ;
  end if ;
#--- Parse internal variables
  $($ ;
  select
  or
    repeat
      @lstring internalVar ;
      $identifier$ ? internalVar ;
      @uint internalVarIndex ;
      [ioVarMap searchKey !internalVar ?internalVarIndex] ;
      translationVector += ! internalVarIndex ;
    while
      $,$ ;
    end repeat ;
  end select ;
  $)$ ;
  @uint inputAndInternalVariablesCount := [translationVector length] ;
  if inputAndInternalVariablesCount != machineInputAndInternalVariableCount then
    error here : "The '$" . [machineIdentifier string] . "' machine defines " . [machineInputAndInternalVariableCount string]
    . " input and internal variable(s), but this operand defines " . [inputAndInternalVariablesCount string] . " input and internal variable(s)" ;
  end if ;
#--- Parse output variables
  $($ ;
  repeat
    @lstring outputVar ;
    $identifier$ ? outputVar ;
    @uint outputVarIndex ;
    [ioVarMap searchKey !outputVar ?outputVarIndex] ;
    translationVector += !outputVarIndex ;
  while
    $,$ ;
  end repeat ;
  $)$ ;
  @uint allVariablesCount := [translationVector length] ;
  @uint machineAllVariablesCount := [machineVariablesMap count] ;
  if allVariablesCount != machineAllVariablesCount then
    error here : "The '$" . [machineIdentifier string] . "' machine defines " . [machineAllVariablesCount string]
    . " variables, but this operand defines " . [allVariablesCount string] . " variables" ;
  end if ;
  outDefinition := [@C_importMachine new !indexOfImportedMachine !translationVector] ;
end rule ;

#---------------------------------------------------------------------------*
#         EXPLICIT AUTOMATON                                                *
#---------------------------------------------------------------------------*

rule <explicit_automaton>
  ??@semanticContext inSemanticContext
  ?!@M_variablesMap variablesMap
  !@AC_machineDefinition outDefinition
:
  @M_stateMap statesMap [emptyMap] ;
  @L_stateDefinition stateDefinitionList [emptyList] ;
  $auto$ ;
  ${$ ;
#--- States declaration
  $state$ ;
  repeat
    @lstring stateName ;
    $identifier$ ? stateName ;
    [!?statesMap insertKey !stateName ![statesMap count]] ;
  while
    $,$ ;
  end repeat ;
  $;$ ;
#--- Initial states
  @L_statesDefinitionList initialStatesDefinitionList [emptyList] ;
  $first$ ;
  repeat
    @lstring initialState ;
    $identifier$ ? initialState ;
    @uint initialStateIndex ;
    [statesMap searchKey !initialState ?initialStateIndex] ;
    initialStatesDefinitionList += !initialStateIndex !here ;
  while
    $,$ ;
  end repeat ;
  $;$ ;
#--- terminal states
  @L_statesDefinitionList terminalStatesDefinitionList [emptyList] ;
  select
  or
    $last$ ;
    repeat
      @lstring terminalState ;
      $identifier$ ? terminalState ;
      @uint terminalStateIndex ;
      [statesMap searchKey !terminalState ?terminalStateIndex] ;
      terminalStatesDefinitionList += ! terminalStateIndex !here ;
    while
      $,$ ;
    end repeat ;
    $;$ ;
  end select ;
#--- Parse state definitions
  @M_stateMap stateDefinitionMap [emptyMap] ;
  repeat
  #--- Current state
    @lstring stateName ;
    $identifier$ ? stateName ;
    @uint stateIndex ;
    [statesMap searchKey !stateName ?stateIndex] ;
    [!?stateDefinitionMap defineState !stateName ![stateDefinitionMap count]] ;
    $:$ ;
  #--- State input expression
    @AC_boolExpression stateExpression ;
    <io_bool_expression> !inSemanticContext !?variablesMap ?stateExpression ;
    @location endOfStateExpression := here ;
    ${$ ;
  #--- Parse state transition
    @L_transitionDefinition transitionsList [emptyList] ;
    repeat
    while
      @AC_boolExpression transitionInputExpression ;
      <io_bool_expression> !inSemanticContext !?variablesMap ?transitionInputExpression ;
      @location endOfExpression := here ;
      $goto$ ;
      @lstring targetStateName ;
      $identifier$ ? targetStateName ;
      @uint targetStateIndex ;
      [statesMap searchKey !targetStateName ?targetStateIndex] ;
      transitionsList += !transitionInputExpression !endOfExpression !targetStateIndex ;
      $;$ ;
    end repeat ;
    $}$ ;
    stateDefinitionList += !stateIndex !stateExpression !endOfStateExpression
                           !transitionsList ;
  while
  end repeat ;
#--- Check all states are defined
  foreach statesMap do
    if not [stateDefinitionMap hasKey ![lkey string]] then
      error here : "'" . lkey . "' state is not described" ;
    end if ;
  end foreach ;
#--- End of input source
  $}$ ;
  outDefinition := [@C_explicitAutomatonDefinition new !statesMap !initialStatesDefinitionList !terminalStatesDefinitionList !stateDefinitionList !here] ;
end rule ;

#---------------------------------------------------------------------------*

end syntax ;

#--------------------------------------------------------------------------------*

