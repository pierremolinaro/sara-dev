//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'sara_semantics.cpp'                          *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                     november 18th, 2006, at 18h20'2"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "sara_semantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  static const char gGGSsourceFile [] = "sara_semantics.ggs" ;
  #define SOURCE_FILE_AT_LINE(line) , gGGSsourceFile, line
#else
  #define SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'M_variablesMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_variablesMap::
elementOf_GGS_M_variablesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_variablesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_variablesMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_variablesMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_variablesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_variablesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_variablesMap * info = (e_M_variablesMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_variablesMap GGS_M_variablesMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_variablesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_variablesMap::
operator == (const GGS_M_variablesMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_variablesMap::
operator != (const GGS_M_variablesMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_variablesMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_variablesMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_variablesMap info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_variablesMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_variablesMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' variable is not declared",
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_variablesMap::
method_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' variable is not declared",
                  inKey,
                  & outIndex
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_variablesMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' variable has been already declared",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_variablesMap GGS_M_variablesMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_variablesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_variablesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_variablesMap GGS_M_variablesMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_variablesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_variablesMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_variablesMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map 'M_stateMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_stateMap::
elementOf_GGS_M_stateMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_stateMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_stateMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_stateMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_stateMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_stateMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_stateMap * info = (e_M_stateMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_stateMap GGS_M_stateMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_stateMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_stateMap::
operator == (const GGS_M_stateMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_stateMap::
operator != (const GGS_M_stateMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_stateMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_stateMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_stateMap info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_stateMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_stateMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' state is not declared",
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_stateMap::
method_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' state is not declared",
                  inKey,
                  & outIndex
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_stateMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' state has been already declared",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_stateMap::
modifier_defineState (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' state has been already defined",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_stateMap GGS_M_stateMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_stateMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_stateMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_stateMap GGS_M_stateMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_stateMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_stateMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_stateMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@L_translationVector'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_translationVector::
elementOf_GGS_L_translationVector (const GGS_luint & argument_0):
mTargetSlot (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_translationVector::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_translationVector * _p = dynamic_cast <const elementOf_GGS_L_translationVector *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mTargetSlot == _p->mTargetSlot).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_translationVector::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTargetSlot.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@L_translationVector'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_translationVector::GGS_L_translationVector (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_translationVector::
GGS_L_translationVector (const GGS_L_translationVector & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_translationVector::
operator == (const GGS_L_translationVector & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_translationVector::
operator != (const GGS_L_translationVector & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector::
_internalAppendValues (const GGS_luint & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector::
_internalPrependValues (const GGS_luint & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector::
_addAssign_operation (const GGS_luint & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_translationVector GGS_L_translationVector::
operator + (const GGS_L_translationVector & inOperand) const {
  GGS_L_translationVector result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_translationVector * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_luint  p_0 = p->mTargetSlot ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_luint & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mTargetSlot) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_translationVector  GGS_L_translationVector::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_translationVector result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_translationVector  GGS_L_translationVector::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_luint & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_translationVector result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_translationVector::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_translationVector", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector::
method_first (C_Lexique & _inLexique,
              GGS_luint & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTargetSlot ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector::
method_last (C_Lexique & _inLexique,
             GGS_luint & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTargetSlot ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_luint & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTargetSlot ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector::
modifier_popLast (C_Lexique & _inLexique,
                GGS_luint & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mTargetSlot ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_AC_boolExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_boolExpression::
cPtr_AC_boolExpression (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_boolExpression * GGS_AC_boolExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
      return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_AC_boolExpression::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@AC_boolExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_AC_boolExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_boolExpression::
GGS_AC_boolExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression::
GGS_AC_boolExpression (const GGS_AC_boolExpression & inOperand) {
  mPointer = (cPtr_AC_boolExpression *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression::
~GGS_AC_boolExpression (void) {
  macroDetachPointer (mPointer, cPtr_AC_boolExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_boolExpression::
operator = (const GGS_AC_boolExpression & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_boolExpression::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_boolExpression) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_AC_boolExpression::
operator == (const GGS_AC_boolExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_AC_boolExpression::
operator != (const GGS_AC_boolExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_boolExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @AC_boolExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_C_importBoolMachine'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_importBoolMachine::
cPtr_C_importBoolMachine (const GGS_uint & argument_0,
                                const GGS_location & argument_1,
                                const GGS_L_translationVector & argument_2 COMMA_LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE),
mIndexOfImportedMachine (argument_0),
mErrorLocation (argument_1),
mTranslationVector (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_importBoolMachine * GGS_C_importBoolMachine::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_importBoolMachine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_importBoolMachine *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_importBoolMachine::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_importBoolMachine * _p = dynamic_cast <const cPtr_C_importBoolMachine *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mIndexOfImportedMachine == _p->mIndexOfImportedMachine).boolValue ()
         && (mErrorLocation == _p->mErrorLocation).boolValue ()
         && (mTranslationVector == _p->mTranslationVector).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_importBoolMachine::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_importBoolMachine:"
           << mIndexOfImportedMachine.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mErrorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTranslationVector.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_importBoolMachine'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_importBoolMachine::
GGS_C_importBoolMachine (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_importBoolMachine::
GGS_C_importBoolMachine (const GGS_C_importBoolMachine & inOperand)
:GGS_AC_boolExpression () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_importBoolMachine::
~GGS_C_importBoolMachine (void) {
  macroDetachPointer (mPointer, cPtr_C_importBoolMachine) ;
}

//---------------------------------------------------------------------------*

void GGS_C_importBoolMachine::
operator = (const GGS_C_importBoolMachine & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_importBoolMachine GGS_C_importBoolMachine::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_uint & argument_0,
                 const GGS_location & argument_1,
                 const GGS_L_translationVector & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_C_importBoolMachine * _ptr = (cPtr_C_importBoolMachine *) NULL ;
  macroMyNew (_ptr, cPtr_C_importBoolMachine (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_C_importBoolMachine result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_importBoolMachine::
reader_mIndexOfImportedMachine (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_importBoolMachine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_importBoolMachine *) mPointer)->mIndexOfImportedMachine ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_C_importBoolMachine::
reader_mErrorLocation (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_importBoolMachine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_importBoolMachine *) mPointer)->mErrorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_translationVector  GGS_C_importBoolMachine::
reader_mTranslationVector (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_translationVector   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_importBoolMachine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_importBoolMachine *) mPointer)->mTranslationVector ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_importBoolMachine::
operator == (const GGS_C_importBoolMachine & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_importBoolMachine::
operator != (const GGS_C_importBoolMachine & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_importBoolMachine::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_importBoolMachine" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_C_andExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_andExpression::
cPtr_C_andExpression (const GGS_AC_boolExpression & argument_0,
                                const GGS_AC_boolExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_andExpression * GGS_C_andExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_andExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_andExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_andExpression::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_andExpression * _p = dynamic_cast <const cPtr_C_andExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLeftExpression == _p->mLeftExpression).boolValue ()
         && (mRightExpression == _p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_andExpression::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_andExpression:"
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_andExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_andExpression::
GGS_C_andExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_andExpression::
GGS_C_andExpression (const GGS_C_andExpression & inOperand)
:GGS_AC_boolExpression () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_andExpression::
~GGS_C_andExpression (void) {
  macroDetachPointer (mPointer, cPtr_C_andExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_C_andExpression::
operator = (const GGS_C_andExpression & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_andExpression GGS_C_andExpression::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_AC_boolExpression & argument_0,
                 const GGS_AC_boolExpression & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_C_andExpression * _ptr = (cPtr_C_andExpression *) NULL ;
  macroMyNew (_ptr, cPtr_C_andExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_C_andExpression result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_C_andExpression::
reader_mLeftExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_boolExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_andExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_andExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_C_andExpression::
reader_mRightExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_boolExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_andExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_andExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_andExpression::
operator == (const GGS_C_andExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_andExpression::
operator != (const GGS_C_andExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_andExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_andExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_C_orExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_orExpression::
cPtr_C_orExpression (const GGS_AC_boolExpression & argument_0,
                                const GGS_AC_boolExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_orExpression * GGS_C_orExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_orExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_orExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_orExpression::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_orExpression * _p = dynamic_cast <const cPtr_C_orExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLeftExpression == _p->mLeftExpression).boolValue ()
         && (mRightExpression == _p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_orExpression::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_orExpression:"
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_orExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_orExpression::
GGS_C_orExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_orExpression::
GGS_C_orExpression (const GGS_C_orExpression & inOperand)
:GGS_AC_boolExpression () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_orExpression::
~GGS_C_orExpression (void) {
  macroDetachPointer (mPointer, cPtr_C_orExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_C_orExpression::
operator = (const GGS_C_orExpression & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_orExpression GGS_C_orExpression::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_AC_boolExpression & argument_0,
                 const GGS_AC_boolExpression & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_C_orExpression * _ptr = (cPtr_C_orExpression *) NULL ;
  macroMyNew (_ptr, cPtr_C_orExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_C_orExpression result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_C_orExpression::
reader_mLeftExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_boolExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_orExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_orExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_C_orExpression::
reader_mRightExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_boolExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_orExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_orExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_orExpression::
operator == (const GGS_C_orExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_orExpression::
operator != (const GGS_C_orExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_orExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_orExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_C_xorExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_xorExpression::
cPtr_C_xorExpression (const GGS_AC_boolExpression & argument_0,
                                const GGS_AC_boolExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_xorExpression * GGS_C_xorExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_xorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_xorExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_xorExpression::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_xorExpression * _p = dynamic_cast <const cPtr_C_xorExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLeftExpression == _p->mLeftExpression).boolValue ()
         && (mRightExpression == _p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_xorExpression::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_xorExpression:"
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_xorExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_xorExpression::
GGS_C_xorExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_xorExpression::
GGS_C_xorExpression (const GGS_C_xorExpression & inOperand)
:GGS_AC_boolExpression () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_xorExpression::
~GGS_C_xorExpression (void) {
  macroDetachPointer (mPointer, cPtr_C_xorExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_C_xorExpression::
operator = (const GGS_C_xorExpression & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_xorExpression GGS_C_xorExpression::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_AC_boolExpression & argument_0,
                 const GGS_AC_boolExpression & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_C_xorExpression * _ptr = (cPtr_C_xorExpression *) NULL ;
  macroMyNew (_ptr, cPtr_C_xorExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_C_xorExpression result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_C_xorExpression::
reader_mLeftExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_boolExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_xorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_xorExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_C_xorExpression::
reader_mRightExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_boolExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_xorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_xorExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_xorExpression::
operator == (const GGS_C_xorExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_xorExpression::
operator != (const GGS_C_xorExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_xorExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_xorExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_C_impliesExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_impliesExpression::
cPtr_C_impliesExpression (const GGS_AC_boolExpression & argument_0,
                                const GGS_AC_boolExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_impliesExpression * GGS_C_impliesExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_impliesExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_impliesExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_impliesExpression::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_impliesExpression * _p = dynamic_cast <const cPtr_C_impliesExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLeftExpression == _p->mLeftExpression).boolValue ()
         && (mRightExpression == _p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_impliesExpression::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_impliesExpression:"
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_impliesExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_impliesExpression::
GGS_C_impliesExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_impliesExpression::
GGS_C_impliesExpression (const GGS_C_impliesExpression & inOperand)
:GGS_AC_boolExpression () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_impliesExpression::
~GGS_C_impliesExpression (void) {
  macroDetachPointer (mPointer, cPtr_C_impliesExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_C_impliesExpression::
operator = (const GGS_C_impliesExpression & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_impliesExpression GGS_C_impliesExpression::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_AC_boolExpression & argument_0,
                 const GGS_AC_boolExpression & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_C_impliesExpression * _ptr = (cPtr_C_impliesExpression *) NULL ;
  macroMyNew (_ptr, cPtr_C_impliesExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_C_impliesExpression result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_C_impliesExpression::
reader_mLeftExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_boolExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_impliesExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_impliesExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_C_impliesExpression::
reader_mRightExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_boolExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_impliesExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_impliesExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_impliesExpression::
operator == (const GGS_C_impliesExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_impliesExpression::
operator != (const GGS_C_impliesExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_impliesExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_impliesExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_C_equalExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_equalExpression::
cPtr_C_equalExpression (const GGS_AC_boolExpression & argument_0,
                                const GGS_AC_boolExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_equalExpression * GGS_C_equalExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_equalExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_equalExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_equalExpression::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_equalExpression * _p = dynamic_cast <const cPtr_C_equalExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLeftExpression == _p->mLeftExpression).boolValue ()
         && (mRightExpression == _p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_equalExpression::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_equalExpression:"
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_equalExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_equalExpression::
GGS_C_equalExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_equalExpression::
GGS_C_equalExpression (const GGS_C_equalExpression & inOperand)
:GGS_AC_boolExpression () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_equalExpression::
~GGS_C_equalExpression (void) {
  macroDetachPointer (mPointer, cPtr_C_equalExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_C_equalExpression::
operator = (const GGS_C_equalExpression & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_equalExpression GGS_C_equalExpression::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_AC_boolExpression & argument_0,
                 const GGS_AC_boolExpression & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_C_equalExpression * _ptr = (cPtr_C_equalExpression *) NULL ;
  macroMyNew (_ptr, cPtr_C_equalExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_C_equalExpression result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_C_equalExpression::
reader_mLeftExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_boolExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_equalExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_equalExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_C_equalExpression::
reader_mRightExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_boolExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_equalExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_equalExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_equalExpression::
operator == (const GGS_C_equalExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_equalExpression::
operator != (const GGS_C_equalExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_equalExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_equalExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_C_notExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_notExpression::
cPtr_C_notExpression (const GGS_AC_boolExpression & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_notExpression * GGS_C_notExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_notExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_notExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_notExpression::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_notExpression * _p = dynamic_cast <const cPtr_C_notExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mExpression == _p->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_notExpression::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_notExpression:"
           << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_notExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_notExpression::
GGS_C_notExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_notExpression::
GGS_C_notExpression (const GGS_C_notExpression & inOperand)
:GGS_AC_boolExpression () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_notExpression::
~GGS_C_notExpression (void) {
  macroDetachPointer (mPointer, cPtr_C_notExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_C_notExpression::
operator = (const GGS_C_notExpression & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_notExpression GGS_C_notExpression::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_AC_boolExpression & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_C_notExpression * _ptr = (cPtr_C_notExpression *) NULL ;
  macroMyNew (_ptr, cPtr_C_notExpression (argument_0 COMMA_THERE)) ;
  GGS_C_notExpression result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_C_notExpression::
reader_mExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_boolExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_notExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_notExpression *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_notExpression::
operator == (const GGS_C_notExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_notExpression::
operator != (const GGS_C_notExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_notExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_notExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_C_VariableExpression'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_VariableExpression::
cPtr_C_VariableExpression (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE),
mInputVarIndex (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_VariableExpression * GGS_C_VariableExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_VariableExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_VariableExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_VariableExpression::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_VariableExpression * _p = dynamic_cast <const cPtr_C_VariableExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mInputVarIndex == _p->mInputVarIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_VariableExpression::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_VariableExpression:"
           << mInputVarIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_VariableExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_VariableExpression::
GGS_C_VariableExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_VariableExpression::
GGS_C_VariableExpression (const GGS_C_VariableExpression & inOperand)
:GGS_AC_boolExpression () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_VariableExpression::
~GGS_C_VariableExpression (void) {
  macroDetachPointer (mPointer, cPtr_C_VariableExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_C_VariableExpression::
operator = (const GGS_C_VariableExpression & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_VariableExpression GGS_C_VariableExpression::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_C_VariableExpression * _ptr = (cPtr_C_VariableExpression *) NULL ;
  macroMyNew (_ptr, cPtr_C_VariableExpression (argument_0 COMMA_THERE)) ;
  GGS_C_VariableExpression result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_C_VariableExpression::
reader_mInputVarIndex (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_VariableExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_VariableExpression *) mPointer)->mInputVarIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_VariableExpression::
operator == (const GGS_C_VariableExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_VariableExpression::
operator != (const GGS_C_VariableExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_VariableExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_VariableExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_C_trueExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_trueExpression::
cPtr_C_trueExpression (LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_trueExpression * GGS_C_trueExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_trueExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_trueExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_trueExpression::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_C_trueExpression::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@C_trueExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_trueExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_trueExpression::
GGS_C_trueExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_trueExpression::
GGS_C_trueExpression (const GGS_C_trueExpression & inOperand)
:GGS_AC_boolExpression () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_trueExpression::
~GGS_C_trueExpression (void) {
  macroDetachPointer (mPointer, cPtr_C_trueExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_C_trueExpression::
operator = (const GGS_C_trueExpression & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_trueExpression GGS_C_trueExpression::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_C_trueExpression * _ptr = (cPtr_C_trueExpression *) NULL ;
  macroMyNew (_ptr, cPtr_C_trueExpression (THERE)) ;
  GGS_C_trueExpression result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_trueExpression::
operator == (const GGS_C_trueExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_trueExpression::
operator != (const GGS_C_trueExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_trueExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_trueExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_C_falseExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_falseExpression::
cPtr_C_falseExpression (LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_falseExpression * GGS_C_falseExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_falseExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_falseExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_falseExpression::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_C_falseExpression::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@C_falseExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_falseExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_falseExpression::
GGS_C_falseExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_falseExpression::
GGS_C_falseExpression (const GGS_C_falseExpression & inOperand)
:GGS_AC_boolExpression () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_falseExpression::
~GGS_C_falseExpression (void) {
  macroDetachPointer (mPointer, cPtr_C_falseExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_C_falseExpression::
operator = (const GGS_C_falseExpression & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_falseExpression GGS_C_falseExpression::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_C_falseExpression * _ptr = (cPtr_C_falseExpression *) NULL ;
  macroMyNew (_ptr, cPtr_C_falseExpression (THERE)) ;
  GGS_C_falseExpression result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_falseExpression::
operator == (const GGS_C_falseExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_falseExpression::
operator != (const GGS_C_falseExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_falseExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_falseExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@L_transitionDefinition'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_transitionDefinition::
elementOf_GGS_L_transitionDefinition (const GGS_AC_boolExpression & argument_0,
                                const GGS_location & argument_1,
                                const GGS_luint & argument_2):
mActionExpression (argument_0),
mEndOfExpression (argument_1),
mTargetStateIndex (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_transitionDefinition::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_transitionDefinition * _p = dynamic_cast <const elementOf_GGS_L_transitionDefinition *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mActionExpression == _p->mActionExpression).boolValue ()
         && (mEndOfExpression == _p->mEndOfExpression).boolValue ()
         && (mTargetStateIndex == _p->mTargetStateIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_transitionDefinition::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActionExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndOfExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTargetStateIndex.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@L_transitionDefinition'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_transitionDefinition::GGS_L_transitionDefinition (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_transitionDefinition::
GGS_L_transitionDefinition (const GGS_L_transitionDefinition & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_transitionDefinition::
operator == (const GGS_L_transitionDefinition & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_transitionDefinition::
operator != (const GGS_L_transitionDefinition & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
_internalAppendValues (const GGS_AC_boolExpression & argument_0,
                    const GGS_location & argument_1,
                    const GGS_luint & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
_internalPrependValues (const GGS_AC_boolExpression & argument_0,
                    const GGS_location & argument_1,
                    const GGS_luint & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
_addAssign_operation (const GGS_AC_boolExpression & argument_0,
                                const GGS_location & argument_1,
                                const GGS_luint & argument_2) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_transitionDefinition GGS_L_transitionDefinition::
operator + (const GGS_L_transitionDefinition & inOperand) const {
  GGS_L_transitionDefinition result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_transitionDefinition * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_AC_boolExpression  p_0 = p->mActionExpression ;
          GGS_location  p_1 = p->mEndOfExpression ;
          GGS_luint  p_2 = p->mTargetStateIndex ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_AC_boolExpression & argument_0,
                     const GGS_location & argument_1,
                     const GGS_luint & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mActionExpression,
                                _p->mEndOfExpression,
                                _p->mTargetStateIndex) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_transitionDefinition  GGS_L_transitionDefinition::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_transitionDefinition result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_transitionDefinition  GGS_L_transitionDefinition::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_AC_boolExpression & argument_0,
                           const GGS_location & argument_1,
                           const GGS_luint & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_transitionDefinition result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_transitionDefinition::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_transitionDefinition", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
method_first (C_Lexique & _inLexique,
              GGS_AC_boolExpression & _out_0,
              GGS_location & _out_1,
              GGS_luint & _out_2
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mActionExpression ;
    _out_1 = _p->mEndOfExpression ;
    _out_2 = _p->mTargetStateIndex ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
method_last (C_Lexique & _inLexique,
             GGS_AC_boolExpression & _out_0,
             GGS_location & _out_1,
             GGS_luint & _out_2
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mActionExpression ;
    _out_1 = _p->mEndOfExpression ;
    _out_2 = _p->mTargetStateIndex ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_AC_boolExpression & _out_0,
                 GGS_location & _out_1,
                 GGS_luint & _out_2
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mActionExpression ;
    _out_1 = _p->mEndOfExpression ;
    _out_2 = _p->mTargetStateIndex ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
modifier_popLast (C_Lexique & _inLexique,
                GGS_AC_boolExpression & _out_0,
                GGS_location & _out_1,
                GGS_luint & _out_2
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mActionExpression ;
    _out_1 = _p->mEndOfExpression ;
    _out_2 = _p->mTargetStateIndex ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@L_stateDefinition'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_stateDefinition::
elementOf_GGS_L_stateDefinition (const GGS_luint & argument_0,
                                const GGS_AC_boolExpression & argument_1,
                                const GGS_location & argument_2,
                                const GGS_L_transitionDefinition & argument_3):
mStateIndex (argument_0),
mStateExpression (argument_1),
mEndOfStateExpression (argument_2),
mTransitionsList (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_stateDefinition::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_stateDefinition * _p = dynamic_cast <const elementOf_GGS_L_stateDefinition *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mStateIndex == _p->mStateIndex).boolValue ()
         && (mStateExpression == _p->mStateExpression).boolValue ()
         && (mEndOfStateExpression == _p->mEndOfStateExpression).boolValue ()
         && (mTransitionsList == _p->mTransitionsList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_stateDefinition::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStateIndex.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStateExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndOfStateExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTransitionsList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@L_stateDefinition'                          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_stateDefinition::GGS_L_stateDefinition (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_stateDefinition::
GGS_L_stateDefinition (const GGS_L_stateDefinition & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_stateDefinition::
operator == (const GGS_L_stateDefinition & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_stateDefinition::
operator != (const GGS_L_stateDefinition & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
_internalAppendValues (const GGS_luint & argument_0,
                    const GGS_AC_boolExpression & argument_1,
                    const GGS_location & argument_2,
                    const GGS_L_transitionDefinition & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
_internalPrependValues (const GGS_luint & argument_0,
                    const GGS_AC_boolExpression & argument_1,
                    const GGS_location & argument_2,
                    const GGS_L_transitionDefinition & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
_addAssign_operation (const GGS_luint & argument_0,
                                const GGS_AC_boolExpression & argument_1,
                                const GGS_location & argument_2,
                                const GGS_L_transitionDefinition & argument_3) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_stateDefinition GGS_L_stateDefinition::
operator + (const GGS_L_stateDefinition & inOperand) const {
  GGS_L_stateDefinition result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_stateDefinition * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_luint  p_0 = p->mStateIndex ;
          GGS_AC_boolExpression  p_1 = p->mStateExpression ;
          GGS_location  p_2 = p->mEndOfStateExpression ;
          GGS_L_transitionDefinition  p_3 = p->mTransitionsList ;
          result._internalAppendValues (p_0, p_1, p_2, p_3) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_luint & argument_0,
                     const GGS_AC_boolExpression & argument_1,
                     const GGS_location & argument_2,
                     const GGS_L_transitionDefinition & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mStateIndex,
                                _p->mStateExpression,
                                _p->mEndOfStateExpression,
                                _p->mTransitionsList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_stateDefinition  GGS_L_stateDefinition::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_stateDefinition result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_stateDefinition  GGS_L_stateDefinition::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_luint & argument_0,
                           const GGS_AC_boolExpression & argument_1,
                           const GGS_location & argument_2,
                           const GGS_L_transitionDefinition & argument_3
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_stateDefinition result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_stateDefinition::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_stateDefinition", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
method_first (C_Lexique & _inLexique,
              GGS_luint & _out_0,
              GGS_AC_boolExpression & _out_1,
              GGS_location & _out_2,
              GGS_L_transitionDefinition & _out_3
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mStateIndex ;
    _out_1 = _p->mStateExpression ;
    _out_2 = _p->mEndOfStateExpression ;
    _out_3 = _p->mTransitionsList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
method_last (C_Lexique & _inLexique,
             GGS_luint & _out_0,
             GGS_AC_boolExpression & _out_1,
             GGS_location & _out_2,
             GGS_L_transitionDefinition & _out_3
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mStateIndex ;
    _out_1 = _p->mStateExpression ;
    _out_2 = _p->mEndOfStateExpression ;
    _out_3 = _p->mTransitionsList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_luint & _out_0,
                 GGS_AC_boolExpression & _out_1,
                 GGS_location & _out_2,
                 GGS_L_transitionDefinition & _out_3
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mStateIndex ;
    _out_1 = _p->mStateExpression ;
    _out_2 = _p->mEndOfStateExpression ;
    _out_3 = _p->mTransitionsList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
modifier_popLast (C_Lexique & _inLexique,
                GGS_luint & _out_0,
                GGS_AC_boolExpression & _out_1,
                GGS_location & _out_2,
                GGS_L_transitionDefinition & _out_3
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mStateIndex ;
    _out_1 = _p->mStateExpression ;
    _out_2 = _p->mEndOfStateExpression ;
    _out_3 = _p->mTransitionsList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@L_statesDefinitionList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_statesDefinitionList::
elementOf_GGS_L_statesDefinitionList (const GGS_luint & argument_0,
                                const GGS_location & argument_1):
mStateIndex (argument_0),
mStateLocation (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_statesDefinitionList::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_statesDefinitionList * _p = dynamic_cast <const elementOf_GGS_L_statesDefinitionList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mStateIndex == _p->mStateIndex).boolValue ()
         && (mStateLocation == _p->mStateLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_statesDefinitionList::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStateIndex.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStateLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@L_statesDefinitionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_statesDefinitionList::GGS_L_statesDefinitionList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_statesDefinitionList::
GGS_L_statesDefinitionList (const GGS_L_statesDefinitionList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_statesDefinitionList::
operator == (const GGS_L_statesDefinitionList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_statesDefinitionList::
operator != (const GGS_L_statesDefinitionList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList::
_internalAppendValues (const GGS_luint & argument_0,
                    const GGS_location & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList::
_internalPrependValues (const GGS_luint & argument_0,
                    const GGS_location & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList::
_addAssign_operation (const GGS_luint & argument_0,
                                const GGS_location & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_statesDefinitionList GGS_L_statesDefinitionList::
operator + (const GGS_L_statesDefinitionList & inOperand) const {
  GGS_L_statesDefinitionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_statesDefinitionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_luint  p_0 = p->mStateIndex ;
          GGS_location  p_1 = p->mStateLocation ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_luint & argument_0,
                     const GGS_location & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mStateIndex,
                                _p->mStateLocation) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_statesDefinitionList  GGS_L_statesDefinitionList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_statesDefinitionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_statesDefinitionList  GGS_L_statesDefinitionList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_luint & argument_0,
                           const GGS_location & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_statesDefinitionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_statesDefinitionList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_statesDefinitionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList::
method_first (C_Lexique & _inLexique,
              GGS_luint & _out_0,
              GGS_location & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mStateIndex ;
    _out_1 = _p->mStateLocation ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList::
method_last (C_Lexique & _inLexique,
             GGS_luint & _out_0,
             GGS_location & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mStateIndex ;
    _out_1 = _p->mStateLocation ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_luint & _out_0,
                 GGS_location & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mStateIndex ;
    _out_1 = _p->mStateLocation ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList::
modifier_popLast (C_Lexique & _inLexique,
                GGS_luint & _out_0,
                GGS_location & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mStateIndex ;
    _out_1 = _p->mStateLocation ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_AC_machineDefinition'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_machineDefinition::
cPtr_AC_machineDefinition (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_machineDefinition * GGS_AC_machineDefinition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
      return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_AC_machineDefinition::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@AC_machineDefinition:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_AC_machineDefinition'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_machineDefinition::
GGS_AC_machineDefinition (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition::
GGS_AC_machineDefinition (const GGS_AC_machineDefinition & inOperand) {
  mPointer = (cPtr_AC_machineDefinition *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition::
~GGS_AC_machineDefinition (void) {
  macroDetachPointer (mPointer, cPtr_AC_machineDefinition) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_machineDefinition::
operator = (const GGS_AC_machineDefinition & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_machineDefinition::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_machineDefinition) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_AC_machineDefinition::
operator == (const GGS_AC_machineDefinition & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_AC_machineDefinition::
operator != (const GGS_AC_machineDefinition & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_machineDefinition::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @AC_machineDefinition" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map 'M_modesMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_modesMap::
elementOf_GGS_M_modesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_modesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_modesMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mModeDefinition.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_modesMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_modesMap * _p = dynamic_cast <const elementOf_GGS_M_modesMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mModeDefinition == _p->mInfo.mModeDefinition).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_modesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_modesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_modesMap * info = (e_M_modesMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_modesMap GGS_M_modesMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_modesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_modesMap::
operator == (const GGS_M_modesMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_modesMap::
operator != (const GGS_M_modesMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_modesMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_modesMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_AC_machineDefinition & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_modesMap info  ;
    info.mModeDefinition = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_modesMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_machineDefinition   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mModeDefinition ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_modesMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_machineDefinition   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' mode is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_modesMap::
method_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_machineDefinition   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' mode is not declared",
                  inKey,
                  outParameter0,
                  & outIndex
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_modesMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_machineDefinition & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' mode has been already declared",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_modesMap GGS_M_modesMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_modesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_modesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_modesMap GGS_M_modesMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_modesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_modesMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_modesMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@ListForModes'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ListForModes::
elementOf_GGS_ListForModes (const GGS_luint & argument_0,
                                const GGS_luint & argument_1):
mSourceMode (argument_0),
mTargetMode (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_ListForModes::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_ListForModes * _p = dynamic_cast <const elementOf_GGS_ListForModes *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mSourceMode == _p->mSourceMode).boolValue ()
         && (mTargetMode == _p->mTargetMode).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ListForModes::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSourceMode.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTargetMode.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           List '@ListForModes'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ListForModes::GGS_ListForModes (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_ListForModes::
GGS_ListForModes (const GGS_ListForModes & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ListForModes::
operator == (const GGS_ListForModes & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ListForModes::
operator != (const GGS_ListForModes & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_ListForModes::
_internalAppendValues (const GGS_luint & argument_0,
                    const GGS_luint & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ListForModes::
_internalPrependValues (const GGS_luint & argument_0,
                    const GGS_luint & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ListForModes::
_addAssign_operation (const GGS_luint & argument_0,
                                const GGS_luint & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_ListForModes GGS_ListForModes::
operator + (const GGS_ListForModes & inOperand) const {
  GGS_ListForModes result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_ListForModes * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_luint  p_0 = p->mSourceMode ;
          GGS_luint  p_1 = p->mTargetMode ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ListForModes::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_luint & argument_0,
                     const GGS_luint & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ListForModes::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSourceMode,
                                _p->mTargetMode) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ListForModes  GGS_ListForModes::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ListForModes result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ListForModes  GGS_ListForModes::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_luint & argument_0,
                           const GGS_luint & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ListForModes result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ListForModes::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@ListForModes", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_ListForModes::
method_first (C_Lexique & _inLexique,
              GGS_luint & _out_0,
              GGS_luint & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSourceMode ;
    _out_1 = _p->mTargetMode ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ListForModes::
method_last (C_Lexique & _inLexique,
             GGS_luint & _out_0,
             GGS_luint & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSourceMode ;
    _out_1 = _p->mTargetMode ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ListForModes::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_luint & _out_0,
                 GGS_luint & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSourceMode ;
    _out_1 = _p->mTargetMode ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ListForModes::
modifier_popLast (C_Lexique & _inLexique,
                GGS_luint & _out_0,
                GGS_luint & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSourceMode ;
    _out_1 = _p->mTargetMode ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//      abstract class 'cPtr_C_substractiveModalCompositionComponent'        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_substractiveModalCompositionComponent::
cPtr_C_substractiveModalCompositionComponent (const GGS_M_modesMap & argument_0,
                                const GGS_ListForModes & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mModeMap (argument_0),
mExclusionList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_substractiveModalCompositionComponent * GGS_C_substractiveModalCompositionComponent::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_substractiveModalCompositionComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_substractiveModalCompositionComponent *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_substractiveModalCompositionComponent::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_substractiveModalCompositionComponent * _p = dynamic_cast <const cPtr_C_substractiveModalCompositionComponent *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mModeMap == _p->mModeMap).boolValue ()
         && (mExclusionList == _p->mExclusionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_substractiveModalCompositionComponent::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_substractiveModalCompositionComponent:"
           << mModeMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExclusionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_C_substractiveModalCompositionComponent'         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_substractiveModalCompositionComponent::
GGS_C_substractiveModalCompositionComponent (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_substractiveModalCompositionComponent::
GGS_C_substractiveModalCompositionComponent (const GGS_C_substractiveModalCompositionComponent & inOperand)
:GGS_AC_machineDefinition () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_substractiveModalCompositionComponent::
~GGS_C_substractiveModalCompositionComponent (void) {
  macroDetachPointer (mPointer, cPtr_C_substractiveModalCompositionComponent) ;
}

//---------------------------------------------------------------------------*

void GGS_C_substractiveModalCompositionComponent::
operator = (const GGS_C_substractiveModalCompositionComponent & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_substractiveModalCompositionComponent GGS_C_substractiveModalCompositionComponent::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_M_modesMap & argument_0,
                 const GGS_ListForModes & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_C_substractiveModalCompositionComponent * _ptr = (cPtr_C_substractiveModalCompositionComponent *) NULL ;
  macroMyNew (_ptr, cPtr_C_substractiveModalCompositionComponent (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_C_substractiveModalCompositionComponent result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_modesMap  GGS_C_substractiveModalCompositionComponent::
reader_mModeMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_modesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_substractiveModalCompositionComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_substractiveModalCompositionComponent *) mPointer)->mModeMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ListForModes  GGS_C_substractiveModalCompositionComponent::
reader_mExclusionList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ListForModes   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_substractiveModalCompositionComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_substractiveModalCompositionComponent *) mPointer)->mExclusionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_substractiveModalCompositionComponent::
operator == (const GGS_C_substractiveModalCompositionComponent & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_substractiveModalCompositionComponent::
operator != (const GGS_C_substractiveModalCompositionComponent & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_substractiveModalCompositionComponent::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_substractiveModalCompositionComponent" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        abstract class 'cPtr_C_additiveModalCompositionComponent'          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_additiveModalCompositionComponent::
cPtr_C_additiveModalCompositionComponent (const GGS_M_modesMap & argument_0,
                                const GGS_ListForModes & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mModeMap (argument_0),
mInclusionList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_additiveModalCompositionComponent * GGS_C_additiveModalCompositionComponent::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_additiveModalCompositionComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_additiveModalCompositionComponent *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_additiveModalCompositionComponent::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_additiveModalCompositionComponent * _p = dynamic_cast <const cPtr_C_additiveModalCompositionComponent *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mModeMap == _p->mModeMap).boolValue ()
         && (mInclusionList == _p->mInclusionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_additiveModalCompositionComponent::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_additiveModalCompositionComponent:"
           << mModeMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInclusionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_C_additiveModalCompositionComponent'           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_additiveModalCompositionComponent::
GGS_C_additiveModalCompositionComponent (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_additiveModalCompositionComponent::
GGS_C_additiveModalCompositionComponent (const GGS_C_additiveModalCompositionComponent & inOperand)
:GGS_AC_machineDefinition () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_additiveModalCompositionComponent::
~GGS_C_additiveModalCompositionComponent (void) {
  macroDetachPointer (mPointer, cPtr_C_additiveModalCompositionComponent) ;
}

//---------------------------------------------------------------------------*

void GGS_C_additiveModalCompositionComponent::
operator = (const GGS_C_additiveModalCompositionComponent & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_additiveModalCompositionComponent GGS_C_additiveModalCompositionComponent::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_M_modesMap & argument_0,
                 const GGS_ListForModes & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_C_additiveModalCompositionComponent * _ptr = (cPtr_C_additiveModalCompositionComponent *) NULL ;
  macroMyNew (_ptr, cPtr_C_additiveModalCompositionComponent (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_C_additiveModalCompositionComponent result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_modesMap  GGS_C_additiveModalCompositionComponent::
reader_mModeMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_modesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_additiveModalCompositionComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_additiveModalCompositionComponent *) mPointer)->mModeMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ListForModes  GGS_C_additiveModalCompositionComponent::
reader_mInclusionList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ListForModes   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_additiveModalCompositionComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_additiveModalCompositionComponent *) mPointer)->mInclusionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_additiveModalCompositionComponent::
operator == (const GGS_C_additiveModalCompositionComponent & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_additiveModalCompositionComponent::
operator != (const GGS_C_additiveModalCompositionComponent & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_additiveModalCompositionComponent::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_additiveModalCompositionComponent" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      abstract class 'cPtr_C_trans'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_trans::
cPtr_C_trans (const GGS_AC_boolExpression & argument_0,
                                const GGS_AC_boolExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mSourceStateExpression (argument_0),
mTargetStateExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_trans * GGS_C_trans::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_trans *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_trans *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_trans::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_trans * _p = dynamic_cast <const cPtr_C_trans *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mSourceStateExpression == _p->mSourceStateExpression).boolValue ()
         && (mTargetStateExpression == _p->mTargetStateExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_trans::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_trans:"
           << mSourceStateExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTargetStateExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        GALGAS class 'GGS_C_trans'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_trans::
GGS_C_trans (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_trans::
GGS_C_trans (const GGS_C_trans & inOperand)
:GGS_AC_machineDefinition () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_trans::
~GGS_C_trans (void) {
  macroDetachPointer (mPointer, cPtr_C_trans) ;
}

//---------------------------------------------------------------------------*

void GGS_C_trans::
operator = (const GGS_C_trans & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_trans GGS_C_trans::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_AC_boolExpression & argument_0,
                 const GGS_AC_boolExpression & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_C_trans * _ptr = (cPtr_C_trans *) NULL ;
  macroMyNew (_ptr, cPtr_C_trans (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_C_trans result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_C_trans::
reader_mSourceStateExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_boolExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_trans *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_trans *) mPointer)->mSourceStateExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_C_trans::
reader_mTargetStateExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_boolExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_trans *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_trans *) mPointer)->mTargetStateExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_trans::
operator == (const GGS_C_trans & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_trans::
operator != (const GGS_C_trans & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_trans::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_trans" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_C_importMachine'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_importMachine::
cPtr_C_importMachine (const GGS_uint & argument_0,
                                const GGS_L_translationVector & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mIndexOfImportedMachine (argument_0),
mTranslationVector (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_importMachine * GGS_C_importMachine::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_importMachine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_importMachine *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_importMachine::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_importMachine * _p = dynamic_cast <const cPtr_C_importMachine *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mIndexOfImportedMachine == _p->mIndexOfImportedMachine).boolValue ()
         && (mTranslationVector == _p->mTranslationVector).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_importMachine::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_importMachine:"
           << mIndexOfImportedMachine.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTranslationVector.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_importMachine'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_importMachine::
GGS_C_importMachine (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_importMachine::
GGS_C_importMachine (const GGS_C_importMachine & inOperand)
:GGS_AC_machineDefinition () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_importMachine::
~GGS_C_importMachine (void) {
  macroDetachPointer (mPointer, cPtr_C_importMachine) ;
}

//---------------------------------------------------------------------------*

void GGS_C_importMachine::
operator = (const GGS_C_importMachine & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_importMachine GGS_C_importMachine::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_uint & argument_0,
                 const GGS_L_translationVector & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_C_importMachine * _ptr = (cPtr_C_importMachine *) NULL ;
  macroMyNew (_ptr, cPtr_C_importMachine (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_C_importMachine result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_importMachine::
reader_mIndexOfImportedMachine (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_importMachine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_importMachine *) mPointer)->mIndexOfImportedMachine ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_translationVector  GGS_C_importMachine::
reader_mTranslationVector (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_translationVector   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_importMachine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_importMachine *) mPointer)->mTranslationVector ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_importMachine::
operator == (const GGS_C_importMachine & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_importMachine::
operator != (const GGS_C_importMachine & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_importMachine::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_importMachine" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           abstract class 'cPtr_C_explicitAutomatonDefinition'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_explicitAutomatonDefinition::
cPtr_C_explicitAutomatonDefinition (const GGS_M_stateMap & argument_0,
                                const GGS_L_statesDefinitionList & argument_1,
                                const GGS_L_statesDefinitionList & argument_2,
                                const GGS_L_stateDefinition & argument_3,
                                const GGS_location & argument_4 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mStatesMap (argument_0),
mInitialStatesDefinitionList (argument_1),
mTerminalStatesDefinitionList (argument_2),
mStateDefinitionList (argument_3),
mEndOfDefinition (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_explicitAutomatonDefinition * GGS_C_explicitAutomatonDefinition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_explicitAutomatonDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_explicitAutomatonDefinition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_explicitAutomatonDefinition::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_explicitAutomatonDefinition * _p = dynamic_cast <const cPtr_C_explicitAutomatonDefinition *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mStatesMap == _p->mStatesMap).boolValue ()
         && (mInitialStatesDefinitionList == _p->mInitialStatesDefinitionList).boolValue ()
         && (mTerminalStatesDefinitionList == _p->mTerminalStatesDefinitionList).boolValue ()
         && (mStateDefinitionList == _p->mStateDefinitionList).boolValue ()
         && (mEndOfDefinition == _p->mEndOfDefinition).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_explicitAutomatonDefinition::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_explicitAutomatonDefinition:"
           << mStatesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInitialStatesDefinitionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTerminalStatesDefinitionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mStateDefinitionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mEndOfDefinition.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_C_explicitAutomatonDefinition'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_explicitAutomatonDefinition::
GGS_C_explicitAutomatonDefinition (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_explicitAutomatonDefinition::
GGS_C_explicitAutomatonDefinition (const GGS_C_explicitAutomatonDefinition & inOperand)
:GGS_AC_machineDefinition () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_explicitAutomatonDefinition::
~GGS_C_explicitAutomatonDefinition (void) {
  macroDetachPointer (mPointer, cPtr_C_explicitAutomatonDefinition) ;
}

//---------------------------------------------------------------------------*

void GGS_C_explicitAutomatonDefinition::
operator = (const GGS_C_explicitAutomatonDefinition & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_explicitAutomatonDefinition GGS_C_explicitAutomatonDefinition::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_M_stateMap & argument_0,
                 const GGS_L_statesDefinitionList & argument_1,
                 const GGS_L_statesDefinitionList & argument_2,
                 const GGS_L_stateDefinition & argument_3,
                 const GGS_location & argument_4 COMMA_LOCATION_ARGS) {
  cPtr_C_explicitAutomatonDefinition * _ptr = (cPtr_C_explicitAutomatonDefinition *) NULL ;
  macroMyNew (_ptr, cPtr_C_explicitAutomatonDefinition (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  GGS_C_explicitAutomatonDefinition result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_stateMap  GGS_C_explicitAutomatonDefinition::
reader_mStatesMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_stateMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_explicitAutomatonDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_explicitAutomatonDefinition *) mPointer)->mStatesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_statesDefinitionList  GGS_C_explicitAutomatonDefinition::
reader_mInitialStatesDefinitionList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_statesDefinitionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_explicitAutomatonDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_explicitAutomatonDefinition *) mPointer)->mInitialStatesDefinitionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_statesDefinitionList  GGS_C_explicitAutomatonDefinition::
reader_mTerminalStatesDefinitionList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_statesDefinitionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_explicitAutomatonDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_explicitAutomatonDefinition *) mPointer)->mTerminalStatesDefinitionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_stateDefinition  GGS_C_explicitAutomatonDefinition::
reader_mStateDefinitionList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_stateDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_explicitAutomatonDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_explicitAutomatonDefinition *) mPointer)->mStateDefinitionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_C_explicitAutomatonDefinition::
reader_mEndOfDefinition (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_explicitAutomatonDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_explicitAutomatonDefinition *) mPointer)->mEndOfDefinition ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_explicitAutomatonDefinition::
operator == (const GGS_C_explicitAutomatonDefinition & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_explicitAutomatonDefinition::
operator != (const GGS_C_explicitAutomatonDefinition & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_explicitAutomatonDefinition::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_explicitAutomatonDefinition" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_C_boolToSeqExpression'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_boolToSeqExpression::
cPtr_C_boolToSeqExpression (const GGS_AC_boolExpression & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_boolToSeqExpression * GGS_C_boolToSeqExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_boolToSeqExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_boolToSeqExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_boolToSeqExpression::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_boolToSeqExpression * _p = dynamic_cast <const cPtr_C_boolToSeqExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mExpression == _p->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_boolToSeqExpression::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_boolToSeqExpression:"
           << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_boolToSeqExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_boolToSeqExpression::
GGS_C_boolToSeqExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_boolToSeqExpression::
GGS_C_boolToSeqExpression (const GGS_C_boolToSeqExpression & inOperand)
:GGS_AC_machineDefinition () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_boolToSeqExpression::
~GGS_C_boolToSeqExpression (void) {
  macroDetachPointer (mPointer, cPtr_C_boolToSeqExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_C_boolToSeqExpression::
operator = (const GGS_C_boolToSeqExpression & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_boolToSeqExpression GGS_C_boolToSeqExpression::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_AC_boolExpression & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_C_boolToSeqExpression * _ptr = (cPtr_C_boolToSeqExpression *) NULL ;
  macroMyNew (_ptr, cPtr_C_boolToSeqExpression (argument_0 COMMA_THERE)) ;
  GGS_C_boolToSeqExpression result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_C_boolToSeqExpression::
reader_mExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_boolExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_boolToSeqExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_boolToSeqExpression *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_boolToSeqExpression::
operator == (const GGS_C_boolToSeqExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_boolToSeqExpression::
operator != (const GGS_C_boolToSeqExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_boolToSeqExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_boolToSeqExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_C_existsDefinition'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_existsDefinition::
cPtr_C_existsDefinition (const GGS_uint & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_AC_machineDefinition & argument_2 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mPreviousVariableCount (argument_0),
mTotalVariableCount (argument_1),
mOperand (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_existsDefinition * GGS_C_existsDefinition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_existsDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_existsDefinition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_existsDefinition::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_existsDefinition * _p = dynamic_cast <const cPtr_C_existsDefinition *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mPreviousVariableCount == _p->mPreviousVariableCount).boolValue ()
         && (mTotalVariableCount == _p->mTotalVariableCount).boolValue ()
         && (mOperand == _p->mOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_existsDefinition::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_existsDefinition:"
           << mPreviousVariableCount.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTotalVariableCount.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOperand.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_existsDefinition'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_existsDefinition::
GGS_C_existsDefinition (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_existsDefinition::
GGS_C_existsDefinition (const GGS_C_existsDefinition & inOperand)
:GGS_AC_machineDefinition () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_existsDefinition::
~GGS_C_existsDefinition (void) {
  macroDetachPointer (mPointer, cPtr_C_existsDefinition) ;
}

//---------------------------------------------------------------------------*

void GGS_C_existsDefinition::
operator = (const GGS_C_existsDefinition & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_existsDefinition GGS_C_existsDefinition::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_uint & argument_0,
                 const GGS_uint & argument_1,
                 const GGS_AC_machineDefinition & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_C_existsDefinition * _ptr = (cPtr_C_existsDefinition *) NULL ;
  macroMyNew (_ptr, cPtr_C_existsDefinition (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_C_existsDefinition result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_existsDefinition::
reader_mPreviousVariableCount (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_existsDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_existsDefinition *) mPointer)->mPreviousVariableCount ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_existsDefinition::
reader_mTotalVariableCount (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_existsDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_existsDefinition *) mPointer)->mTotalVariableCount ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_existsDefinition::
reader_mOperand (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_existsDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_existsDefinition *) mPointer)->mOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_existsDefinition::
operator == (const GGS_C_existsDefinition & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_existsDefinition::
operator != (const GGS_C_existsDefinition & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_existsDefinition::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_existsDefinition" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_C_forallDefinition'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_forallDefinition::
cPtr_C_forallDefinition (const GGS_uint & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_AC_machineDefinition & argument_2 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mPreviousVariableCount (argument_0),
mTotalVariableCount (argument_1),
mOperand (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_forallDefinition * GGS_C_forallDefinition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_forallDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_forallDefinition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_forallDefinition::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_forallDefinition * _p = dynamic_cast <const cPtr_C_forallDefinition *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mPreviousVariableCount == _p->mPreviousVariableCount).boolValue ()
         && (mTotalVariableCount == _p->mTotalVariableCount).boolValue ()
         && (mOperand == _p->mOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_forallDefinition::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_forallDefinition:"
           << mPreviousVariableCount.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTotalVariableCount.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOperand.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_forallDefinition'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_forallDefinition::
GGS_C_forallDefinition (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_forallDefinition::
GGS_C_forallDefinition (const GGS_C_forallDefinition & inOperand)
:GGS_AC_machineDefinition () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_forallDefinition::
~GGS_C_forallDefinition (void) {
  macroDetachPointer (mPointer, cPtr_C_forallDefinition) ;
}

//---------------------------------------------------------------------------*

void GGS_C_forallDefinition::
operator = (const GGS_C_forallDefinition & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_forallDefinition GGS_C_forallDefinition::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_uint & argument_0,
                 const GGS_uint & argument_1,
                 const GGS_AC_machineDefinition & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_C_forallDefinition * _ptr = (cPtr_C_forallDefinition *) NULL ;
  macroMyNew (_ptr, cPtr_C_forallDefinition (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_C_forallDefinition result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_forallDefinition::
reader_mPreviousVariableCount (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_forallDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_forallDefinition *) mPointer)->mPreviousVariableCount ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_forallDefinition::
reader_mTotalVariableCount (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_forallDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_forallDefinition *) mPointer)->mTotalVariableCount ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_forallDefinition::
reader_mOperand (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_forallDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_forallDefinition *) mPointer)->mOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_forallDefinition::
operator == (const GGS_C_forallDefinition & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_forallDefinition::
operator != (const GGS_C_forallDefinition & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_forallDefinition::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_forallDefinition" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_C_parallelComposition'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_parallelComposition::
cPtr_C_parallelComposition (const GGS_AC_machineDefinition & argument_0,
                                const GGS_AC_machineDefinition & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mLeftOperand (argument_0),
mRightOperand (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_parallelComposition * GGS_C_parallelComposition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parallelComposition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_parallelComposition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_parallelComposition::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_parallelComposition * _p = dynamic_cast <const cPtr_C_parallelComposition *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLeftOperand == _p->mLeftOperand).boolValue ()
         && (mRightOperand == _p->mRightOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_parallelComposition::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_parallelComposition:"
           << mLeftOperand.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightOperand.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_parallelComposition'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_parallelComposition::
GGS_C_parallelComposition (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_parallelComposition::
GGS_C_parallelComposition (const GGS_C_parallelComposition & inOperand)
:GGS_AC_machineDefinition () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_parallelComposition::
~GGS_C_parallelComposition (void) {
  macroDetachPointer (mPointer, cPtr_C_parallelComposition) ;
}

//---------------------------------------------------------------------------*

void GGS_C_parallelComposition::
operator = (const GGS_C_parallelComposition & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_parallelComposition GGS_C_parallelComposition::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_AC_machineDefinition & argument_0,
                 const GGS_AC_machineDefinition & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_C_parallelComposition * _ptr = (cPtr_C_parallelComposition *) NULL ;
  macroMyNew (_ptr, cPtr_C_parallelComposition (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_C_parallelComposition result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_parallelComposition::
reader_mLeftOperand (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parallelComposition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_parallelComposition *) mPointer)->mLeftOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_parallelComposition::
reader_mRightOperand (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parallelComposition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_parallelComposition *) mPointer)->mRightOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_parallelComposition::
operator == (const GGS_C_parallelComposition & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_parallelComposition::
operator != (const GGS_C_parallelComposition & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_parallelComposition::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_parallelComposition" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_C_orComposition'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_orComposition::
cPtr_C_orComposition (const GGS_AC_machineDefinition & argument_0,
                                const GGS_AC_machineDefinition & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mLeftOperand (argument_0),
mRightOperand (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_orComposition * GGS_C_orComposition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_orComposition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_orComposition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_orComposition::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_orComposition * _p = dynamic_cast <const cPtr_C_orComposition *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLeftOperand == _p->mLeftOperand).boolValue ()
         && (mRightOperand == _p->mRightOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_orComposition::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_orComposition:"
           << mLeftOperand.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightOperand.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_orComposition'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_orComposition::
GGS_C_orComposition (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_orComposition::
GGS_C_orComposition (const GGS_C_orComposition & inOperand)
:GGS_AC_machineDefinition () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_orComposition::
~GGS_C_orComposition (void) {
  macroDetachPointer (mPointer, cPtr_C_orComposition) ;
}

//---------------------------------------------------------------------------*

void GGS_C_orComposition::
operator = (const GGS_C_orComposition & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_orComposition GGS_C_orComposition::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_AC_machineDefinition & argument_0,
                 const GGS_AC_machineDefinition & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_C_orComposition * _ptr = (cPtr_C_orComposition *) NULL ;
  macroMyNew (_ptr, cPtr_C_orComposition (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_C_orComposition result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_orComposition::
reader_mLeftOperand (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_orComposition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_orComposition *) mPointer)->mLeftOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_orComposition::
reader_mRightOperand (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_orComposition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_orComposition *) mPointer)->mRightOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_orComposition::
operator == (const GGS_C_orComposition & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_orComposition::
operator != (const GGS_C_orComposition & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_orComposition::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_orComposition" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_C_strongModalComposition'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_strongModalComposition::
cPtr_C_strongModalComposition (const GGS_AC_machineDefinition & argument_0,
                                const GGS_location & argument_1,
                                const GGS_AC_machineDefinition & argument_2 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mLeftOperand (argument_0),
mErrorLocation (argument_1),
mRightOperand (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_strongModalComposition * GGS_C_strongModalComposition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_strongModalComposition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_strongModalComposition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_strongModalComposition::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_strongModalComposition * _p = dynamic_cast <const cPtr_C_strongModalComposition *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLeftOperand == _p->mLeftOperand).boolValue ()
         && (mErrorLocation == _p->mErrorLocation).boolValue ()
         && (mRightOperand == _p->mRightOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_strongModalComposition::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_strongModalComposition:"
           << mLeftOperand.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mErrorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightOperand.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_C_strongModalComposition'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_strongModalComposition::
GGS_C_strongModalComposition (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_strongModalComposition::
GGS_C_strongModalComposition (const GGS_C_strongModalComposition & inOperand)
:GGS_AC_machineDefinition () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_strongModalComposition::
~GGS_C_strongModalComposition (void) {
  macroDetachPointer (mPointer, cPtr_C_strongModalComposition) ;
}

//---------------------------------------------------------------------------*

void GGS_C_strongModalComposition::
operator = (const GGS_C_strongModalComposition & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_strongModalComposition GGS_C_strongModalComposition::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_AC_machineDefinition & argument_0,
                 const GGS_location & argument_1,
                 const GGS_AC_machineDefinition & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_C_strongModalComposition * _ptr = (cPtr_C_strongModalComposition *) NULL ;
  macroMyNew (_ptr, cPtr_C_strongModalComposition (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_C_strongModalComposition result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_strongModalComposition::
reader_mLeftOperand (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_strongModalComposition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_strongModalComposition *) mPointer)->mLeftOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_C_strongModalComposition::
reader_mErrorLocation (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_strongModalComposition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_strongModalComposition *) mPointer)->mErrorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_strongModalComposition::
reader_mRightOperand (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_strongModalComposition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_strongModalComposition *) mPointer)->mRightOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_strongModalComposition::
operator == (const GGS_C_strongModalComposition & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_strongModalComposition::
operator != (const GGS_C_strongModalComposition & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_strongModalComposition::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_strongModalComposition" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_C_weakModalComposition'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_weakModalComposition::
cPtr_C_weakModalComposition (const GGS_AC_machineDefinition & argument_0,
                                const GGS_location & argument_1,
                                const GGS_AC_machineDefinition & argument_2 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mLeftOperand (argument_0),
mErrorLocation (argument_1),
mRightOperand (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_weakModalComposition * GGS_C_weakModalComposition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_weakModalComposition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_weakModalComposition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_weakModalComposition::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_weakModalComposition * _p = dynamic_cast <const cPtr_C_weakModalComposition *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLeftOperand == _p->mLeftOperand).boolValue ()
         && (mErrorLocation == _p->mErrorLocation).boolValue ()
         && (mRightOperand == _p->mRightOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_weakModalComposition::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_weakModalComposition:"
           << mLeftOperand.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mErrorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightOperand.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_weakModalComposition'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_weakModalComposition::
GGS_C_weakModalComposition (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_weakModalComposition::
GGS_C_weakModalComposition (const GGS_C_weakModalComposition & inOperand)
:GGS_AC_machineDefinition () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_weakModalComposition::
~GGS_C_weakModalComposition (void) {
  macroDetachPointer (mPointer, cPtr_C_weakModalComposition) ;
}

//---------------------------------------------------------------------------*

void GGS_C_weakModalComposition::
operator = (const GGS_C_weakModalComposition & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_weakModalComposition GGS_C_weakModalComposition::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_AC_machineDefinition & argument_0,
                 const GGS_location & argument_1,
                 const GGS_AC_machineDefinition & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_C_weakModalComposition * _ptr = (cPtr_C_weakModalComposition *) NULL ;
  macroMyNew (_ptr, cPtr_C_weakModalComposition (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_C_weakModalComposition result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_weakModalComposition::
reader_mLeftOperand (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_weakModalComposition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_weakModalComposition *) mPointer)->mLeftOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_C_weakModalComposition::
reader_mErrorLocation (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_weakModalComposition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_weakModalComposition *) mPointer)->mErrorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_weakModalComposition::
reader_mRightOperand (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_weakModalComposition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_weakModalComposition *) mPointer)->mRightOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_weakModalComposition::
operator == (const GGS_C_weakModalComposition & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_weakModalComposition::
operator != (const GGS_C_weakModalComposition & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_weakModalComposition::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_weakModalComposition" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_C_fullSaturationOperation'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_fullSaturationOperation::
cPtr_C_fullSaturationOperation (const GGS_AC_machineDefinition & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mOperand (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_fullSaturationOperation * GGS_C_fullSaturationOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_fullSaturationOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_fullSaturationOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_fullSaturationOperation::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_fullSaturationOperation * _p = dynamic_cast <const cPtr_C_fullSaturationOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mOperand == _p->mOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_fullSaturationOperation::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_fullSaturationOperation:"
           << mOperand.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_C_fullSaturationOperation'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_fullSaturationOperation::
GGS_C_fullSaturationOperation (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_fullSaturationOperation::
GGS_C_fullSaturationOperation (const GGS_C_fullSaturationOperation & inOperand)
:GGS_AC_machineDefinition () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_fullSaturationOperation::
~GGS_C_fullSaturationOperation (void) {
  macroDetachPointer (mPointer, cPtr_C_fullSaturationOperation) ;
}

//---------------------------------------------------------------------------*

void GGS_C_fullSaturationOperation::
operator = (const GGS_C_fullSaturationOperation & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_fullSaturationOperation GGS_C_fullSaturationOperation::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_AC_machineDefinition & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_C_fullSaturationOperation * _ptr = (cPtr_C_fullSaturationOperation *) NULL ;
  macroMyNew (_ptr, cPtr_C_fullSaturationOperation (argument_0 COMMA_THERE)) ;
  GGS_C_fullSaturationOperation result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_fullSaturationOperation::
reader_mOperand (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_fullSaturationOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_fullSaturationOperation *) mPointer)->mOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_fullSaturationOperation::
operator == (const GGS_C_fullSaturationOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_fullSaturationOperation::
operator != (const GGS_C_fullSaturationOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_fullSaturationOperation::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_fullSaturationOperation" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_C_complementationOperation'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_complementationOperation::
cPtr_C_complementationOperation (const GGS_AC_machineDefinition & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mOperand (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_complementationOperation * GGS_C_complementationOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_complementationOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_complementationOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_complementationOperation::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_complementationOperation * _p = dynamic_cast <const cPtr_C_complementationOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mOperand == _p->mOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_complementationOperation::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_complementationOperation:"
           << mOperand.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_C_complementationOperation'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_complementationOperation::
GGS_C_complementationOperation (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_complementationOperation::
GGS_C_complementationOperation (const GGS_C_complementationOperation & inOperand)
:GGS_AC_machineDefinition () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_complementationOperation::
~GGS_C_complementationOperation (void) {
  macroDetachPointer (mPointer, cPtr_C_complementationOperation) ;
}

//---------------------------------------------------------------------------*

void GGS_C_complementationOperation::
operator = (const GGS_C_complementationOperation & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_complementationOperation GGS_C_complementationOperation::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_AC_machineDefinition & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_C_complementationOperation * _ptr = (cPtr_C_complementationOperation *) NULL ;
  macroMyNew (_ptr, cPtr_C_complementationOperation (argument_0 COMMA_THERE)) ;
  GGS_C_complementationOperation result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_complementationOperation::
reader_mOperand (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_complementationOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_complementationOperation *) mPointer)->mOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_complementationOperation::
operator == (const GGS_C_complementationOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_complementationOperation::
operator != (const GGS_C_complementationOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_complementationOperation::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_complementationOperation" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         abstract class 'cPtr_C_suppressTerminalStatesOperation'           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_suppressTerminalStatesOperation::
cPtr_C_suppressTerminalStatesOperation (const GGS_AC_machineDefinition & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mOperand (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_suppressTerminalStatesOperation * GGS_C_suppressTerminalStatesOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_suppressTerminalStatesOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_suppressTerminalStatesOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_suppressTerminalStatesOperation::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_suppressTerminalStatesOperation * _p = dynamic_cast <const cPtr_C_suppressTerminalStatesOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mOperand == _p->mOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_suppressTerminalStatesOperation::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_suppressTerminalStatesOperation:"
           << mOperand.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_C_suppressTerminalStatesOperation'            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_suppressTerminalStatesOperation::
GGS_C_suppressTerminalStatesOperation (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_suppressTerminalStatesOperation::
GGS_C_suppressTerminalStatesOperation (const GGS_C_suppressTerminalStatesOperation & inOperand)
:GGS_AC_machineDefinition () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_suppressTerminalStatesOperation::
~GGS_C_suppressTerminalStatesOperation (void) {
  macroDetachPointer (mPointer, cPtr_C_suppressTerminalStatesOperation) ;
}

//---------------------------------------------------------------------------*

void GGS_C_suppressTerminalStatesOperation::
operator = (const GGS_C_suppressTerminalStatesOperation & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_suppressTerminalStatesOperation GGS_C_suppressTerminalStatesOperation::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_AC_machineDefinition & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_C_suppressTerminalStatesOperation * _ptr = (cPtr_C_suppressTerminalStatesOperation *) NULL ;
  macroMyNew (_ptr, cPtr_C_suppressTerminalStatesOperation (argument_0 COMMA_THERE)) ;
  GGS_C_suppressTerminalStatesOperation result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_suppressTerminalStatesOperation::
reader_mOperand (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_suppressTerminalStatesOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_suppressTerminalStatesOperation *) mPointer)->mOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_suppressTerminalStatesOperation::
operator == (const GGS_C_suppressTerminalStatesOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_suppressTerminalStatesOperation::
operator != (const GGS_C_suppressTerminalStatesOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_suppressTerminalStatesOperation::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_suppressTerminalStatesOperation" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          abstract class 'cPtr_C_suppressInitialStatesOperation'           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_suppressInitialStatesOperation::
cPtr_C_suppressInitialStatesOperation (const GGS_AC_machineDefinition & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mOperand (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_suppressInitialStatesOperation * GGS_C_suppressInitialStatesOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_suppressInitialStatesOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_suppressInitialStatesOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_suppressInitialStatesOperation::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_suppressInitialStatesOperation * _p = dynamic_cast <const cPtr_C_suppressInitialStatesOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mOperand == _p->mOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_suppressInitialStatesOperation::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_suppressInitialStatesOperation:"
           << mOperand.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_C_suppressInitialStatesOperation'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_suppressInitialStatesOperation::
GGS_C_suppressInitialStatesOperation (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_suppressInitialStatesOperation::
GGS_C_suppressInitialStatesOperation (const GGS_C_suppressInitialStatesOperation & inOperand)
:GGS_AC_machineDefinition () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_suppressInitialStatesOperation::
~GGS_C_suppressInitialStatesOperation (void) {
  macroDetachPointer (mPointer, cPtr_C_suppressInitialStatesOperation) ;
}

//---------------------------------------------------------------------------*

void GGS_C_suppressInitialStatesOperation::
operator = (const GGS_C_suppressInitialStatesOperation & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_suppressInitialStatesOperation GGS_C_suppressInitialStatesOperation::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_AC_machineDefinition & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_C_suppressInitialStatesOperation * _ptr = (cPtr_C_suppressInitialStatesOperation *) NULL ;
  macroMyNew (_ptr, cPtr_C_suppressInitialStatesOperation (argument_0 COMMA_THERE)) ;
  GGS_C_suppressInitialStatesOperation result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_suppressInitialStatesOperation::
reader_mOperand (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_suppressInitialStatesOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_suppressInitialStatesOperation *) mPointer)->mOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_suppressInitialStatesOperation::
operator == (const GGS_C_suppressInitialStatesOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_suppressInitialStatesOperation::
operator != (const GGS_C_suppressInitialStatesOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_suppressInitialStatesOperation::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_suppressInitialStatesOperation" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       abstract class 'cPtr_AC_job'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_job::
cPtr_AC_job (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_job * GGS_AC_job::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
      return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_AC_job::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@AC_job:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        GALGAS class 'GGS_AC_job'                          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_job::
GGS_AC_job (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_job::
GGS_AC_job (const GGS_AC_job & inOperand) {
  mPointer = (cPtr_AC_job *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_job::
~GGS_AC_job (void) {
  macroDetachPointer (mPointer, cPtr_AC_job) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_job::
operator = (const GGS_AC_job & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_job::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_job) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_AC_job::
operator == (const GGS_AC_job & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_AC_job::
operator != (const GGS_AC_job & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_job::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @AC_job" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_C_machineCheck'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_machineCheck::
cPtr_C_machineCheck (const GGS_luint & argument_0,
                                const GGS_bool& argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_job (THERE),
mMachineIndex (argument_0),
mCheckMachineIsBoolean (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_machineCheck * GGS_C_machineCheck::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineCheck *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_machineCheck *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_machineCheck::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_machineCheck * _p = dynamic_cast <const cPtr_C_machineCheck *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mMachineIndex == _p->mMachineIndex).boolValue ()
         && (mCheckMachineIsBoolean == _p->mCheckMachineIsBoolean).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_machineCheck::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_machineCheck:"
           << mMachineIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mCheckMachineIsBoolean.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_machineCheck'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_machineCheck::
GGS_C_machineCheck (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_machineCheck::
GGS_C_machineCheck (const GGS_C_machineCheck & inOperand)
:GGS_AC_job () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_machineCheck::
~GGS_C_machineCheck (void) {
  macroDetachPointer (mPointer, cPtr_C_machineCheck) ;
}

//---------------------------------------------------------------------------*

void GGS_C_machineCheck::
operator = (const GGS_C_machineCheck & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_machineCheck GGS_C_machineCheck::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_bool& argument_1 COMMA_LOCATION_ARGS) {
  cPtr_C_machineCheck * _ptr = (cPtr_C_machineCheck *) NULL ;
  macroMyNew (_ptr, cPtr_C_machineCheck (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_C_machineCheck result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_C_machineCheck::
reader_mMachineIndex (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineCheck *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineCheck *) mPointer)->mMachineIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_machineCheck::
reader_mCheckMachineIsBoolean (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineCheck *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineCheck *) mPointer)->mCheckMachineIsBoolean ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_machineCheck::
operator == (const GGS_C_machineCheck & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_machineCheck::
operator != (const GGS_C_machineCheck & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_machineCheck::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_machineCheck" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_C_machineCheckIdentical'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_machineCheckIdentical::
cPtr_C_machineCheckIdentical (const GGS_luint & argument_0,
                                const GGS_luint & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_job (THERE),
mMachineIndex1 (argument_0),
mMachineIndex2 (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_machineCheckIdentical * GGS_C_machineCheckIdentical::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineCheckIdentical *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_machineCheckIdentical *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_machineCheckIdentical::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_machineCheckIdentical * _p = dynamic_cast <const cPtr_C_machineCheckIdentical *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mMachineIndex1 == _p->mMachineIndex1).boolValue ()
         && (mMachineIndex2 == _p->mMachineIndex2).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_machineCheckIdentical::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_machineCheckIdentical:"
           << mMachineIndex1.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMachineIndex2.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_machineCheckIdentical'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_machineCheckIdentical::
GGS_C_machineCheckIdentical (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_machineCheckIdentical::
GGS_C_machineCheckIdentical (const GGS_C_machineCheckIdentical & inOperand)
:GGS_AC_job () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_machineCheckIdentical::
~GGS_C_machineCheckIdentical (void) {
  macroDetachPointer (mPointer, cPtr_C_machineCheckIdentical) ;
}

//---------------------------------------------------------------------------*

void GGS_C_machineCheckIdentical::
operator = (const GGS_C_machineCheckIdentical & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_machineCheckIdentical GGS_C_machineCheckIdentical::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_luint & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_C_machineCheckIdentical * _ptr = (cPtr_C_machineCheckIdentical *) NULL ;
  macroMyNew (_ptr, cPtr_C_machineCheckIdentical (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_C_machineCheckIdentical result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_C_machineCheckIdentical::
reader_mMachineIndex1 (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineCheckIdentical *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineCheckIdentical *) mPointer)->mMachineIndex1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_C_machineCheckIdentical::
reader_mMachineIndex2 (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineCheckIdentical *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineCheckIdentical *) mPointer)->mMachineIndex2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_machineCheckIdentical::
operator == (const GGS_C_machineCheckIdentical & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_machineCheckIdentical::
operator != (const GGS_C_machineCheckIdentical & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_machineCheckIdentical::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_machineCheckIdentical" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_C_machineComponent'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_machineComponent::
cPtr_C_machineComponent (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_uint & argument_2,
                                const GGS_uint & argument_3,
                                const GGS_M_variablesMap & argument_4,
                                const GGS_AC_machineDefinition & argument_5 COMMA_LOCATION_ARGS)
:cPtr_AC_job (THERE),
mMachineName (argument_0),
mMachineIndex (argument_1),
mInputVariableCount (argument_2),
mInputAndInternalVariableCount (argument_3),
mVariablesMap (argument_4),
mDefinition (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_machineComponent * GGS_C_machineComponent::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_machineComponent *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_machineComponent::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_machineComponent * _p = dynamic_cast <const cPtr_C_machineComponent *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mMachineName == _p->mMachineName).boolValue ()
         && (mMachineIndex == _p->mMachineIndex).boolValue ()
         && (mInputVariableCount == _p->mInputVariableCount).boolValue ()
         && (mInputAndInternalVariableCount == _p->mInputAndInternalVariableCount).boolValue ()
         && (mVariablesMap == _p->mVariablesMap).boolValue ()
         && (mDefinition == _p->mDefinition).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_machineComponent::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_machineComponent:"
           << mMachineName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMachineIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInputVariableCount.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInputAndInternalVariableCount.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mVariablesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mDefinition.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_machineComponent'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_machineComponent::
GGS_C_machineComponent (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_machineComponent::
GGS_C_machineComponent (const GGS_C_machineComponent & inOperand)
:GGS_AC_job () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_machineComponent::
~GGS_C_machineComponent (void) {
  macroDetachPointer (mPointer, cPtr_C_machineComponent) ;
}

//---------------------------------------------------------------------------*

void GGS_C_machineComponent::
operator = (const GGS_C_machineComponent & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_machineComponent GGS_C_machineComponent::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_uint & argument_2,
                 const GGS_uint & argument_3,
                 const GGS_M_variablesMap & argument_4,
                 const GGS_AC_machineDefinition & argument_5 COMMA_LOCATION_ARGS) {
  cPtr_C_machineComponent * _ptr = (cPtr_C_machineComponent *) NULL ;
  macroMyNew (_ptr, cPtr_C_machineComponent (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  GGS_C_machineComponent result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_machineComponent::
reader_mMachineName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineComponent *) mPointer)->mMachineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_C_machineComponent::
reader_mMachineIndex (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineComponent *) mPointer)->mMachineIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_machineComponent::
reader_mInputVariableCount (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineComponent *) mPointer)->mInputVariableCount ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_machineComponent::
reader_mInputAndInternalVariableCount (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineComponent *) mPointer)->mInputAndInternalVariableCount ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_variablesMap  GGS_C_machineComponent::
reader_mVariablesMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_variablesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineComponent *) mPointer)->mVariablesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_machineComponent::
reader_mDefinition (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineComponent *) mPointer)->mDefinition ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_machineComponent::
operator == (const GGS_C_machineComponent & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_machineComponent::
operator != (const GGS_C_machineComponent & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_machineComponent::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_machineComponent" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        abstract class 'cPtr_C_machineDefinedByAdditiveModalComp'          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_machineDefinedByAdditiveModalComp::
cPtr_C_machineDefinedByAdditiveModalComp (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_uint & argument_2,
                                const GGS_uint & argument_3,
                                const GGS_M_variablesMap & argument_4,
                                const GGS_M_modesMap & argument_5,
                                const GGS_ListForModes & argument_6 COMMA_LOCATION_ARGS)
:cPtr_AC_job (THERE),
mMachineName (argument_0),
mMachineIndex (argument_1),
mInputVariableCount (argument_2),
mInputAndInternalVariableCount (argument_3),
mVariablesMap (argument_4),
mModeMap (argument_5),
mInclusionList (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_machineDefinedByAdditiveModalComp * GGS_C_machineDefinedByAdditiveModalComp::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedByAdditiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_machineDefinedByAdditiveModalComp *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_machineDefinedByAdditiveModalComp::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_machineDefinedByAdditiveModalComp * _p = dynamic_cast <const cPtr_C_machineDefinedByAdditiveModalComp *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mMachineName == _p->mMachineName).boolValue ()
         && (mMachineIndex == _p->mMachineIndex).boolValue ()
         && (mInputVariableCount == _p->mInputVariableCount).boolValue ()
         && (mInputAndInternalVariableCount == _p->mInputAndInternalVariableCount).boolValue ()
         && (mVariablesMap == _p->mVariablesMap).boolValue ()
         && (mModeMap == _p->mModeMap).boolValue ()
         && (mInclusionList == _p->mInclusionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_machineDefinedByAdditiveModalComp::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_machineDefinedByAdditiveModalComp:"
           << mMachineName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMachineIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInputVariableCount.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInputAndInternalVariableCount.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mVariablesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mModeMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInclusionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_C_machineDefinedByAdditiveModalComp'           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_machineDefinedByAdditiveModalComp::
GGS_C_machineDefinedByAdditiveModalComp (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_machineDefinedByAdditiveModalComp::
GGS_C_machineDefinedByAdditiveModalComp (const GGS_C_machineDefinedByAdditiveModalComp & inOperand)
:GGS_AC_job () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_machineDefinedByAdditiveModalComp::
~GGS_C_machineDefinedByAdditiveModalComp (void) {
  macroDetachPointer (mPointer, cPtr_C_machineDefinedByAdditiveModalComp) ;
}

//---------------------------------------------------------------------------*

void GGS_C_machineDefinedByAdditiveModalComp::
operator = (const GGS_C_machineDefinedByAdditiveModalComp & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_machineDefinedByAdditiveModalComp GGS_C_machineDefinedByAdditiveModalComp::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_uint & argument_2,
                 const GGS_uint & argument_3,
                 const GGS_M_variablesMap & argument_4,
                 const GGS_M_modesMap & argument_5,
                 const GGS_ListForModes & argument_6 COMMA_LOCATION_ARGS) {
  cPtr_C_machineDefinedByAdditiveModalComp * _ptr = (cPtr_C_machineDefinedByAdditiveModalComp *) NULL ;
  macroMyNew (_ptr, cPtr_C_machineDefinedByAdditiveModalComp (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  GGS_C_machineDefinedByAdditiveModalComp result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_machineDefinedByAdditiveModalComp::
reader_mMachineName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedByAdditiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineDefinedByAdditiveModalComp *) mPointer)->mMachineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_C_machineDefinedByAdditiveModalComp::
reader_mMachineIndex (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedByAdditiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineDefinedByAdditiveModalComp *) mPointer)->mMachineIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_machineDefinedByAdditiveModalComp::
reader_mInputVariableCount (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedByAdditiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineDefinedByAdditiveModalComp *) mPointer)->mInputVariableCount ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_machineDefinedByAdditiveModalComp::
reader_mInputAndInternalVariableCount (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedByAdditiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineDefinedByAdditiveModalComp *) mPointer)->mInputAndInternalVariableCount ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_variablesMap  GGS_C_machineDefinedByAdditiveModalComp::
reader_mVariablesMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_variablesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedByAdditiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineDefinedByAdditiveModalComp *) mPointer)->mVariablesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_modesMap  GGS_C_machineDefinedByAdditiveModalComp::
reader_mModeMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_modesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedByAdditiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineDefinedByAdditiveModalComp *) mPointer)->mModeMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ListForModes  GGS_C_machineDefinedByAdditiveModalComp::
reader_mInclusionList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ListForModes   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedByAdditiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineDefinedByAdditiveModalComp *) mPointer)->mInclusionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_machineDefinedByAdditiveModalComp::
operator == (const GGS_C_machineDefinedByAdditiveModalComp & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_machineDefinedByAdditiveModalComp::
operator != (const GGS_C_machineDefinedByAdditiveModalComp & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_machineDefinedByAdditiveModalComp::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_machineDefinedByAdditiveModalComp" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      abstract class 'cPtr_C_machineDefinedBySubstractiveModalComp'        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_machineDefinedBySubstractiveModalComp::
cPtr_C_machineDefinedBySubstractiveModalComp (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_uint & argument_2,
                                const GGS_uint & argument_3,
                                const GGS_M_variablesMap & argument_4,
                                const GGS_M_modesMap & argument_5,
                                const GGS_ListForModes & argument_6 COMMA_LOCATION_ARGS)
:cPtr_AC_job (THERE),
mMachineName (argument_0),
mMachineIndex (argument_1),
mInputVariableCount (argument_2),
mInputAndInternalVariableCount (argument_3),
mVariablesMap (argument_4),
mModeMap (argument_5),
mExclusionList (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_machineDefinedBySubstractiveModalComp * GGS_C_machineDefinedBySubstractiveModalComp::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedBySubstractiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_machineDefinedBySubstractiveModalComp *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_machineDefinedBySubstractiveModalComp::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_machineDefinedBySubstractiveModalComp * _p = dynamic_cast <const cPtr_C_machineDefinedBySubstractiveModalComp *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mMachineName == _p->mMachineName).boolValue ()
         && (mMachineIndex == _p->mMachineIndex).boolValue ()
         && (mInputVariableCount == _p->mInputVariableCount).boolValue ()
         && (mInputAndInternalVariableCount == _p->mInputAndInternalVariableCount).boolValue ()
         && (mVariablesMap == _p->mVariablesMap).boolValue ()
         && (mModeMap == _p->mModeMap).boolValue ()
         && (mExclusionList == _p->mExclusionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_machineDefinedBySubstractiveModalComp::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_machineDefinedBySubstractiveModalComp:"
           << mMachineName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMachineIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInputVariableCount.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInputAndInternalVariableCount.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mVariablesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mModeMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExclusionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_C_machineDefinedBySubstractiveModalComp'         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_machineDefinedBySubstractiveModalComp::
GGS_C_machineDefinedBySubstractiveModalComp (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_machineDefinedBySubstractiveModalComp::
GGS_C_machineDefinedBySubstractiveModalComp (const GGS_C_machineDefinedBySubstractiveModalComp & inOperand)
:GGS_AC_job () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_machineDefinedBySubstractiveModalComp::
~GGS_C_machineDefinedBySubstractiveModalComp (void) {
  macroDetachPointer (mPointer, cPtr_C_machineDefinedBySubstractiveModalComp) ;
}

//---------------------------------------------------------------------------*

void GGS_C_machineDefinedBySubstractiveModalComp::
operator = (const GGS_C_machineDefinedBySubstractiveModalComp & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_machineDefinedBySubstractiveModalComp GGS_C_machineDefinedBySubstractiveModalComp::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_uint & argument_2,
                 const GGS_uint & argument_3,
                 const GGS_M_variablesMap & argument_4,
                 const GGS_M_modesMap & argument_5,
                 const GGS_ListForModes & argument_6 COMMA_LOCATION_ARGS) {
  cPtr_C_machineDefinedBySubstractiveModalComp * _ptr = (cPtr_C_machineDefinedBySubstractiveModalComp *) NULL ;
  macroMyNew (_ptr, cPtr_C_machineDefinedBySubstractiveModalComp (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  GGS_C_machineDefinedBySubstractiveModalComp result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_machineDefinedBySubstractiveModalComp::
reader_mMachineName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedBySubstractiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineDefinedBySubstractiveModalComp *) mPointer)->mMachineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_C_machineDefinedBySubstractiveModalComp::
reader_mMachineIndex (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedBySubstractiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineDefinedBySubstractiveModalComp *) mPointer)->mMachineIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_machineDefinedBySubstractiveModalComp::
reader_mInputVariableCount (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedBySubstractiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineDefinedBySubstractiveModalComp *) mPointer)->mInputVariableCount ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_machineDefinedBySubstractiveModalComp::
reader_mInputAndInternalVariableCount (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedBySubstractiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineDefinedBySubstractiveModalComp *) mPointer)->mInputAndInternalVariableCount ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_variablesMap  GGS_C_machineDefinedBySubstractiveModalComp::
reader_mVariablesMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_variablesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedBySubstractiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineDefinedBySubstractiveModalComp *) mPointer)->mVariablesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_modesMap  GGS_C_machineDefinedBySubstractiveModalComp::
reader_mModeMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_modesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedBySubstractiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineDefinedBySubstractiveModalComp *) mPointer)->mModeMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ListForModes  GGS_C_machineDefinedBySubstractiveModalComp::
reader_mExclusionList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ListForModes   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedBySubstractiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineDefinedBySubstractiveModalComp *) mPointer)->mExclusionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_machineDefinedBySubstractiveModalComp::
operator == (const GGS_C_machineDefinedBySubstractiveModalComp & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_machineDefinedBySubstractiveModalComp::
operator != (const GGS_C_machineDefinedBySubstractiveModalComp & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_machineDefinedBySubstractiveModalComp::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_machineDefinedBySubstractiveModalComp" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@L_inputConfigurationForScenario'             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_inputConfigurationForScenario::
elementOf_GGS_L_inputConfigurationForScenario (const GGS_luint & argument_0):
mInputValue (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_inputConfigurationForScenario::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_inputConfigurationForScenario * _p = dynamic_cast <const elementOf_GGS_L_inputConfigurationForScenario *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mInputValue == _p->mInputValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_inputConfigurationForScenario::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInputValue.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@L_inputConfigurationForScenario'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_inputConfigurationForScenario::GGS_L_inputConfigurationForScenario (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_inputConfigurationForScenario::
GGS_L_inputConfigurationForScenario (const GGS_L_inputConfigurationForScenario & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_inputConfigurationForScenario::
operator == (const GGS_L_inputConfigurationForScenario & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_inputConfigurationForScenario::
operator != (const GGS_L_inputConfigurationForScenario & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_inputConfigurationForScenario::
_internalAppendValues (const GGS_luint & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_inputConfigurationForScenario::
_internalPrependValues (const GGS_luint & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_inputConfigurationForScenario::
_addAssign_operation (const GGS_luint & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_inputConfigurationForScenario GGS_L_inputConfigurationForScenario::
operator + (const GGS_L_inputConfigurationForScenario & inOperand) const {
  GGS_L_inputConfigurationForScenario result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_inputConfigurationForScenario * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_luint  p_0 = p->mInputValue ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_inputConfigurationForScenario::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_luint & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_inputConfigurationForScenario::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mInputValue) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_inputConfigurationForScenario  GGS_L_inputConfigurationForScenario::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_inputConfigurationForScenario result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_inputConfigurationForScenario  GGS_L_inputConfigurationForScenario::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_luint & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_inputConfigurationForScenario result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_inputConfigurationForScenario::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_inputConfigurationForScenario", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_inputConfigurationForScenario::
method_first (C_Lexique & _inLexique,
              GGS_luint & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInputValue ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_inputConfigurationForScenario::
method_last (C_Lexique & _inLexique,
             GGS_luint & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInputValue ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_inputConfigurationForScenario::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_luint & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInputValue ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_inputConfigurationForScenario::
modifier_popLast (C_Lexique & _inLexique,
                GGS_luint & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInputValue ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@L_inputScenario'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_inputScenario::
elementOf_GGS_L_inputScenario (const GGS_L_inputConfigurationForScenario & argument_0):
mInputConfiguration (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_inputScenario::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_inputScenario * _p = dynamic_cast <const elementOf_GGS_L_inputScenario *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mInputConfiguration == _p->mInputConfiguration).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_inputScenario::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInputConfiguration.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@L_inputScenario'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_inputScenario::GGS_L_inputScenario (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_inputScenario::
GGS_L_inputScenario (const GGS_L_inputScenario & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_inputScenario::
operator == (const GGS_L_inputScenario & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_inputScenario::
operator != (const GGS_L_inputScenario & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_inputScenario::
_internalAppendValues (const GGS_L_inputConfigurationForScenario & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_inputScenario::
_internalPrependValues (const GGS_L_inputConfigurationForScenario & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_inputScenario::
_addAssign_operation (const GGS_L_inputConfigurationForScenario & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_inputScenario GGS_L_inputScenario::
operator + (const GGS_L_inputScenario & inOperand) const {
  GGS_L_inputScenario result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_inputScenario * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_L_inputConfigurationForScenario  p_0 = p->mInputConfiguration ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_inputScenario::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_L_inputConfigurationForScenario & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_inputScenario::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mInputConfiguration) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_inputScenario  GGS_L_inputScenario::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_inputScenario result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_inputScenario  GGS_L_inputScenario::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_L_inputConfigurationForScenario & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_inputScenario result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_inputScenario::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_inputScenario", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_inputScenario::
method_first (C_Lexique & _inLexique,
              GGS_L_inputConfigurationForScenario & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInputConfiguration ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_inputScenario::
method_last (C_Lexique & _inLexique,
             GGS_L_inputConfigurationForScenario & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInputConfiguration ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_inputScenario::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_L_inputConfigurationForScenario & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInputConfiguration ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_inputScenario::
modifier_popLast (C_Lexique & _inLexique,
                GGS_L_inputConfigurationForScenario & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInputConfiguration ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@L_scenarioList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_scenarioList::
elementOf_GGS_L_scenarioList (const GGS_lstring & argument_0,
                                const GGS_L_inputScenario & argument_1):
mScenarioTitle (argument_0),
mInputScenario (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_scenarioList::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_scenarioList * _p = dynamic_cast <const elementOf_GGS_L_scenarioList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mScenarioTitle == _p->mScenarioTitle).boolValue ()
         && (mInputScenario == _p->mInputScenario).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_scenarioList::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mScenarioTitle.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInputScenario.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@L_scenarioList'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_scenarioList::GGS_L_scenarioList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_scenarioList::
GGS_L_scenarioList (const GGS_L_scenarioList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_scenarioList::
operator == (const GGS_L_scenarioList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_scenarioList::
operator != (const GGS_L_scenarioList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_scenarioList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_L_inputScenario & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_scenarioList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_L_inputScenario & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_scenarioList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_L_inputScenario & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_scenarioList GGS_L_scenarioList::
operator + (const GGS_L_scenarioList & inOperand) const {
  GGS_L_scenarioList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_scenarioList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mScenarioTitle ;
          GGS_L_inputScenario  p_1 = p->mInputScenario ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_scenarioList::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_L_inputScenario & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_scenarioList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mScenarioTitle,
                                _p->mInputScenario) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_scenarioList  GGS_L_scenarioList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_scenarioList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_scenarioList  GGS_L_scenarioList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_L_inputScenario & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_scenarioList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_scenarioList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_scenarioList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_scenarioList::
method_first (C_Lexique & _inLexique,
              GGS_lstring & _out_0,
              GGS_L_inputScenario & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mScenarioTitle ;
    _out_1 = _p->mInputScenario ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_scenarioList::
method_last (C_Lexique & _inLexique,
             GGS_lstring & _out_0,
             GGS_L_inputScenario & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mScenarioTitle ;
    _out_1 = _p->mInputScenario ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_scenarioList::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_L_inputScenario & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mScenarioTitle ;
    _out_1 = _p->mInputScenario ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_scenarioList::
modifier_popLast (C_Lexique & _inLexique,
                GGS_lstring & _out_0,
                GGS_L_inputScenario & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mScenarioTitle ;
    _out_1 = _p->mInputScenario ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_C_scenarioComponent'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_scenarioComponent::
cPtr_C_scenarioComponent (const GGS_luint & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_uint & argument_2,
                                const GGS_M_variablesMap & argument_3,
                                const GGS_L_scenarioList & argument_4 COMMA_LOCATION_ARGS)
:cPtr_AC_job (THERE),
mMachineIndex (argument_0),
mInputVariableCount (argument_1),
mInputAndInternalVariableCount (argument_2),
mVariablesMap (argument_3),
mScenarioList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_scenarioComponent * GGS_C_scenarioComponent::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_scenarioComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_scenarioComponent *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_scenarioComponent::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_scenarioComponent * _p = dynamic_cast <const cPtr_C_scenarioComponent *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mMachineIndex == _p->mMachineIndex).boolValue ()
         && (mInputVariableCount == _p->mInputVariableCount).boolValue ()
         && (mInputAndInternalVariableCount == _p->mInputAndInternalVariableCount).boolValue ()
         && (mVariablesMap == _p->mVariablesMap).boolValue ()
         && (mScenarioList == _p->mScenarioList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_scenarioComponent::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_scenarioComponent:"
           << mMachineIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInputVariableCount.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInputAndInternalVariableCount.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mVariablesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mScenarioList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_scenarioComponent'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_scenarioComponent::
GGS_C_scenarioComponent (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_scenarioComponent::
GGS_C_scenarioComponent (const GGS_C_scenarioComponent & inOperand)
:GGS_AC_job () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_scenarioComponent::
~GGS_C_scenarioComponent (void) {
  macroDetachPointer (mPointer, cPtr_C_scenarioComponent) ;
}

//---------------------------------------------------------------------------*

void GGS_C_scenarioComponent::
operator = (const GGS_C_scenarioComponent & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_scenarioComponent GGS_C_scenarioComponent::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_uint & argument_1,
                 const GGS_uint & argument_2,
                 const GGS_M_variablesMap & argument_3,
                 const GGS_L_scenarioList & argument_4 COMMA_LOCATION_ARGS) {
  cPtr_C_scenarioComponent * _ptr = (cPtr_C_scenarioComponent *) NULL ;
  macroMyNew (_ptr, cPtr_C_scenarioComponent (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  GGS_C_scenarioComponent result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_C_scenarioComponent::
reader_mMachineIndex (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_scenarioComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_scenarioComponent *) mPointer)->mMachineIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_scenarioComponent::
reader_mInputVariableCount (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_scenarioComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_scenarioComponent *) mPointer)->mInputVariableCount ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_scenarioComponent::
reader_mInputAndInternalVariableCount (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_scenarioComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_scenarioComponent *) mPointer)->mInputAndInternalVariableCount ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_variablesMap  GGS_C_scenarioComponent::
reader_mVariablesMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_variablesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_scenarioComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_scenarioComponent *) mPointer)->mVariablesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_scenarioList  GGS_C_scenarioComponent::
reader_mScenarioList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_scenarioList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_scenarioComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_scenarioComponent *) mPointer)->mScenarioList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_scenarioComponent::
operator == (const GGS_C_scenarioComponent & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_scenarioComponent::
operator != (const GGS_C_scenarioComponent & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_scenarioComponent::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_scenarioComponent" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    abstract class 'cPtr_typeUse_AND'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUse_AND::
cPtr_typeUse_AND (LOCATION_ARGS)
:cPtr_AC_job (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUse_AND * GGS_typeUse_AND::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUse_AND *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeUse_AND *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeUse_AND::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeUse_AND::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeUse_AND:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeUse_AND'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeUse_AND::
GGS_typeUse_AND (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_AND::
GGS_typeUse_AND (const GGS_typeUse_AND & inOperand)
:GGS_AC_job () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_AND::
~GGS_typeUse_AND (void) {
  macroDetachPointer (mPointer, cPtr_typeUse_AND) ;
}

//---------------------------------------------------------------------------*

void GGS_typeUse_AND::
operator = (const GGS_typeUse_AND & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_AND GGS_typeUse_AND::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeUse_AND * _ptr = (cPtr_typeUse_AND *) NULL ;
  macroMyNew (_ptr, cPtr_typeUse_AND (THERE)) ;
  GGS_typeUse_AND result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeUse_AND::
operator == (const GGS_typeUse_AND & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeUse_AND::
operator != (const GGS_typeUse_AND & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeUse_AND::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeUse_AND" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    abstract class 'cPtr_typeUse_ITE'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUse_ITE::
cPtr_typeUse_ITE (LOCATION_ARGS)
:cPtr_AC_job (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUse_ITE * GGS_typeUse_ITE::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUse_ITE *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeUse_ITE *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeUse_ITE::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeUse_ITE::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeUse_ITE:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeUse_ITE'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeUse_ITE::
GGS_typeUse_ITE (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_ITE::
GGS_typeUse_ITE (const GGS_typeUse_ITE & inOperand)
:GGS_AC_job () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_ITE::
~GGS_typeUse_ITE (void) {
  macroDetachPointer (mPointer, cPtr_typeUse_ITE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeUse_ITE::
operator = (const GGS_typeUse_ITE & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_ITE GGS_typeUse_ITE::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeUse_ITE * _ptr = (cPtr_typeUse_ITE *) NULL ;
  macroMyNew (_ptr, cPtr_typeUse_ITE (THERE)) ;
  GGS_typeUse_ITE result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeUse_ITE::
operator == (const GGS_typeUse_ITE & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeUse_ITE::
operator != (const GGS_typeUse_ITE & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeUse_ITE::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeUse_ITE" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeUse_AND_ITE'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUse_AND_ITE::
cPtr_typeUse_AND_ITE (LOCATION_ARGS)
:cPtr_AC_job (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUse_AND_ITE * GGS_typeUse_AND_ITE::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUse_AND_ITE *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeUse_AND_ITE *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeUse_AND_ITE::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeUse_AND_ITE::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeUse_AND_ITE:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeUse_AND_ITE'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeUse_AND_ITE::
GGS_typeUse_AND_ITE (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_AND_ITE::
GGS_typeUse_AND_ITE (const GGS_typeUse_AND_ITE & inOperand)
:GGS_AC_job () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_AND_ITE::
~GGS_typeUse_AND_ITE (void) {
  macroDetachPointer (mPointer, cPtr_typeUse_AND_ITE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeUse_AND_ITE::
operator = (const GGS_typeUse_AND_ITE & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_AND_ITE GGS_typeUse_AND_ITE::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeUse_AND_ITE * _ptr = (cPtr_typeUse_AND_ITE *) NULL ;
  macroMyNew (_ptr, cPtr_typeUse_AND_ITE (THERE)) ;
  GGS_typeUse_AND_ITE result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeUse_AND_ITE::
operator == (const GGS_typeUse_AND_ITE & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeUse_AND_ITE::
operator != (const GGS_typeUse_AND_ITE & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeUse_AND_ITE::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeUse_AND_ITE" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeResize_AND_cache'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeResize_AND_cache::
cPtr_typeResize_AND_cache (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_job (THERE),
mNewSize (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeResize_AND_cache * GGS_typeResize_AND_cache::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeResize_AND_cache *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeResize_AND_cache *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeResize_AND_cache::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeResize_AND_cache * _p = dynamic_cast <const cPtr_typeResize_AND_cache *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mNewSize == _p->mNewSize).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeResize_AND_cache::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeResize_AND_cache:"
           << mNewSize.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeResize_AND_cache'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeResize_AND_cache::
GGS_typeResize_AND_cache (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeResize_AND_cache::
GGS_typeResize_AND_cache (const GGS_typeResize_AND_cache & inOperand)
:GGS_AC_job () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeResize_AND_cache::
~GGS_typeResize_AND_cache (void) {
  macroDetachPointer (mPointer, cPtr_typeResize_AND_cache) ;
}

//---------------------------------------------------------------------------*

void GGS_typeResize_AND_cache::
operator = (const GGS_typeResize_AND_cache & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeResize_AND_cache GGS_typeResize_AND_cache::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeResize_AND_cache * _ptr = (cPtr_typeResize_AND_cache *) NULL ;
  macroMyNew (_ptr, cPtr_typeResize_AND_cache (argument_0 COMMA_THERE)) ;
  GGS_typeResize_AND_cache result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeResize_AND_cache::
reader_mNewSize (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeResize_AND_cache *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeResize_AND_cache *) mPointer)->mNewSize ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeResize_AND_cache::
operator == (const GGS_typeResize_AND_cache & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeResize_AND_cache::
operator != (const GGS_typeResize_AND_cache & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeResize_AND_cache::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeResize_AND_cache" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeResize_ITE_cache'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeResize_ITE_cache::
cPtr_typeResize_ITE_cache (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_job (THERE),
mNewSize (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeResize_ITE_cache * GGS_typeResize_ITE_cache::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeResize_ITE_cache *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeResize_ITE_cache *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeResize_ITE_cache::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeResize_ITE_cache * _p = dynamic_cast <const cPtr_typeResize_ITE_cache *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mNewSize == _p->mNewSize).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeResize_ITE_cache::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeResize_ITE_cache:"
           << mNewSize.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeResize_ITE_cache'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeResize_ITE_cache::
GGS_typeResize_ITE_cache (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeResize_ITE_cache::
GGS_typeResize_ITE_cache (const GGS_typeResize_ITE_cache & inOperand)
:GGS_AC_job () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeResize_ITE_cache::
~GGS_typeResize_ITE_cache (void) {
  macroDetachPointer (mPointer, cPtr_typeResize_ITE_cache) ;
}

//---------------------------------------------------------------------------*

void GGS_typeResize_ITE_cache::
operator = (const GGS_typeResize_ITE_cache & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeResize_ITE_cache GGS_typeResize_ITE_cache::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeResize_ITE_cache * _ptr = (cPtr_typeResize_ITE_cache *) NULL ;
  macroMyNew (_ptr, cPtr_typeResize_ITE_cache (argument_0 COMMA_THERE)) ;
  GGS_typeResize_ITE_cache result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeResize_ITE_cache::
reader_mNewSize (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeResize_ITE_cache *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeResize_ITE_cache *) mPointer)->mNewSize ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeResize_ITE_cache::
operator == (const GGS_typeResize_ITE_cache & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeResize_ITE_cache::
operator != (const GGS_typeResize_ITE_cache & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeResize_ITE_cache::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeResize_ITE_cache" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeResizeMap'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeResizeMap::
cPtr_typeResizeMap (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_job (THERE),
mNewSize (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeResizeMap * GGS_typeResizeMap::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeResizeMap *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeResizeMap *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeResizeMap::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeResizeMap * _p = dynamic_cast <const cPtr_typeResizeMap *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mNewSize == _p->mNewSize).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeResizeMap::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeResizeMap:"
           << mNewSize.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeResizeMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeResizeMap::
GGS_typeResizeMap (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeResizeMap::
GGS_typeResizeMap (const GGS_typeResizeMap & inOperand)
:GGS_AC_job () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeResizeMap::
~GGS_typeResizeMap (void) {
  macroDetachPointer (mPointer, cPtr_typeResizeMap) ;
}

//---------------------------------------------------------------------------*

void GGS_typeResizeMap::
operator = (const GGS_typeResizeMap & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeResizeMap GGS_typeResizeMap::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeResizeMap * _ptr = (cPtr_typeResizeMap *) NULL ;
  macroMyNew (_ptr, cPtr_typeResizeMap (argument_0 COMMA_THERE)) ;
  GGS_typeResizeMap result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeResizeMap::
reader_mNewSize (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeResizeMap *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeResizeMap *) mPointer)->mNewSize ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeResizeMap::
operator == (const GGS_typeResizeMap & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeResizeMap::
operator != (const GGS_typeResizeMap & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeResizeMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeResizeMap" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeDisplayBDDstats'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDisplayBDDstats::
cPtr_typeDisplayBDDstats (LOCATION_ARGS)
:cPtr_AC_job (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDisplayBDDstats * GGS_typeDisplayBDDstats::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDisplayBDDstats *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDisplayBDDstats *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDisplayBDDstats::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDisplayBDDstats::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeDisplayBDDstats:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDisplayBDDstats'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDisplayBDDstats::
GGS_typeDisplayBDDstats (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDisplayBDDstats::
GGS_typeDisplayBDDstats (const GGS_typeDisplayBDDstats & inOperand)
:GGS_AC_job () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDisplayBDDstats::
~GGS_typeDisplayBDDstats (void) {
  macroDetachPointer (mPointer, cPtr_typeDisplayBDDstats) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDisplayBDDstats::
operator = (const GGS_typeDisplayBDDstats & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDisplayBDDstats GGS_typeDisplayBDDstats::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeDisplayBDDstats * _ptr = (cPtr_typeDisplayBDDstats *) NULL ;
  macroMyNew (_ptr, cPtr_typeDisplayBDDstats (THERE)) ;
  GGS_typeDisplayBDDstats result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDisplayBDDstats::
operator == (const GGS_typeDisplayBDDstats & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDisplayBDDstats::
operator != (const GGS_typeDisplayBDDstats & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDisplayBDDstats::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeDisplayBDDstats" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       Element of list '@L_jobList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_jobList::
elementOf_GGS_L_jobList (const GGS_AC_job & argument_0):
mComponent (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_jobList::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_jobList * _p = dynamic_cast <const elementOf_GGS_L_jobList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mComponent == _p->mComponent).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_jobList::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mComponent.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            List '@L_jobList'                              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_jobList::GGS_L_jobList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_jobList::
GGS_L_jobList (const GGS_L_jobList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_jobList::
operator == (const GGS_L_jobList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_jobList::
operator != (const GGS_L_jobList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_jobList::
_internalAppendValues (const GGS_AC_job & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_jobList::
_internalPrependValues (const GGS_AC_job & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_jobList::
_addAssign_operation (const GGS_AC_job & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_jobList GGS_L_jobList::
operator + (const GGS_L_jobList & inOperand) const {
  GGS_L_jobList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_jobList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_AC_job  p_0 = p->mComponent ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_jobList::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_AC_job & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_jobList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mComponent) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_jobList  GGS_L_jobList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_jobList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_jobList  GGS_L_jobList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_AC_job & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_jobList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_jobList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_jobList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_jobList::
method_first (C_Lexique & _inLexique,
              GGS_AC_job & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mComponent ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_jobList::
method_last (C_Lexique & _inLexique,
             GGS_AC_job & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mComponent ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_jobList::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_AC_job & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mComponent ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_jobList::
modifier_popLast (C_Lexique & _inLexique,
                GGS_AC_job & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mComponent ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'M_machinesMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_machinesMap::
elementOf_GGS_M_machinesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_machinesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_machinesMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mInputVariableCount.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mInputAndInternalVariableCount.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mVariablesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_machinesMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_machinesMap * _p = dynamic_cast <const elementOf_GGS_M_machinesMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mInputVariableCount == _p->mInfo.mInputVariableCount).boolValue ()
           && (mInfo.mInputAndInternalVariableCount == _p->mInfo.mInputAndInternalVariableCount).boolValue ()
           && (mInfo.mVariablesMap == _p->mInfo.mVariablesMap).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_machinesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_machinesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_machinesMap * info = (e_M_machinesMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_machinesMap GGS_M_machinesMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_machinesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_machinesMap::
operator == (const GGS_M_machinesMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_machinesMap::
operator != (const GGS_M_machinesMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_machinesMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_machinesMap::
_removeElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_uint & outParameter0,
                GGS_uint & outParameter1,
                GGS_M_variablesMap & outParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  AC_galgas_map_element * removedElement = NULL ;
  sint32 elementIndex = - 1 ;
  if (_isBuilt () && inKey._isBuilt ()) {
    bool unused ;
    _internalRemove (mSharedMapRoot->_mRoot, inKey, removedElement, unused) ;
    if (removedElement == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
      outParameter0._drop_operation () ;
      outParameter1._drop_operation () ;
      outParameter2._drop_operation () ;
    }else{
      element_type * _p = (element_type *) removedElement ;
      elementIndex = _p->mIndex ;
      outParameter0 = _p->mInfo.mInputVariableCount ;
      outParameter1 = _p->mInfo.mInputAndInternalVariableCount ;
      outParameter2 = _p->mInfo.mVariablesMap ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
  macroMyDelete (removedElement, element_type) ;
}

//---------------------------------------------------------------------------*

void GGS_M_machinesMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_uint & inParameter0,
                const GGS_uint & inParameter1,
                const GGS_M_variablesMap & inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inParameter2._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_machinesMap info  ;
    info.mInputVariableCount = inParameter0 ;
    info.mInputAndInternalVariableCount = inParameter1 ;
    info.mVariablesMap = inParameter2 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_machinesMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_uint   & outParameter1,
               GGS_M_variablesMap   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    outParameter2._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mInputVariableCount ;
    outParameter1 = node->mInfo.mInputAndInternalVariableCount ;
    outParameter2 = node->mInfo.mVariablesMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_machinesMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0,
                                GGS_uint   & outParameter1,
                                GGS_M_variablesMap   & outParameter2 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' machine is not defined",
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_machinesMap::
method_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_uint   & outParameter0,
                                GGS_uint   & outParameter1,
                                GGS_M_variablesMap   & outParameter2 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' machine is not defined",
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  & outIndex
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_machinesMap::
modifier_removeKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint & outParameter0,
                                GGS_uint & outParameter1,
                                GGS_M_variablesMap & outParameter2 COMMA_LOCATION_ARGS) {
  _removeElement (_inLexique,
                  "the '%K' machine is not defined",
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_machinesMap::
modifier_removeKeyGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_uint & outParameter0,
                                GGS_uint & outParameter1,
                                GGS_M_variablesMap & outParameter2 COMMA_LOCATION_ARGS) {
  _removeElement (_inLexique,
                  "the '%K' machine is not defined",
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  & outIndex
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_machinesMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0,
                                const GGS_uint & inParameter1,
                                const GGS_M_variablesMap & inParameter2 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' machine has been already declared",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_machinesMap::
modifier_insertKeyGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_uint & inParameter0,
                                const GGS_uint & inParameter1,
                                const GGS_M_variablesMap & inParameter2 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' machine has been already declared",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 & outIndex
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_machinesMap GGS_M_machinesMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_machinesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_machinesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_machinesMap GGS_M_machinesMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_machinesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_machinesMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_machinesMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

