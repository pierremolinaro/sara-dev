//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'sara_semantics.cpp'                          *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                       june 5th, 2006, at 22h55'18"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "sara_semantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  static const char gGGSsourceFile [] = "sara_parser.ggs" ;
  #define SOURCE_FILE_AT_LINE(line) , gGGSsourceFile, line
#else
  #define SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'M_variablesMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_variablesMap::
elementOf_GGS_M_variablesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_variablesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_variablesMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_variablesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_variablesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_variablesMap * info = (e_M_variablesMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_variablesMap GGS_M_variablesMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_variablesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_variablesMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_variablesMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_variablesMap info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_variablesMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_variablesMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' variable is not declared",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_variablesMap::method_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' variable is not declared",
                 inKey,
                 & outIndex
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_variablesMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' variable has been already declared",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_variablesMap GGS_M_variablesMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_variablesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_variablesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_variablesMap GGS_M_variablesMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_variablesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_variablesMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @M_variablesMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map 'M_stateMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_stateMap::
elementOf_GGS_M_stateMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_stateMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_stateMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_stateMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_stateMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_stateMap * info = (e_M_stateMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_stateMap GGS_M_stateMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_stateMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_stateMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_stateMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_stateMap info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_stateMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_stateMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' state is not declared",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_stateMap::method_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' state is not declared",
                 inKey,
                 & outIndex
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_stateMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' state has been already declared",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_stateMap::
method_defineState (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' state has been already defined",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_stateMap GGS_M_stateMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_stateMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_stateMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_stateMap GGS_M_stateMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_stateMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_stateMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @M_stateMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@L_translationVector'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_translationVector::
elementOf_GGS_L_translationVector (const GGS_luint & argument_0):
mNextItem (NULL),
mTargetSlot (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_translationVector::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mTargetSlot.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@L_translationVector'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_translationVector::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_L_translationVector::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_translationVector::GGS_L_translationVector (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_translationVector::~GGS_L_translationVector (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_L_translationVector::
GGS_L_translationVector (const GGS_L_translationVector & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector::
operator = (const GGS_L_translationVector & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_translationVector::element_type * GGS_L_translationVector::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector::
internalAppendItem (const GGS_luint & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector::
addAssign_operation (const GGS_luint & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mTargetSlot) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_translationVector  GGS_L_translationVector::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_translationVector result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_L_translationVector::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_translationVector::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @L_translationVector" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_L_translationVector::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_AC_boolExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_boolExpression::
cPtr_AC_boolExpression (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_AC_boolExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_boolExpression::
GGS_AC_boolExpression (void) {
  mPointer = (cPtr_AC_boolExpression *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression::
GGS_AC_boolExpression (const GGS_AC_boolExpression & inOperand) {
  mPointer = (cPtr_AC_boolExpression *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression::
~GGS_AC_boolExpression (void) {
  macroDetachPointer (mPointer, cPtr_AC_boolExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_boolExpression::
operator = (const GGS_AC_boolExpression & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_boolExpression::
operator = (cPtr_AC_boolExpression * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression::
GGS_AC_boolExpression (cPtr_AC_boolExpression * inSource) {
  mPointer = (cPtr_AC_boolExpression *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_boolExpression * GGS_AC_boolExpression
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_AC_boolExpression
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_boolExpression) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_boolExpression
::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @AC_boolExpression" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_importBoolMachine'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_importBoolMachine::cPtr_C_importBoolMachine (const GGS_uint & argument_0,
                                const GGS_location & argument_1,
                                const GGS_L_translationVector & argument_2 COMMA_LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE),
mIndexOfImportedMachine (argument_0),
mErrorLocation (argument_1),
mTranslationVector (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_C_importBoolMachine::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_importBoolMachine:" ;
mIndexOfImportedMachine.reader_description  (_inLexique COMMA_THERE) ;
mErrorLocation.reader_description  (_inLexique COMMA_THERE) ;
mTranslationVector.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_importBoolMachine'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_importBoolMachine * GGS_C_importBoolMachine::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_uint & argument_0,
                                const GGS_location & argument_1,
                                const GGS_L_translationVector & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_C_importBoolMachine * ptr_ = (cPtr_C_importBoolMachine *) NULL ;
    macroMyNew (ptr_, cPtr_C_importBoolMachine (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_andExpression'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_andExpression::cPtr_C_andExpression (const GGS_AC_boolExpression & argument_0,
                                const GGS_AC_boolExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_andExpression::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_andExpression:" ;
mLeftExpression.reader_description  (_inLexique COMMA_THERE) ;
mRightExpression.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_andExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_andExpression * GGS_C_andExpression::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_AC_boolExpression & argument_0,
                                const GGS_AC_boolExpression & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_C_andExpression * ptr_ = (cPtr_C_andExpression *) NULL ;
    macroMyNew (ptr_, cPtr_C_andExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'C_orExpression'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_orExpression::cPtr_C_orExpression (const GGS_AC_boolExpression & argument_0,
                                const GGS_AC_boolExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_orExpression::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_orExpression:" ;
mLeftExpression.reader_description  (_inLexique COMMA_THERE) ;
mRightExpression.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_orExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_orExpression * GGS_C_orExpression::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_AC_boolExpression & argument_0,
                                const GGS_AC_boolExpression & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_C_orExpression * ptr_ = (cPtr_C_orExpression *) NULL ;
    macroMyNew (ptr_, cPtr_C_orExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_xorExpression'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_xorExpression::cPtr_C_xorExpression (const GGS_AC_boolExpression & argument_0,
                                const GGS_AC_boolExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_xorExpression::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_xorExpression:" ;
mLeftExpression.reader_description  (_inLexique COMMA_THERE) ;
mRightExpression.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_xorExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_xorExpression * GGS_C_xorExpression::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_AC_boolExpression & argument_0,
                                const GGS_AC_boolExpression & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_C_xorExpression * ptr_ = (cPtr_C_xorExpression *) NULL ;
    macroMyNew (ptr_, cPtr_C_xorExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_impliesExpression'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_impliesExpression::cPtr_C_impliesExpression (const GGS_AC_boolExpression & argument_0,
                                const GGS_AC_boolExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_impliesExpression::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_impliesExpression:" ;
mLeftExpression.reader_description  (_inLexique COMMA_THERE) ;
mRightExpression.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_impliesExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_impliesExpression * GGS_C_impliesExpression::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_AC_boolExpression & argument_0,
                                const GGS_AC_boolExpression & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_C_impliesExpression * ptr_ = (cPtr_C_impliesExpression *) NULL ;
    macroMyNew (ptr_, cPtr_C_impliesExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'C_equalExpression'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_equalExpression::cPtr_C_equalExpression (const GGS_AC_boolExpression & argument_0,
                                const GGS_AC_boolExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_equalExpression::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_equalExpression:" ;
mLeftExpression.reader_description  (_inLexique COMMA_THERE) ;
mRightExpression.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_equalExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_equalExpression * GGS_C_equalExpression::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_AC_boolExpression & argument_0,
                                const GGS_AC_boolExpression & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_C_equalExpression * ptr_ = (cPtr_C_equalExpression *) NULL ;
    macroMyNew (ptr_, cPtr_C_equalExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_notExpression'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_notExpression::cPtr_C_notExpression (const GGS_AC_boolExpression & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_C_notExpression::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_notExpression:" ;
mExpression.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_notExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_notExpression * GGS_C_notExpression::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_AC_boolExpression & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_C_notExpression * ptr_ = (cPtr_C_notExpression *) NULL ;
    macroMyNew (ptr_, cPtr_C_notExpression (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_VariableExpression'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_VariableExpression::cPtr_C_VariableExpression (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE),
mInputVarIndex (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_C_VariableExpression::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_VariableExpression:" ;
mInputVarIndex.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_VariableExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_VariableExpression * GGS_C_VariableExpression::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_C_VariableExpression * ptr_ = (cPtr_C_VariableExpression *) NULL ;
    macroMyNew (ptr_, cPtr_C_VariableExpression (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_trueExpression'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_trueExpression::cPtr_C_trueExpression (LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_C_trueExpression::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@C_trueExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_trueExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_trueExpression * GGS_C_trueExpression::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_C_trueExpression * ptr_ = (cPtr_C_trueExpression *) NULL ;
    macroMyNew (ptr_, cPtr_C_trueExpression (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'C_falseExpression'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_falseExpression::cPtr_C_falseExpression (LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_C_falseExpression::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@C_falseExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_falseExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_falseExpression * GGS_C_falseExpression::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_C_falseExpression * ptr_ = (cPtr_C_falseExpression *) NULL ;
    macroMyNew (ptr_, cPtr_C_falseExpression (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@L_transitionDefinition'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_transitionDefinition::
elementOf_GGS_L_transitionDefinition (const GGS_AC_boolExpression & argument_0,
                                const GGS_location & argument_1,
                                const GGS_luint & argument_2):
mNextItem (NULL),
mActionExpression (argument_0),
mEndOfExpression (argument_1),
mTargetStateIndex (argument_2) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_transitionDefinition::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mActionExpression.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mEndOfExpression.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mTargetStateIndex.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@L_transitionDefinition'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_transitionDefinition::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_L_transitionDefinition::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_transitionDefinition::GGS_L_transitionDefinition (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_transitionDefinition::~GGS_L_transitionDefinition (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_L_transitionDefinition::
GGS_L_transitionDefinition (const GGS_L_transitionDefinition & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
operator = (const GGS_L_transitionDefinition & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_transitionDefinition::element_type * GGS_L_transitionDefinition::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
internalAppendItem (const GGS_AC_boolExpression & argument_0,
                    const GGS_location & argument_1,
                    const GGS_luint & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
addAssign_operation (const GGS_AC_boolExpression & argument_0,
                                const GGS_location & argument_1,
                                const GGS_luint & argument_2) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mActionExpression,
                                p->mEndOfExpression,
                                p->mTargetStateIndex) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_transitionDefinition  GGS_L_transitionDefinition::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_transitionDefinition result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_L_transitionDefinition::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_transitionDefinition::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @L_transitionDefinition" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_L_transitionDefinition::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@L_stateDefinition'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_stateDefinition::
elementOf_GGS_L_stateDefinition (const GGS_luint & argument_0,
                                const GGS_AC_boolExpression & argument_1,
                                const GGS_location & argument_2,
                                const GGS_L_transitionDefinition & argument_3):
mNextItem (NULL),
mStateIndex (argument_0),
mStateExpression (argument_1),
mEndOfStateExpression (argument_2),
mTransitionsList (argument_3) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_stateDefinition::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mStateIndex.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mStateExpression.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mEndOfStateExpression.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mTransitionsList.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@L_stateDefinition'                          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_stateDefinition::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_L_stateDefinition::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_stateDefinition::GGS_L_stateDefinition (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_stateDefinition::~GGS_L_stateDefinition (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_L_stateDefinition::
GGS_L_stateDefinition (const GGS_L_stateDefinition & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
operator = (const GGS_L_stateDefinition & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_stateDefinition::element_type * GGS_L_stateDefinition::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
internalAppendItem (const GGS_luint & argument_0,
                    const GGS_AC_boolExpression & argument_1,
                    const GGS_location & argument_2,
                    const GGS_L_transitionDefinition & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
addAssign_operation (const GGS_luint & argument_0,
                                const GGS_AC_boolExpression & argument_1,
                                const GGS_location & argument_2,
                                const GGS_L_transitionDefinition & argument_3) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mStateIndex,
                                p->mStateExpression,
                                p->mEndOfStateExpression,
                                p->mTransitionsList) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_stateDefinition  GGS_L_stateDefinition::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_stateDefinition result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_L_stateDefinition::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_stateDefinition::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @L_stateDefinition" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_L_stateDefinition::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@L_statesDefinitionList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_statesDefinitionList::
elementOf_GGS_L_statesDefinitionList (const GGS_luint & argument_0,
                                const GGS_location & argument_1):
mNextItem (NULL),
mStateIndex (argument_0),
mStateLocation (argument_1) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_statesDefinitionList::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mStateIndex.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mStateLocation.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@L_statesDefinitionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_statesDefinitionList::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_L_statesDefinitionList::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_statesDefinitionList::GGS_L_statesDefinitionList (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_statesDefinitionList::~GGS_L_statesDefinitionList (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_L_statesDefinitionList::
GGS_L_statesDefinitionList (const GGS_L_statesDefinitionList & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList::
operator = (const GGS_L_statesDefinitionList & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_statesDefinitionList::element_type * GGS_L_statesDefinitionList::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList::
internalAppendItem (const GGS_luint & argument_0,
                    const GGS_location & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList::
addAssign_operation (const GGS_luint & argument_0,
                                const GGS_location & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mStateIndex,
                                p->mStateLocation) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_statesDefinitionList  GGS_L_statesDefinitionList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_statesDefinitionList result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_L_statesDefinitionList::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_statesDefinitionList::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @L_statesDefinitionList" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_L_statesDefinitionList::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_AC_machineDefinition'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_machineDefinition::
cPtr_AC_machineDefinition (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_AC_machineDefinition'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_machineDefinition::
GGS_AC_machineDefinition (void) {
  mPointer = (cPtr_AC_machineDefinition *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition::
GGS_AC_machineDefinition (const GGS_AC_machineDefinition & inOperand) {
  mPointer = (cPtr_AC_machineDefinition *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition::
~GGS_AC_machineDefinition (void) {
  macroDetachPointer (mPointer, cPtr_AC_machineDefinition) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_machineDefinition::
operator = (const GGS_AC_machineDefinition & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_machineDefinition::
operator = (cPtr_AC_machineDefinition * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition::
GGS_AC_machineDefinition (cPtr_AC_machineDefinition * inSource) {
  mPointer = (cPtr_AC_machineDefinition *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_machineDefinition * GGS_AC_machineDefinition
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_AC_machineDefinition
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_machineDefinition) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_machineDefinition
::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @AC_machineDefinition" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map 'M_modesMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_modesMap::
elementOf_GGS_M_modesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_modesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_modesMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mModeDefinition.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_modesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_modesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_modesMap * info = (e_M_modesMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_modesMap GGS_M_modesMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_modesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_modesMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_modesMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_AC_machineDefinition &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_modesMap info  ;
    info.mModeDefinition = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_modesMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_machineDefinition   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mModeDefinition ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_modesMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_machineDefinition   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' mode is not declared",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_modesMap::method_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_machineDefinition   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' mode is not declared",
                 inKey,
                 outParameter0,
                 & outIndex
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_modesMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_machineDefinition & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' mode has been already declared",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_modesMap GGS_M_modesMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_modesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_modesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_modesMap GGS_M_modesMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_modesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_modesMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @M_modesMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@ListForModes'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ListForModes::
elementOf_GGS_ListForModes (const GGS_luint & argument_0,
                                const GGS_luint & argument_1):
mNextItem (NULL),
mSourceMode (argument_0),
mTargetMode (argument_1) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ListForModes::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mSourceMode.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mTargetMode.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           List '@ListForModes'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ListForModes::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_ListForModes::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_ListForModes::GGS_ListForModes (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_ListForModes::~GGS_ListForModes (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_ListForModes::
GGS_ListForModes (const GGS_ListForModes & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ListForModes::
operator = (const GGS_ListForModes & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ListForModes::element_type * GGS_ListForModes::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_ListForModes::
internalAppendItem (const GGS_luint & argument_0,
                    const GGS_luint & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ListForModes::
addAssign_operation (const GGS_luint & argument_0,
                                const GGS_luint & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ListForModes::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mSourceMode,
                                p->mTargetMode) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ListForModes  GGS_ListForModes::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ListForModes result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_ListForModes::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ListForModes::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @ListForModes" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_ListForModes::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_ListForModes::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'C_substractiveModalCompositionComponent'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_substractiveModalCompositionComponent::cPtr_C_substractiveModalCompositionComponent (const GGS_M_modesMap & argument_0,
                                const GGS_ListForModes & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mModeMap (argument_0),
mExclusionList (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_substractiveModalCompositionComponent::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_substractiveModalCompositionComponent:" ;
mModeMap.reader_description  (_inLexique COMMA_THERE) ;
mExclusionList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_C_substractiveModalCompositionComponent'         *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_substractiveModalCompositionComponent * GGS_C_substractiveModalCompositionComponent::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_M_modesMap & argument_0,
                                const GGS_ListForModes & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_C_substractiveModalCompositionComponent * ptr_ = (cPtr_C_substractiveModalCompositionComponent *) NULL ;
    macroMyNew (ptr_, cPtr_C_substractiveModalCompositionComponent (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'C_additiveModalCompositionComponent'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_additiveModalCompositionComponent::cPtr_C_additiveModalCompositionComponent (const GGS_M_modesMap & argument_0,
                                const GGS_ListForModes & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mModeMap (argument_0),
mInclusionList (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_additiveModalCompositionComponent::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_additiveModalCompositionComponent:" ;
mModeMap.reader_description  (_inLexique COMMA_THERE) ;
mInclusionList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_C_additiveModalCompositionComponent'           *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_additiveModalCompositionComponent * GGS_C_additiveModalCompositionComponent::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_M_modesMap & argument_0,
                                const GGS_ListForModes & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_C_additiveModalCompositionComponent * ptr_ = (cPtr_C_additiveModalCompositionComponent *) NULL ;
    macroMyNew (ptr_, cPtr_C_additiveModalCompositionComponent (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                             class 'C_trans'                               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_trans::cPtr_C_trans (const GGS_AC_boolExpression & argument_0,
                                const GGS_AC_boolExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mSourceStateExpression (argument_0),
mTargetStateExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_trans::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_trans:" ;
mSourceStateExpression.reader_description  (_inLexique COMMA_THERE) ;
mTargetStateExpression.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        GALGAS class 'GGS_C_trans'                         *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_trans * GGS_C_trans::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_AC_boolExpression & argument_0,
                                const GGS_AC_boolExpression & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_C_trans * ptr_ = (cPtr_C_trans *) NULL ;
    macroMyNew (ptr_, cPtr_C_trans (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_importMachine'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_importMachine::cPtr_C_importMachine (const GGS_uint & argument_0,
                                const GGS_L_translationVector & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mIndexOfImportedMachine (argument_0),
mTranslationVector (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_importMachine::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_importMachine:" ;
mIndexOfImportedMachine.reader_description  (_inLexique COMMA_THERE) ;
mTranslationVector.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_importMachine'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_importMachine * GGS_C_importMachine::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_uint & argument_0,
                                const GGS_L_translationVector & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_C_importMachine * ptr_ = (cPtr_C_importMachine *) NULL ;
    macroMyNew (ptr_, cPtr_C_importMachine (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'C_explicitAutomatonDefinition'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_explicitAutomatonDefinition::cPtr_C_explicitAutomatonDefinition (const GGS_M_stateMap & argument_0,
                                const GGS_L_statesDefinitionList & argument_1,
                                const GGS_L_statesDefinitionList & argument_2,
                                const GGS_L_stateDefinition & argument_3,
                                const GGS_location & argument_4 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mStatesMap (argument_0),
mInitialStatesDefinitionList (argument_1),
mTerminalStatesDefinitionList (argument_2),
mStateDefinitionList (argument_3),
mEndOfDefinition (argument_4) {
}

//---------------------------------------------------------------------------*

void cPtr_C_explicitAutomatonDefinition::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_explicitAutomatonDefinition:" ;
mStatesMap.reader_description  (_inLexique COMMA_THERE) ;
mInitialStatesDefinitionList.reader_description  (_inLexique COMMA_THERE) ;
mTerminalStatesDefinitionList.reader_description  (_inLexique COMMA_THERE) ;
mStateDefinitionList.reader_description  (_inLexique COMMA_THERE) ;
mEndOfDefinition.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_C_explicitAutomatonDefinition'              *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_explicitAutomatonDefinition * GGS_C_explicitAutomatonDefinition::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_M_stateMap & argument_0,
                                const GGS_L_statesDefinitionList & argument_1,
                                const GGS_L_statesDefinitionList & argument_2,
                                const GGS_L_stateDefinition & argument_3,
                                const GGS_location & argument_4 COMMA_LOCATION_ARGS) {
    cPtr_C_explicitAutomatonDefinition * ptr_ = (cPtr_C_explicitAutomatonDefinition *) NULL ;
    macroMyNew (ptr_, cPtr_C_explicitAutomatonDefinition (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'C_boolToSeqExpression'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_boolToSeqExpression::cPtr_C_boolToSeqExpression (const GGS_AC_boolExpression & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_C_boolToSeqExpression::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_boolToSeqExpression:" ;
mExpression.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_boolToSeqExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_boolToSeqExpression * GGS_C_boolToSeqExpression::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_AC_boolExpression & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_C_boolToSeqExpression * ptr_ = (cPtr_C_boolToSeqExpression *) NULL ;
    macroMyNew (ptr_, cPtr_C_boolToSeqExpression (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'C_existsDefinition'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_existsDefinition::cPtr_C_existsDefinition (const GGS_uint & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_AC_machineDefinition & argument_2 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mPreviousVariableCount (argument_0),
mTotalVariableCount (argument_1),
mOperand (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_C_existsDefinition::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_existsDefinition:" ;
mPreviousVariableCount.reader_description  (_inLexique COMMA_THERE) ;
mTotalVariableCount.reader_description  (_inLexique COMMA_THERE) ;
mOperand.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_existsDefinition'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_existsDefinition * GGS_C_existsDefinition::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_uint & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_AC_machineDefinition & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_C_existsDefinition * ptr_ = (cPtr_C_existsDefinition *) NULL ;
    macroMyNew (ptr_, cPtr_C_existsDefinition (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'C_forallDefinition'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_forallDefinition::cPtr_C_forallDefinition (const GGS_uint & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_AC_machineDefinition & argument_2 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mPreviousVariableCount (argument_0),
mTotalVariableCount (argument_1),
mOperand (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_C_forallDefinition::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_forallDefinition:" ;
mPreviousVariableCount.reader_description  (_inLexique COMMA_THERE) ;
mTotalVariableCount.reader_description  (_inLexique COMMA_THERE) ;
mOperand.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_forallDefinition'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_forallDefinition * GGS_C_forallDefinition::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_uint & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_AC_machineDefinition & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_C_forallDefinition * ptr_ = (cPtr_C_forallDefinition *) NULL ;
    macroMyNew (ptr_, cPtr_C_forallDefinition (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'C_parallelComposition'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_parallelComposition::cPtr_C_parallelComposition (const GGS_AC_machineDefinition & argument_0,
                                const GGS_AC_machineDefinition & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mLeftOperand (argument_0),
mRightOperand (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_parallelComposition::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_parallelComposition:" ;
mLeftOperand.reader_description  (_inLexique COMMA_THERE) ;
mRightOperand.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_parallelComposition'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_parallelComposition * GGS_C_parallelComposition::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_AC_machineDefinition & argument_0,
                                const GGS_AC_machineDefinition & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_C_parallelComposition * ptr_ = (cPtr_C_parallelComposition *) NULL ;
    macroMyNew (ptr_, cPtr_C_parallelComposition (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_orComposition'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_orComposition::cPtr_C_orComposition (const GGS_AC_machineDefinition & argument_0,
                                const GGS_AC_machineDefinition & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mLeftOperand (argument_0),
mRightOperand (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_orComposition::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_orComposition:" ;
mLeftOperand.reader_description  (_inLexique COMMA_THERE) ;
mRightOperand.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_orComposition'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_orComposition * GGS_C_orComposition::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_AC_machineDefinition & argument_0,
                                const GGS_AC_machineDefinition & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_C_orComposition * ptr_ = (cPtr_C_orComposition *) NULL ;
    macroMyNew (ptr_, cPtr_C_orComposition (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'C_strongModalComposition'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_strongModalComposition::cPtr_C_strongModalComposition (const GGS_AC_machineDefinition & argument_0,
                                const GGS_location & argument_1,
                                const GGS_AC_machineDefinition & argument_2 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mLeftOperand (argument_0),
mErrorLocation (argument_1),
mRightOperand (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_C_strongModalComposition::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_strongModalComposition:" ;
mLeftOperand.reader_description  (_inLexique COMMA_THERE) ;
mErrorLocation.reader_description  (_inLexique COMMA_THERE) ;
mRightOperand.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_C_strongModalComposition'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_strongModalComposition * GGS_C_strongModalComposition::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_AC_machineDefinition & argument_0,
                                const GGS_location & argument_1,
                                const GGS_AC_machineDefinition & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_C_strongModalComposition * ptr_ = (cPtr_C_strongModalComposition *) NULL ;
    macroMyNew (ptr_, cPtr_C_strongModalComposition (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'C_weakModalComposition'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_weakModalComposition::cPtr_C_weakModalComposition (const GGS_AC_machineDefinition & argument_0,
                                const GGS_location & argument_1,
                                const GGS_AC_machineDefinition & argument_2 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mLeftOperand (argument_0),
mErrorLocation (argument_1),
mRightOperand (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_C_weakModalComposition::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_weakModalComposition:" ;
mLeftOperand.reader_description  (_inLexique COMMA_THERE) ;
mErrorLocation.reader_description  (_inLexique COMMA_THERE) ;
mRightOperand.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_weakModalComposition'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_weakModalComposition * GGS_C_weakModalComposition::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_AC_machineDefinition & argument_0,
                                const GGS_location & argument_1,
                                const GGS_AC_machineDefinition & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_C_weakModalComposition * ptr_ = (cPtr_C_weakModalComposition *) NULL ;
    macroMyNew (ptr_, cPtr_C_weakModalComposition (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'C_fullSaturationOperation'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_fullSaturationOperation::cPtr_C_fullSaturationOperation (const GGS_AC_machineDefinition & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mOperand (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_C_fullSaturationOperation::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_fullSaturationOperation:" ;
mOperand.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_C_fullSaturationOperation'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_fullSaturationOperation * GGS_C_fullSaturationOperation::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_AC_machineDefinition & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_C_fullSaturationOperation * ptr_ = (cPtr_C_fullSaturationOperation *) NULL ;
    macroMyNew (ptr_, cPtr_C_fullSaturationOperation (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'C_complementationOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_complementationOperation::cPtr_C_complementationOperation (const GGS_AC_machineDefinition & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mOperand (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_C_complementationOperation::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_complementationOperation:" ;
mOperand.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_C_complementationOperation'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_complementationOperation * GGS_C_complementationOperation::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_AC_machineDefinition & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_C_complementationOperation * ptr_ = (cPtr_C_complementationOperation *) NULL ;
    macroMyNew (ptr_, cPtr_C_complementationOperation (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'C_suppressTerminalStatesOperation'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_suppressTerminalStatesOperation::cPtr_C_suppressTerminalStatesOperation (const GGS_AC_machineDefinition & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mOperand (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_C_suppressTerminalStatesOperation::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_suppressTerminalStatesOperation:" ;
mOperand.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_C_suppressTerminalStatesOperation'            *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_suppressTerminalStatesOperation * GGS_C_suppressTerminalStatesOperation::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_AC_machineDefinition & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_C_suppressTerminalStatesOperation * ptr_ = (cPtr_C_suppressTerminalStatesOperation *) NULL ;
    macroMyNew (ptr_, cPtr_C_suppressTerminalStatesOperation (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'C_suppressInitialStatesOperation'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_suppressInitialStatesOperation::cPtr_C_suppressInitialStatesOperation (const GGS_AC_machineDefinition & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mOperand (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_C_suppressInitialStatesOperation::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_suppressInitialStatesOperation:" ;
mOperand.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_C_suppressInitialStatesOperation'             *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_suppressInitialStatesOperation * GGS_C_suppressInitialStatesOperation::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_AC_machineDefinition & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_C_suppressInitialStatesOperation * ptr_ = (cPtr_C_suppressInitialStatesOperation *) NULL ;
    macroMyNew (ptr_, cPtr_C_suppressInitialStatesOperation (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       abstract class 'cPtr_AC_job'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_job::
cPtr_AC_job (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        GALGAS class 'GGS_AC_job'                          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_job::
GGS_AC_job (void) {
  mPointer = (cPtr_AC_job *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_job::
GGS_AC_job (const GGS_AC_job & inOperand) {
  mPointer = (cPtr_AC_job *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_job::
~GGS_AC_job (void) {
  macroDetachPointer (mPointer, cPtr_AC_job) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_job::
operator = (const GGS_AC_job & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_job::
operator = (cPtr_AC_job * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_AC_job::
GGS_AC_job (cPtr_AC_job * inSource) {
  mPointer = (cPtr_AC_job *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_job * GGS_AC_job
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_AC_job
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_job) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_AC_job
::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @AC_job" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'C_machineCheck'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_machineCheck::cPtr_C_machineCheck (const GGS_luint & argument_0,
                                const GGS_bool& argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_job (THERE),
mMachineIndex (argument_0),
mCheckMachineIsBoolean (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_machineCheck::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_machineCheck:" ;
mMachineIndex.reader_description  (_inLexique COMMA_THERE) ;
mCheckMachineIsBoolean.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_machineCheck'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_machineCheck * GGS_C_machineCheck::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_luint & argument_0,
                                const GGS_bool& argument_1 COMMA_LOCATION_ARGS) {
    cPtr_C_machineCheck * ptr_ = (cPtr_C_machineCheck *) NULL ;
    macroMyNew (ptr_, cPtr_C_machineCheck (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'C_machineCheckIdentical'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_machineCheckIdentical::cPtr_C_machineCheckIdentical (const GGS_luint & argument_0,
                                const GGS_luint & argument_1 COMMA_LOCATION_ARGS)
:cPtr_AC_job (THERE),
mMachineIndex1 (argument_0),
mMachineIndex2 (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_machineCheckIdentical::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_machineCheckIdentical:" ;
mMachineIndex1.reader_description  (_inLexique COMMA_THERE) ;
mMachineIndex2.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_machineCheckIdentical'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_machineCheckIdentical * GGS_C_machineCheckIdentical::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_luint & argument_0,
                                const GGS_luint & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_C_machineCheckIdentical * ptr_ = (cPtr_C_machineCheckIdentical *) NULL ;
    macroMyNew (ptr_, cPtr_C_machineCheckIdentical (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'C_machineComponent'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_machineComponent::cPtr_C_machineComponent (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_uint & argument_2,
                                const GGS_uint & argument_3,
                                const GGS_M_variablesMap & argument_4,
                                const GGS_AC_machineDefinition & argument_5 COMMA_LOCATION_ARGS)
:cPtr_AC_job (THERE),
mMachineName (argument_0),
mMachineIndex (argument_1),
mInputVariableCount (argument_2),
mInputAndInternalVariableCount (argument_3),
mVariablesMap (argument_4),
mDefinition (argument_5) {
}

//---------------------------------------------------------------------------*

void cPtr_C_machineComponent::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_machineComponent:" ;
mMachineName.reader_description  (_inLexique COMMA_THERE) ;
mMachineIndex.reader_description  (_inLexique COMMA_THERE) ;
mInputVariableCount.reader_description  (_inLexique COMMA_THERE) ;
mInputAndInternalVariableCount.reader_description  (_inLexique COMMA_THERE) ;
mVariablesMap.reader_description  (_inLexique COMMA_THERE) ;
mDefinition.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_machineComponent'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_machineComponent * GGS_C_machineComponent::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_uint & argument_2,
                                const GGS_uint & argument_3,
                                const GGS_M_variablesMap & argument_4,
                                const GGS_AC_machineDefinition & argument_5 COMMA_LOCATION_ARGS) {
    cPtr_C_machineComponent * ptr_ = (cPtr_C_machineComponent *) NULL ;
    macroMyNew (ptr_, cPtr_C_machineComponent (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'C_machineDefinedByAdditiveModalComp'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_machineDefinedByAdditiveModalComp::cPtr_C_machineDefinedByAdditiveModalComp (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_uint & argument_2,
                                const GGS_uint & argument_3,
                                const GGS_M_variablesMap & argument_4,
                                const GGS_M_modesMap & argument_5,
                                const GGS_ListForModes & argument_6 COMMA_LOCATION_ARGS)
:cPtr_AC_job (THERE),
mMachineName (argument_0),
mMachineIndex (argument_1),
mInputVariableCount (argument_2),
mInputAndInternalVariableCount (argument_3),
mVariablesMap (argument_4),
mModeMap (argument_5),
mInclusionList (argument_6) {
}

//---------------------------------------------------------------------------*

void cPtr_C_machineDefinedByAdditiveModalComp::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_machineDefinedByAdditiveModalComp:" ;
mMachineName.reader_description  (_inLexique COMMA_THERE) ;
mMachineIndex.reader_description  (_inLexique COMMA_THERE) ;
mInputVariableCount.reader_description  (_inLexique COMMA_THERE) ;
mInputAndInternalVariableCount.reader_description  (_inLexique COMMA_THERE) ;
mVariablesMap.reader_description  (_inLexique COMMA_THERE) ;
mModeMap.reader_description  (_inLexique COMMA_THERE) ;
mInclusionList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_C_machineDefinedByAdditiveModalComp'           *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_machineDefinedByAdditiveModalComp * GGS_C_machineDefinedByAdditiveModalComp::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_uint & argument_2,
                                const GGS_uint & argument_3,
                                const GGS_M_variablesMap & argument_4,
                                const GGS_M_modesMap & argument_5,
                                const GGS_ListForModes & argument_6 COMMA_LOCATION_ARGS) {
    cPtr_C_machineDefinedByAdditiveModalComp * ptr_ = (cPtr_C_machineDefinedByAdditiveModalComp *) NULL ;
    macroMyNew (ptr_, cPtr_C_machineDefinedByAdditiveModalComp (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'C_machineDefinedBySubstractiveModalComp'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_machineDefinedBySubstractiveModalComp::cPtr_C_machineDefinedBySubstractiveModalComp (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_uint & argument_2,
                                const GGS_uint & argument_3,
                                const GGS_M_variablesMap & argument_4,
                                const GGS_M_modesMap & argument_5,
                                const GGS_ListForModes & argument_6 COMMA_LOCATION_ARGS)
:cPtr_AC_job (THERE),
mMachineName (argument_0),
mMachineIndex (argument_1),
mInputVariableCount (argument_2),
mInputAndInternalVariableCount (argument_3),
mVariablesMap (argument_4),
mModeMap (argument_5),
mExclusionList (argument_6) {
}

//---------------------------------------------------------------------------*

void cPtr_C_machineDefinedBySubstractiveModalComp::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_machineDefinedBySubstractiveModalComp:" ;
mMachineName.reader_description  (_inLexique COMMA_THERE) ;
mMachineIndex.reader_description  (_inLexique COMMA_THERE) ;
mInputVariableCount.reader_description  (_inLexique COMMA_THERE) ;
mInputAndInternalVariableCount.reader_description  (_inLexique COMMA_THERE) ;
mVariablesMap.reader_description  (_inLexique COMMA_THERE) ;
mModeMap.reader_description  (_inLexique COMMA_THERE) ;
mExclusionList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_C_machineDefinedBySubstractiveModalComp'         *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_machineDefinedBySubstractiveModalComp * GGS_C_machineDefinedBySubstractiveModalComp::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_uint & argument_2,
                                const GGS_uint & argument_3,
                                const GGS_M_variablesMap & argument_4,
                                const GGS_M_modesMap & argument_5,
                                const GGS_ListForModes & argument_6 COMMA_LOCATION_ARGS) {
    cPtr_C_machineDefinedBySubstractiveModalComp * ptr_ = (cPtr_C_machineDefinedBySubstractiveModalComp *) NULL ;
    macroMyNew (ptr_, cPtr_C_machineDefinedBySubstractiveModalComp (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@L_inputConfigurationForScenario'             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_inputConfigurationForScenario::
elementOf_GGS_L_inputConfigurationForScenario (const GGS_luint & argument_0):
mNextItem (NULL),
mInputValue (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_inputConfigurationForScenario::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mInputValue.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@L_inputConfigurationForScenario'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_inputConfigurationForScenario::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_L_inputConfigurationForScenario::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_inputConfigurationForScenario::GGS_L_inputConfigurationForScenario (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_inputConfigurationForScenario::~GGS_L_inputConfigurationForScenario (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_L_inputConfigurationForScenario::
GGS_L_inputConfigurationForScenario (const GGS_L_inputConfigurationForScenario & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_inputConfigurationForScenario::
operator = (const GGS_L_inputConfigurationForScenario & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_inputConfigurationForScenario::element_type * GGS_L_inputConfigurationForScenario::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_L_inputConfigurationForScenario::
internalAppendItem (const GGS_luint & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_inputConfigurationForScenario::
addAssign_operation (const GGS_luint & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_inputConfigurationForScenario::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mInputValue) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_inputConfigurationForScenario  GGS_L_inputConfigurationForScenario::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_inputConfigurationForScenario result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_L_inputConfigurationForScenario::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_inputConfigurationForScenario::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @L_inputConfigurationForScenario" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_L_inputConfigurationForScenario::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_L_inputConfigurationForScenario::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@L_inputScenario'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_inputScenario::
elementOf_GGS_L_inputScenario (const GGS_L_inputConfigurationForScenario & argument_0):
mNextItem (NULL),
mInputConfiguration (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_inputScenario::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mInputConfiguration.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@L_inputScenario'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_inputScenario::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_L_inputScenario::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_inputScenario::GGS_L_inputScenario (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_inputScenario::~GGS_L_inputScenario (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_L_inputScenario::
GGS_L_inputScenario (const GGS_L_inputScenario & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_inputScenario::
operator = (const GGS_L_inputScenario & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_inputScenario::element_type * GGS_L_inputScenario::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_L_inputScenario::
internalAppendItem (const GGS_L_inputConfigurationForScenario & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_inputScenario::
addAssign_operation (const GGS_L_inputConfigurationForScenario & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_inputScenario::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mInputConfiguration) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_inputScenario  GGS_L_inputScenario::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_inputScenario result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_L_inputScenario::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_inputScenario::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @L_inputScenario" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_L_inputScenario::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_L_inputScenario::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@L_scenarioList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_scenarioList::
elementOf_GGS_L_scenarioList (const GGS_lstring & argument_0,
                                const GGS_L_inputScenario & argument_1):
mNextItem (NULL),
mScenarioTitle (argument_0),
mInputScenario (argument_1) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_scenarioList::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mScenarioTitle.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInputScenario.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@L_scenarioList'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_scenarioList::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_L_scenarioList::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_scenarioList::GGS_L_scenarioList (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_scenarioList::~GGS_L_scenarioList (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_L_scenarioList::
GGS_L_scenarioList (const GGS_L_scenarioList & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_scenarioList::
operator = (const GGS_L_scenarioList & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_scenarioList::element_type * GGS_L_scenarioList::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_L_scenarioList::
internalAppendItem (const GGS_lstring & argument_0,
                    const GGS_L_inputScenario & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_scenarioList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_L_inputScenario & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_scenarioList::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mScenarioTitle,
                                p->mInputScenario) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_scenarioList  GGS_L_scenarioList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_scenarioList result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_L_scenarioList::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_scenarioList::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @L_scenarioList" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_L_scenarioList::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_L_scenarioList::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_scenarioComponent'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_scenarioComponent::cPtr_C_scenarioComponent (const GGS_luint & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_uint & argument_2,
                                const GGS_M_variablesMap & argument_3,
                                const GGS_L_scenarioList & argument_4 COMMA_LOCATION_ARGS)
:cPtr_AC_job (THERE),
mMachineIndex (argument_0),
mInputVariableCount (argument_1),
mInputAndInternalVariableCount (argument_2),
mVariablesMap (argument_3),
mScenarioList (argument_4) {
}

//---------------------------------------------------------------------------*

void cPtr_C_scenarioComponent::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_scenarioComponent:" ;
mMachineIndex.reader_description  (_inLexique COMMA_THERE) ;
mInputVariableCount.reader_description  (_inLexique COMMA_THERE) ;
mInputAndInternalVariableCount.reader_description  (_inLexique COMMA_THERE) ;
mVariablesMap.reader_description  (_inLexique COMMA_THERE) ;
mScenarioList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_scenarioComponent'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_scenarioComponent * GGS_C_scenarioComponent::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_luint & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_uint & argument_2,
                                const GGS_M_variablesMap & argument_3,
                                const GGS_L_scenarioList & argument_4 COMMA_LOCATION_ARGS) {
    cPtr_C_scenarioComponent * ptr_ = (cPtr_C_scenarioComponent *) NULL ;
    macroMyNew (ptr_, cPtr_C_scenarioComponent (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeUse_AND'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUse_AND::cPtr_typeUse_AND (LOCATION_ARGS)
:cPtr_AC_job (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeUse_AND::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeUse_AND:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeUse_AND'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUse_AND * GGS_typeUse_AND::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeUse_AND * ptr_ = (cPtr_typeUse_AND *) NULL ;
    macroMyNew (ptr_, cPtr_typeUse_AND (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeUse_ITE'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUse_ITE::cPtr_typeUse_ITE (LOCATION_ARGS)
:cPtr_AC_job (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeUse_ITE::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeUse_ITE:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeUse_ITE'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUse_ITE * GGS_typeUse_ITE::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeUse_ITE * ptr_ = (cPtr_typeUse_ITE *) NULL ;
    macroMyNew (ptr_, cPtr_typeUse_ITE (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeUse_AND_ITE'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUse_AND_ITE::cPtr_typeUse_AND_ITE (LOCATION_ARGS)
:cPtr_AC_job (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeUse_AND_ITE::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeUse_AND_ITE:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeUse_AND_ITE'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUse_AND_ITE * GGS_typeUse_AND_ITE::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeUse_AND_ITE * ptr_ = (cPtr_typeUse_AND_ITE *) NULL ;
    macroMyNew (ptr_, cPtr_typeUse_AND_ITE (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeResize_AND_cache'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeResize_AND_cache::cPtr_typeResize_AND_cache (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_job (THERE),
mNewSize (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeResize_AND_cache::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeResize_AND_cache:" ;
mNewSize.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeResize_AND_cache'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeResize_AND_cache * GGS_typeResize_AND_cache::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeResize_AND_cache * ptr_ = (cPtr_typeResize_AND_cache *) NULL ;
    macroMyNew (ptr_, cPtr_typeResize_AND_cache (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeResize_ITE_cache'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeResize_ITE_cache::cPtr_typeResize_ITE_cache (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_job (THERE),
mNewSize (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeResize_ITE_cache::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeResize_ITE_cache:" ;
mNewSize.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeResize_ITE_cache'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeResize_ITE_cache * GGS_typeResize_ITE_cache::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeResize_ITE_cache * ptr_ = (cPtr_typeResize_ITE_cache *) NULL ;
    macroMyNew (ptr_, cPtr_typeResize_ITE_cache (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeResizeMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeResizeMap::cPtr_typeResizeMap (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_job (THERE),
mNewSize (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeResizeMap::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeResizeMap:" ;
mNewSize.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeResizeMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeResizeMap * GGS_typeResizeMap::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeResizeMap * ptr_ = (cPtr_typeResizeMap *) NULL ;
    macroMyNew (ptr_, cPtr_typeResizeMap (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeDisplayBDDstats'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDisplayBDDstats::cPtr_typeDisplayBDDstats (LOCATION_ARGS)
:cPtr_AC_job (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDisplayBDDstats::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeDisplayBDDstats:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDisplayBDDstats'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDisplayBDDstats * GGS_typeDisplayBDDstats::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeDisplayBDDstats * ptr_ = (cPtr_typeDisplayBDDstats *) NULL ;
    macroMyNew (ptr_, cPtr_typeDisplayBDDstats (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       Element of list '@L_jobList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_jobList::
elementOf_GGS_L_jobList (const GGS_AC_job & argument_0):
mNextItem (NULL),
mComponent (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_jobList::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mComponent.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            List '@L_jobList'                              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_jobList::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_L_jobList::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_jobList::GGS_L_jobList (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_jobList::~GGS_L_jobList (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_L_jobList::
GGS_L_jobList (const GGS_L_jobList & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_jobList::
operator = (const GGS_L_jobList & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_jobList::element_type * GGS_L_jobList::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_L_jobList::
internalAppendItem (const GGS_AC_job & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_jobList::
addAssign_operation (const GGS_AC_job & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_jobList::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mComponent) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_jobList  GGS_L_jobList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_jobList result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_L_jobList::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_jobList::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @L_jobList" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_L_jobList::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_L_jobList::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'M_machinesMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_machinesMap::
elementOf_GGS_M_machinesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_machinesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_machinesMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mInputVariableCount.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mInputAndInternalVariableCount.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mVariablesMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_machinesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_machinesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_machinesMap * info = (e_M_machinesMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_machinesMap GGS_M_machinesMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_machinesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_machinesMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_machinesMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_uint &  inParameter0,
               const GGS_uint &  inParameter1,
               const GGS_M_variablesMap &  inParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_machinesMap info  ;
    info.mInputVariableCount = inParameter0 ;
    info.mInputAndInternalVariableCount = inParameter1 ;
    info.mVariablesMap = inParameter2 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_machinesMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_uint   & outParameter1,
               GGS_M_variablesMap   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mInputVariableCount ;
    outParameter1 = node->mInfo.mInputAndInternalVariableCount ;
    outParameter2 = node->mInfo.mVariablesMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_machinesMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0,
                                GGS_uint   & outParameter1,
                                GGS_M_variablesMap   & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' machine is not defined",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_machinesMap::method_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_uint   & outParameter0,
                                GGS_uint   & outParameter1,
                                GGS_M_variablesMap   & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' machine is not defined",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 & outIndex
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_machinesMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0,
                                const GGS_uint & inParameter1,
                                const GGS_M_variablesMap & inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' machine has been already declared",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_machinesMap::
method_insertKeyGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_uint & inParameter0,
                                const GGS_uint & inParameter1,
                                const GGS_M_variablesMap & inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' machine has been already declared",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 & outIndex
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_machinesMap GGS_M_machinesMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_machinesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_machinesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_machinesMap GGS_M_machinesMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_machinesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_machinesMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @M_machinesMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

