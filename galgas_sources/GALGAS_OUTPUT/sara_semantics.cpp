//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'sara_semantics.cpp'                          *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                     january 17th, 2010, at 19h29'6"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "sara_semantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "sara_semantics.ggs", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_M_variablesMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_variablesMap::e_M_variablesMap (void) :
mIndex () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@M_variablesMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_M_variablesMap ("M_variablesMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_M_variablesMap::
elementOf_GGS_M_variablesMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_M_variablesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_variablesMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_variablesMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_variablesMap * ptr = dynamic_cast <const elementOf_GGS_M_variablesMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mIndex.operator_isEqual (ptr->mInfo.mIndex)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_variablesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_variablesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_variablesMap * info = (e_M_variablesMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_variablesMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_variablesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_variablesMap * info = (e_M_variablesMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_variablesMap GGS_M_variablesMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_variablesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_variablesMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_variablesMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_variablesMap::
operator_isEqual (const GGS_M_variablesMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_variablesMap::
operator_isNotEqual (const GGS_M_variablesMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_variablesMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_variablesMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_uint & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_variablesMap info  ;
    info.mIndex = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_variablesMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mIndex ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_variablesMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_variablesMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_variablesMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_variablesMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_variablesMap GGS_M_variablesMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_variablesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_variablesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_variablesMap GGS_M_variablesMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_variablesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_variablesMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @M_variablesMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    PMSInt32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (elementID, s, inIndentation) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_M_variablesMap::cEnumerator::_mIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mIndex ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_M_variablesMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_M_variablesMap * p = NULL ;
    macroMyNew (p, GGS_M_variablesMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_variablesMap GGS_M_variablesMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_M_variablesMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_M_variablesMap * p = dynamic_cast <const GGS_M_variablesMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_M_variablesMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_M_variablesMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_M_variablesMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_M_stateMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_stateMap::e_M_stateMap (void) :
mIndex () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@M_stateMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_M_stateMap ("M_stateMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_M_stateMap::
elementOf_GGS_M_stateMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_M_stateMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_stateMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_stateMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_stateMap * ptr = dynamic_cast <const elementOf_GGS_M_stateMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mIndex.operator_isEqual (ptr->mInfo.mIndex)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_stateMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_stateMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_stateMap * info = (e_M_stateMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_stateMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_stateMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_stateMap * info = (e_M_stateMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_stateMap GGS_M_stateMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_stateMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_stateMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_stateMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_stateMap::
operator_isEqual (const GGS_M_stateMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_stateMap::
operator_isNotEqual (const GGS_M_stateMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_stateMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_stateMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_uint & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_stateMap info  ;
    info.mIndex = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_stateMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mIndex ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_stateMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_stateMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_stateMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_M_stateMap::kInsertMessage_defineState [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_stateMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_stateMap::
modifier_defineState (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_defineState,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_stateMap GGS_M_stateMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_stateMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_stateMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_stateMap GGS_M_stateMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_stateMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_stateMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @M_stateMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    PMSInt32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (elementID, s, inIndentation) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_M_stateMap::cEnumerator::_mIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mIndex ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_M_stateMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_M_stateMap * p = NULL ;
    macroMyNew (p, GGS_M_stateMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_stateMap GGS_M_stateMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_M_stateMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_M_stateMap * p = dynamic_cast <const GGS_M_stateMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_M_stateMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_M_stateMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_M_stateMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@L_translationVector'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_translationVector::
elementOf_GGS_L_translationVector (const GGS_uint & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mTargetSlot (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_translationVector::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_translationVector * ptr = dynamic_cast <const elementOf_GGS_L_translationVector *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTargetSlot.operator_isEqual (ptr->mTargetSlot).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_translationVector::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTargetSlot.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@L_translationVector'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_L_translationVector ("L_translationVector", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_L_translationVector::
internalAppendValues (const GGS_uint & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector::
internalPrependValues (const GGS_uint & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector::
addAssign_operation (const GGS_uint & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_translationVector GGS_L_translationVector::
operator_concat (const GGS_L_translationVector & inOperand) const {
  GGS_L_translationVector result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector::
dotAssign_operation (const GGS_L_translationVector inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_L_translationVector * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_uint  p_0 = p->mTargetSlot ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_uint & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mTargetSlot
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_translationVector  GGS_L_translationVector::
constructor_emptyList (void) {
  GGS_L_translationVector result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_translationVector  GGS_L_translationVector::
constructor_listWithValue (const GGS_uint & argument_0) {
  GGS_L_translationVector result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector::
internalSubListWithRange (GGS_L_translationVector & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mTargetSlot) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_translationVector GGS_L_translationVector::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_translationVector result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_translationVector GGS_L_translationVector::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_translationVector result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_translationVector::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@L_translationVector", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector::
method_first (C_Compiler & inLexique,
              GGS_uint & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mTargetSlot ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector::
method_last (C_Compiler & inLexique,
             GGS_uint & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mTargetSlot ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_uint & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mTargetSlot ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector::
modifier_popLast (C_Compiler & inLexique,
                GGS_uint & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mTargetSlot ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_L_translationVector::
reader_mTargetSlotAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_uint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTargetSlot ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector::
modifier_setMTargetSlotAtIndex (C_Compiler & inLexique,
                              const GGS_uint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTargetSlot = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_L_translationVector::cEnumerator::_mTargetSlot (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTargetSlot ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_L_translationVector::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_L_translationVector * p = NULL ;
    macroMyNew (p, GGS_L_translationVector (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_translationVector GGS_L_translationVector::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_L_translationVector result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_L_translationVector * p = dynamic_cast <const GGS_L_translationVector *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_L_translationVector, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_L_translationVector::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_L_translationVector ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_AC_boolExpression'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_boolExpression::
cPtr_AC_boolExpression (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_boolExpression * GGS_AC_boolExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_AC_boolExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_AC_boolExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_AC_boolExpression::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@AC_boolExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_AC_boolExpression::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_boolExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_AC_boolExpression (& typeid (cPtr_AC_boolExpression), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_AC_boolExpression::galgasRTTI (void) const {
  return & gClassInfoFor__AC_boolExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_AC_boolExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_AC_boolExpression ("AC_boolExpression", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_AC_boolExpression::
GGS_AC_boolExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression::
GGS_AC_boolExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_AC_boolExpression GGS_AC_boolExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_AC_boolExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_AC_boolExpression *> (inPointer) != NULL)
      : (typeid (cPtr_AC_boolExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_AC_boolExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_AC_boolExpression),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_AC_boolExpression::actualTypeName (void) const {
  return "AC_boolExpression" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_AC_boolExpression::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__AC_boolExpression ("AC_boolExpression", & kTypeDescriptor_GGS_AC_boolExpression) ;

//---------------------------------------------------------------------------*

GGS_object GGS_AC_boolExpression::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_AC_boolExpression * p = NULL ;
    macroMyNew (p, GGS_AC_boolExpression (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression GGS_AC_boolExpression::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_AC_boolExpression result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_AC_boolExpression * p = dynamic_cast <const GGS_AC_boolExpression *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_AC_boolExpression, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_AC_boolExpression::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_AC_boolExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_C_importBoolMachine'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_importBoolMachine::
cPtr_C_importBoolMachine (const GGS_uint & argument_0,
                                const GGS_location & argument_1,
                                const GGS_L_translationVector & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE),
mIndexOfImportedMachine (argument_0),
mErrorLocation (argument_1),
mTranslationVector (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_importBoolMachine * GGS_C_importBoolMachine::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_importBoolMachine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_importBoolMachine *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_importBoolMachine::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_importBoolMachine * ptr = dynamic_cast <const cPtr_C_importBoolMachine *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIndexOfImportedMachine.operator_isEqual (ptr->mIndexOfImportedMachine).boolValue ()
         && mErrorLocation.operator_isEqual (ptr->mErrorLocation).boolValue ()
         && mTranslationVector.operator_isEqual (ptr->mTranslationVector).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_importBoolMachine::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_importBoolMachine:"
           << mIndexOfImportedMachine.reader_description (inIndentation + 1)
           << mErrorLocation.reader_description (inIndentation + 1)
           << mTranslationVector.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_importBoolMachine::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_importBoolMachine::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_importBoolMachine (& typeid (cPtr_C_importBoolMachine), & typeid (cPtr_AC_boolExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_importBoolMachine::galgasRTTI (void) const {
  return & gClassInfoFor__C_importBoolMachine ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_importBoolMachine::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_importBoolMachine (mIndexOfImportedMachine, mErrorLocation, mTranslationVector COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_importBoolMachine'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_importBoolMachine ("C_importBoolMachine", true, & kTypeDescriptor_GGS_AC_boolExpression) ;

//---------------------------------------------------------------------------*

GGS_C_importBoolMachine::
GGS_C_importBoolMachine (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_importBoolMachine::
GGS_C_importBoolMachine (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_importBoolMachine GGS_C_importBoolMachine::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_importBoolMachine result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_importBoolMachine *> (inPointer) != NULL)
      : (typeid (cPtr_C_importBoolMachine) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_importBoolMachine (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_importBoolMachine),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_importBoolMachine GGS_C_importBoolMachine::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_uint & argument_0,
                 const GGS_location & argument_1,
                 const GGS_L_translationVector & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_C_importBoolMachine result ;
  macroMyNew (result.mPointer, cPtr_C_importBoolMachine (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_importBoolMachine::
reader_mIndexOfImportedMachine (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_importBoolMachine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_importBoolMachine *) mPointer)->mIndexOfImportedMachine ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_C_importBoolMachine::
reader_mErrorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_importBoolMachine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_importBoolMachine *) mPointer)->mErrorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_translationVector  GGS_C_importBoolMachine::
reader_mTranslationVector (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_translationVector   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_importBoolMachine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_importBoolMachine *) mPointer)->mTranslationVector ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_importBoolMachine::actualTypeName (void) const {
  return "C_importBoolMachine" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_importBoolMachine ("C_importBoolMachine", gClassInfoFor__AC_boolExpression, & kTypeDescriptor_GGS_C_importBoolMachine) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_importBoolMachine::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_importBoolMachine * p = NULL ;
    macroMyNew (p, GGS_C_importBoolMachine (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_importBoolMachine GGS_C_importBoolMachine::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_importBoolMachine result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_importBoolMachine * p = dynamic_cast <const GGS_C_importBoolMachine *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_importBoolMachine, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_importBoolMachine::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_importBoolMachine ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_C_andExpression'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_andExpression::
cPtr_C_andExpression (const GGS_AC_boolExpression & argument_0,
                                const GGS_AC_boolExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_andExpression * GGS_C_andExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_andExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_andExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_andExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_andExpression * ptr = dynamic_cast <const cPtr_C_andExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_andExpression::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_andExpression:"
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_andExpression::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_andExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_andExpression (& typeid (cPtr_C_andExpression), & typeid (cPtr_AC_boolExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_andExpression::galgasRTTI (void) const {
  return & gClassInfoFor__C_andExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_andExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_andExpression (mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_andExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_andExpression ("C_andExpression", true, & kTypeDescriptor_GGS_AC_boolExpression) ;

//---------------------------------------------------------------------------*

GGS_C_andExpression::
GGS_C_andExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_andExpression::
GGS_C_andExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_andExpression GGS_C_andExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_andExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_andExpression *> (inPointer) != NULL)
      : (typeid (cPtr_C_andExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_andExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_andExpression),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_andExpression GGS_C_andExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_AC_boolExpression & argument_0,
                 const GGS_AC_boolExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_andExpression result ;
  macroMyNew (result.mPointer, cPtr_C_andExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_C_andExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_boolExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_andExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_andExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_C_andExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_boolExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_andExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_andExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_andExpression::actualTypeName (void) const {
  return "C_andExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_andExpression ("C_andExpression", gClassInfoFor__AC_boolExpression, & kTypeDescriptor_GGS_C_andExpression) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_andExpression::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_andExpression * p = NULL ;
    macroMyNew (p, GGS_C_andExpression (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_andExpression GGS_C_andExpression::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_andExpression result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_andExpression * p = dynamic_cast <const GGS_C_andExpression *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_andExpression, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_andExpression::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_andExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_C_orExpression'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_orExpression::
cPtr_C_orExpression (const GGS_AC_boolExpression & argument_0,
                                const GGS_AC_boolExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_orExpression * GGS_C_orExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_orExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_orExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_orExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_orExpression * ptr = dynamic_cast <const cPtr_C_orExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_orExpression::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_orExpression:"
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_orExpression::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_orExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_orExpression (& typeid (cPtr_C_orExpression), & typeid (cPtr_AC_boolExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_orExpression::galgasRTTI (void) const {
  return & gClassInfoFor__C_orExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_orExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_orExpression (mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_orExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_orExpression ("C_orExpression", true, & kTypeDescriptor_GGS_AC_boolExpression) ;

//---------------------------------------------------------------------------*

GGS_C_orExpression::
GGS_C_orExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_orExpression::
GGS_C_orExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_orExpression GGS_C_orExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_orExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_orExpression *> (inPointer) != NULL)
      : (typeid (cPtr_C_orExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_orExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_orExpression),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_orExpression GGS_C_orExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_AC_boolExpression & argument_0,
                 const GGS_AC_boolExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_orExpression result ;
  macroMyNew (result.mPointer, cPtr_C_orExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_C_orExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_boolExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_orExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_orExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_C_orExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_boolExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_orExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_orExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_orExpression::actualTypeName (void) const {
  return "C_orExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_orExpression ("C_orExpression", gClassInfoFor__AC_boolExpression, & kTypeDescriptor_GGS_C_orExpression) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_orExpression::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_orExpression * p = NULL ;
    macroMyNew (p, GGS_C_orExpression (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_orExpression GGS_C_orExpression::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_orExpression result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_orExpression * p = dynamic_cast <const GGS_C_orExpression *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_orExpression, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_orExpression::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_orExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_C_xorExpression'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_xorExpression::
cPtr_C_xorExpression (const GGS_AC_boolExpression & argument_0,
                                const GGS_AC_boolExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_xorExpression * GGS_C_xorExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_xorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_xorExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_xorExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_xorExpression * ptr = dynamic_cast <const cPtr_C_xorExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_xorExpression::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_xorExpression:"
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_xorExpression::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_xorExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_xorExpression (& typeid (cPtr_C_xorExpression), & typeid (cPtr_AC_boolExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_xorExpression::galgasRTTI (void) const {
  return & gClassInfoFor__C_xorExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_xorExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_xorExpression (mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_xorExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_xorExpression ("C_xorExpression", true, & kTypeDescriptor_GGS_AC_boolExpression) ;

//---------------------------------------------------------------------------*

GGS_C_xorExpression::
GGS_C_xorExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_xorExpression::
GGS_C_xorExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_xorExpression GGS_C_xorExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_xorExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_xorExpression *> (inPointer) != NULL)
      : (typeid (cPtr_C_xorExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_xorExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_xorExpression),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_xorExpression GGS_C_xorExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_AC_boolExpression & argument_0,
                 const GGS_AC_boolExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_xorExpression result ;
  macroMyNew (result.mPointer, cPtr_C_xorExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_C_xorExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_boolExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_xorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_xorExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_C_xorExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_boolExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_xorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_xorExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_xorExpression::actualTypeName (void) const {
  return "C_xorExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_xorExpression ("C_xorExpression", gClassInfoFor__AC_boolExpression, & kTypeDescriptor_GGS_C_xorExpression) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_xorExpression::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_xorExpression * p = NULL ;
    macroMyNew (p, GGS_C_xorExpression (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_xorExpression GGS_C_xorExpression::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_xorExpression result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_xorExpression * p = dynamic_cast <const GGS_C_xorExpression *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_xorExpression, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_xorExpression::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_xorExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_C_impliesExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_impliesExpression::
cPtr_C_impliesExpression (const GGS_AC_boolExpression & argument_0,
                                const GGS_AC_boolExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_impliesExpression * GGS_C_impliesExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_impliesExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_impliesExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_impliesExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_impliesExpression * ptr = dynamic_cast <const cPtr_C_impliesExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_impliesExpression::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_impliesExpression:"
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_impliesExpression::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_impliesExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_impliesExpression (& typeid (cPtr_C_impliesExpression), & typeid (cPtr_AC_boolExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_impliesExpression::galgasRTTI (void) const {
  return & gClassInfoFor__C_impliesExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_impliesExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_impliesExpression (mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_impliesExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_impliesExpression ("C_impliesExpression", true, & kTypeDescriptor_GGS_AC_boolExpression) ;

//---------------------------------------------------------------------------*

GGS_C_impliesExpression::
GGS_C_impliesExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_impliesExpression::
GGS_C_impliesExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_impliesExpression GGS_C_impliesExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_impliesExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_impliesExpression *> (inPointer) != NULL)
      : (typeid (cPtr_C_impliesExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_impliesExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_impliesExpression),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_impliesExpression GGS_C_impliesExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_AC_boolExpression & argument_0,
                 const GGS_AC_boolExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_impliesExpression result ;
  macroMyNew (result.mPointer, cPtr_C_impliesExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_C_impliesExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_boolExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_impliesExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_impliesExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_C_impliesExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_boolExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_impliesExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_impliesExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_impliesExpression::actualTypeName (void) const {
  return "C_impliesExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_impliesExpression ("C_impliesExpression", gClassInfoFor__AC_boolExpression, & kTypeDescriptor_GGS_C_impliesExpression) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_impliesExpression::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_impliesExpression * p = NULL ;
    macroMyNew (p, GGS_C_impliesExpression (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_impliesExpression GGS_C_impliesExpression::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_impliesExpression result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_impliesExpression * p = dynamic_cast <const GGS_C_impliesExpression *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_impliesExpression, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_impliesExpression::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_impliesExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_C_equalExpression'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_equalExpression::
cPtr_C_equalExpression (const GGS_AC_boolExpression & argument_0,
                                const GGS_AC_boolExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_equalExpression * GGS_C_equalExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_equalExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_equalExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_equalExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_equalExpression * ptr = dynamic_cast <const cPtr_C_equalExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_equalExpression::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_equalExpression:"
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_equalExpression::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_equalExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_equalExpression (& typeid (cPtr_C_equalExpression), & typeid (cPtr_AC_boolExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_equalExpression::galgasRTTI (void) const {
  return & gClassInfoFor__C_equalExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_equalExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_equalExpression (mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_equalExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_equalExpression ("C_equalExpression", true, & kTypeDescriptor_GGS_AC_boolExpression) ;

//---------------------------------------------------------------------------*

GGS_C_equalExpression::
GGS_C_equalExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_equalExpression::
GGS_C_equalExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_equalExpression GGS_C_equalExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_equalExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_equalExpression *> (inPointer) != NULL)
      : (typeid (cPtr_C_equalExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_equalExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_equalExpression),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_equalExpression GGS_C_equalExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_AC_boolExpression & argument_0,
                 const GGS_AC_boolExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_equalExpression result ;
  macroMyNew (result.mPointer, cPtr_C_equalExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_C_equalExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_boolExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_equalExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_equalExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_C_equalExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_boolExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_equalExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_equalExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_equalExpression::actualTypeName (void) const {
  return "C_equalExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_equalExpression ("C_equalExpression", gClassInfoFor__AC_boolExpression, & kTypeDescriptor_GGS_C_equalExpression) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_equalExpression::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_equalExpression * p = NULL ;
    macroMyNew (p, GGS_C_equalExpression (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_equalExpression GGS_C_equalExpression::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_equalExpression result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_equalExpression * p = dynamic_cast <const GGS_C_equalExpression *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_equalExpression, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_equalExpression::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_equalExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_C_notExpression'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_notExpression::
cPtr_C_notExpression (const GGS_AC_boolExpression & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_notExpression * GGS_C_notExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_notExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_notExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_notExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_notExpression * ptr = dynamic_cast <const cPtr_C_notExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_notExpression::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_notExpression:"
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_notExpression::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_notExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_notExpression (& typeid (cPtr_C_notExpression), & typeid (cPtr_AC_boolExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_notExpression::galgasRTTI (void) const {
  return & gClassInfoFor__C_notExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_notExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_notExpression (mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_notExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_notExpression ("C_notExpression", true, & kTypeDescriptor_GGS_AC_boolExpression) ;

//---------------------------------------------------------------------------*

GGS_C_notExpression::
GGS_C_notExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_notExpression::
GGS_C_notExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_notExpression GGS_C_notExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_notExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_notExpression *> (inPointer) != NULL)
      : (typeid (cPtr_C_notExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_notExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_notExpression),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_notExpression GGS_C_notExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_AC_boolExpression & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_C_notExpression result ;
  macroMyNew (result.mPointer, cPtr_C_notExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_C_notExpression::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_boolExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_notExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_notExpression *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_notExpression::actualTypeName (void) const {
  return "C_notExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_notExpression ("C_notExpression", gClassInfoFor__AC_boolExpression, & kTypeDescriptor_GGS_C_notExpression) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_notExpression::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_notExpression * p = NULL ;
    macroMyNew (p, GGS_C_notExpression (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_notExpression GGS_C_notExpression::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_notExpression result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_notExpression * p = dynamic_cast <const GGS_C_notExpression *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_notExpression, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_notExpression::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_notExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_C_VariableExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_VariableExpression::
cPtr_C_VariableExpression (const GGS_uint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE),
mInputVarIndex (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_VariableExpression * GGS_C_VariableExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_VariableExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_VariableExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_VariableExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_VariableExpression * ptr = dynamic_cast <const cPtr_C_VariableExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInputVarIndex.operator_isEqual (ptr->mInputVarIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_VariableExpression::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_VariableExpression:"
           << mInputVarIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_VariableExpression::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_VariableExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_VariableExpression (& typeid (cPtr_C_VariableExpression), & typeid (cPtr_AC_boolExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_VariableExpression::galgasRTTI (void) const {
  return & gClassInfoFor__C_VariableExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_VariableExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_VariableExpression (mInputVarIndex COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_VariableExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_VariableExpression ("C_VariableExpression", true, & kTypeDescriptor_GGS_AC_boolExpression) ;

//---------------------------------------------------------------------------*

GGS_C_VariableExpression::
GGS_C_VariableExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_VariableExpression::
GGS_C_VariableExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_VariableExpression GGS_C_VariableExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_VariableExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_VariableExpression *> (inPointer) != NULL)
      : (typeid (cPtr_C_VariableExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_VariableExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_VariableExpression),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_VariableExpression GGS_C_VariableExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_uint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_C_VariableExpression result ;
  macroMyNew (result.mPointer, cPtr_C_VariableExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_VariableExpression::
reader_mInputVarIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_VariableExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_VariableExpression *) mPointer)->mInputVarIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_VariableExpression::actualTypeName (void) const {
  return "C_VariableExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_VariableExpression ("C_VariableExpression", gClassInfoFor__AC_boolExpression, & kTypeDescriptor_GGS_C_VariableExpression) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_VariableExpression::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_VariableExpression * p = NULL ;
    macroMyNew (p, GGS_C_VariableExpression (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_VariableExpression GGS_C_VariableExpression::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_VariableExpression result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_VariableExpression * p = dynamic_cast <const GGS_C_VariableExpression *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_VariableExpression, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_VariableExpression::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_VariableExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_C_trueExpression'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_trueExpression::
cPtr_C_trueExpression (LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_trueExpression * GGS_C_trueExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_trueExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_trueExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_trueExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_C_trueExpression::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@C_trueExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_trueExpression::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_trueExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_trueExpression (& typeid (cPtr_C_trueExpression), & typeid (cPtr_AC_boolExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_trueExpression::galgasRTTI (void) const {
  return & gClassInfoFor__C_trueExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_trueExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_trueExpression ("C_trueExpression", true, & kTypeDescriptor_GGS_AC_boolExpression) ;

//---------------------------------------------------------------------------*

GGS_C_trueExpression::
GGS_C_trueExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_trueExpression::
GGS_C_trueExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_trueExpression GGS_C_trueExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_trueExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_trueExpression *> (inPointer) != NULL)
      : (typeid (cPtr_C_trueExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_trueExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_trueExpression),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_C_trueExpression * gSingleton_C_trueExpression = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_C_trueExpression (void) {
  macroDetachPointer (gSingleton_C_trueExpression, cPtr_C_trueExpression) ;
}

//---------------------------------------------------------------------------*

GGS_C_trueExpression GGS_C_trueExpression::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_C_trueExpression result ;
  if (NULL == gSingleton_C_trueExpression) {
    macroMyNew (gSingleton_C_trueExpression, cPtr_C_trueExpression (THERE)) ;
    registerReleaseRoutine (cleanUp_C_trueExpression) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_C_trueExpression) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_trueExpression::actualTypeName (void) const {
  return "C_trueExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_trueExpression ("C_trueExpression", gClassInfoFor__AC_boolExpression, & kTypeDescriptor_GGS_C_trueExpression) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_trueExpression::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_trueExpression * p = NULL ;
    macroMyNew (p, GGS_C_trueExpression (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_trueExpression GGS_C_trueExpression::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_trueExpression result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_trueExpression * p = dynamic_cast <const GGS_C_trueExpression *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_trueExpression, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_trueExpression::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_trueExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_C_falseExpression'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_falseExpression::
cPtr_C_falseExpression (LOCATION_ARGS)
:cPtr_AC_boolExpression (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_falseExpression * GGS_C_falseExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_falseExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_falseExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_falseExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_C_falseExpression::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@C_falseExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_falseExpression::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_falseExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_falseExpression (& typeid (cPtr_C_falseExpression), & typeid (cPtr_AC_boolExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_falseExpression::galgasRTTI (void) const {
  return & gClassInfoFor__C_falseExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_falseExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_falseExpression ("C_falseExpression", true, & kTypeDescriptor_GGS_AC_boolExpression) ;

//---------------------------------------------------------------------------*

GGS_C_falseExpression::
GGS_C_falseExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_falseExpression::
GGS_C_falseExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_falseExpression GGS_C_falseExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_falseExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_falseExpression *> (inPointer) != NULL)
      : (typeid (cPtr_C_falseExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_falseExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_falseExpression),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_C_falseExpression * gSingleton_C_falseExpression = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_C_falseExpression (void) {
  macroDetachPointer (gSingleton_C_falseExpression, cPtr_C_falseExpression) ;
}

//---------------------------------------------------------------------------*

GGS_C_falseExpression GGS_C_falseExpression::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_C_falseExpression result ;
  if (NULL == gSingleton_C_falseExpression) {
    macroMyNew (gSingleton_C_falseExpression, cPtr_C_falseExpression (THERE)) ;
    registerReleaseRoutine (cleanUp_C_falseExpression) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_C_falseExpression) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_falseExpression::actualTypeName (void) const {
  return "C_falseExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_falseExpression ("C_falseExpression", gClassInfoFor__AC_boolExpression, & kTypeDescriptor_GGS_C_falseExpression) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_falseExpression::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_falseExpression * p = NULL ;
    macroMyNew (p, GGS_C_falseExpression (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_falseExpression GGS_C_falseExpression::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_falseExpression result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_falseExpression * p = dynamic_cast <const GGS_C_falseExpression *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_falseExpression, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_falseExpression::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_falseExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@L_transitionDefinition'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_transitionDefinition::
elementOf_GGS_L_transitionDefinition (const GGS_AC_boolExpression & argument_0,
                                const GGS_location & argument_1,
                                const GGS_uint & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mActionExpression (argument_0),
mEndOfExpression (argument_1),
mTargetStateIndex (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_transitionDefinition::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_transitionDefinition * ptr = dynamic_cast <const elementOf_GGS_L_transitionDefinition *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mActionExpression.operator_isEqual (ptr->mActionExpression).boolValue ()
         && mEndOfExpression.operator_isEqual (ptr->mEndOfExpression).boolValue ()
         && mTargetStateIndex.operator_isEqual (ptr->mTargetStateIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_transitionDefinition::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActionExpression.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndOfExpression.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTargetStateIndex.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@L_transitionDefinition'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_L_transitionDefinition ("L_transitionDefinition", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
internalAppendValues (const GGS_AC_boolExpression & argument_0,
                    const GGS_location & argument_1,
                    const GGS_uint & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
internalPrependValues (const GGS_AC_boolExpression & argument_0,
                    const GGS_location & argument_1,
                    const GGS_uint & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
addAssign_operation (const GGS_AC_boolExpression & argument_0,
                                const GGS_location & argument_1,
                                const GGS_uint & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_transitionDefinition GGS_L_transitionDefinition::
operator_concat (const GGS_L_transitionDefinition & inOperand) const {
  GGS_L_transitionDefinition result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
dotAssign_operation (const GGS_L_transitionDefinition inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_L_transitionDefinition * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_AC_boolExpression  p_0 = p->mActionExpression ;
          GGS_location  p_1 = p->mEndOfExpression ;
          GGS_uint  p_2 = p->mTargetStateIndex ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_AC_boolExpression & argument_0,
                     const GGS_location & argument_1,
                     const GGS_uint & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mActionExpression,
                                ptr->mEndOfExpression,
                                ptr->mTargetStateIndex
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_transitionDefinition  GGS_L_transitionDefinition::
constructor_emptyList (void) {
  GGS_L_transitionDefinition result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_transitionDefinition  GGS_L_transitionDefinition::
constructor_listWithValue (const GGS_AC_boolExpression & argument_0,
                                const GGS_location & argument_1,
                                const GGS_uint & argument_2) {
  GGS_L_transitionDefinition result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
internalSubListWithRange (GGS_L_transitionDefinition & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mActionExpression, ptr->mEndOfExpression, ptr->mTargetStateIndex) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_transitionDefinition GGS_L_transitionDefinition::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_transitionDefinition result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_transitionDefinition GGS_L_transitionDefinition::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_transitionDefinition result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_transitionDefinition::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@L_transitionDefinition", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
method_first (C_Compiler & inLexique,
              GGS_AC_boolExpression & _out_0,
              GGS_location & _out_1,
              GGS_uint & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActionExpression ;
    _out_1 = ptr->mEndOfExpression ;
    _out_2 = ptr->mTargetStateIndex ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
method_last (C_Compiler & inLexique,
             GGS_AC_boolExpression & _out_0,
             GGS_location & _out_1,
             GGS_uint & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActionExpression ;
    _out_1 = ptr->mEndOfExpression ;
    _out_2 = ptr->mTargetStateIndex ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_AC_boolExpression & _out_0,
                 GGS_location & _out_1,
                 GGS_uint & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActionExpression ;
    _out_1 = ptr->mEndOfExpression ;
    _out_2 = ptr->mTargetStateIndex ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
modifier_popLast (C_Compiler & inLexique,
                GGS_AC_boolExpression & _out_0,
                GGS_location & _out_1,
                GGS_uint & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActionExpression ;
    _out_1 = ptr->mEndOfExpression ;
    _out_2 = ptr->mTargetStateIndex ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_L_transitionDefinition::
reader_mActionExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_AC_boolExpression  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mActionExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_L_transitionDefinition::
reader_mEndOfExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEndOfExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_L_transitionDefinition::
reader_mTargetStateIndexAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_uint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTargetStateIndex ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
modifier_setMActionExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_AC_boolExpression  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mActionExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
modifier_setMEndOfExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEndOfExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
modifier_setMTargetStateIndexAtIndex (C_Compiler & inLexique,
                              const GGS_uint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTargetStateIndex = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_boolExpression  & GGS_L_transitionDefinition::cEnumerator::_mActionExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mActionExpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_L_transitionDefinition::cEnumerator::_mEndOfExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEndOfExpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_L_transitionDefinition::cEnumerator::_mTargetStateIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTargetStateIndex ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_L_transitionDefinition::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_L_transitionDefinition * p = NULL ;
    macroMyNew (p, GGS_L_transitionDefinition (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_transitionDefinition GGS_L_transitionDefinition::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_L_transitionDefinition result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_L_transitionDefinition * p = dynamic_cast <const GGS_L_transitionDefinition *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_L_transitionDefinition, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_L_transitionDefinition::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_L_transitionDefinition ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@L_stateDefinition'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_stateDefinition::
elementOf_GGS_L_stateDefinition (const GGS_uint & argument_0,
                                const GGS_AC_boolExpression & argument_1,
                                const GGS_location & argument_2,
                                const GGS_L_transitionDefinition & argument_3
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mStateIndex (argument_0),
mStateExpression (argument_1),
mEndOfStateExpression (argument_2),
mTransitionsList (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_stateDefinition::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_stateDefinition * ptr = dynamic_cast <const elementOf_GGS_L_stateDefinition *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStateIndex.operator_isEqual (ptr->mStateIndex).boolValue ()
         && mStateExpression.operator_isEqual (ptr->mStateExpression).boolValue ()
         && mEndOfStateExpression.operator_isEqual (ptr->mEndOfStateExpression).boolValue ()
         && mTransitionsList.operator_isEqual (ptr->mTransitionsList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_stateDefinition::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStateIndex.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStateExpression.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndOfStateExpression.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTransitionsList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@L_stateDefinition'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_L_stateDefinition ("L_stateDefinition", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
internalAppendValues (const GGS_uint & argument_0,
                    const GGS_AC_boolExpression & argument_1,
                    const GGS_location & argument_2,
                    const GGS_L_transitionDefinition & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
internalPrependValues (const GGS_uint & argument_0,
                    const GGS_AC_boolExpression & argument_1,
                    const GGS_location & argument_2,
                    const GGS_L_transitionDefinition & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
addAssign_operation (const GGS_uint & argument_0,
                                const GGS_AC_boolExpression & argument_1,
                                const GGS_location & argument_2,
                                const GGS_L_transitionDefinition & argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_stateDefinition GGS_L_stateDefinition::
operator_concat (const GGS_L_stateDefinition & inOperand) const {
  GGS_L_stateDefinition result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
dotAssign_operation (const GGS_L_stateDefinition inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_L_stateDefinition * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_uint  p_0 = p->mStateIndex ;
          GGS_AC_boolExpression  p_1 = p->mStateExpression ;
          GGS_location  p_2 = p->mEndOfStateExpression ;
          GGS_L_transitionDefinition  p_3 = p->mTransitionsList ;
          internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_uint & argument_0,
                     const GGS_AC_boolExpression & argument_1,
                     const GGS_location & argument_2,
                     const GGS_L_transitionDefinition & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mStateIndex,
                                ptr->mStateExpression,
                                ptr->mEndOfStateExpression,
                                ptr->mTransitionsList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_stateDefinition  GGS_L_stateDefinition::
constructor_emptyList (void) {
  GGS_L_stateDefinition result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_stateDefinition  GGS_L_stateDefinition::
constructor_listWithValue (const GGS_uint & argument_0,
                                const GGS_AC_boolExpression & argument_1,
                                const GGS_location & argument_2,
                                const GGS_L_transitionDefinition & argument_3) {
  GGS_L_stateDefinition result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
internalSubListWithRange (GGS_L_stateDefinition & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mStateIndex, ptr->mStateExpression, ptr->mEndOfStateExpression, ptr->mTransitionsList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_stateDefinition GGS_L_stateDefinition::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_stateDefinition result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_stateDefinition GGS_L_stateDefinition::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_stateDefinition result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_stateDefinition::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@L_stateDefinition", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
method_first (C_Compiler & inLexique,
              GGS_uint & _out_0,
              GGS_AC_boolExpression & _out_1,
              GGS_location & _out_2,
              GGS_L_transitionDefinition & _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStateIndex ;
    _out_1 = ptr->mStateExpression ;
    _out_2 = ptr->mEndOfStateExpression ;
    _out_3 = ptr->mTransitionsList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
method_last (C_Compiler & inLexique,
             GGS_uint & _out_0,
             GGS_AC_boolExpression & _out_1,
             GGS_location & _out_2,
             GGS_L_transitionDefinition & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStateIndex ;
    _out_1 = ptr->mStateExpression ;
    _out_2 = ptr->mEndOfStateExpression ;
    _out_3 = ptr->mTransitionsList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_uint & _out_0,
                 GGS_AC_boolExpression & _out_1,
                 GGS_location & _out_2,
                 GGS_L_transitionDefinition & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStateIndex ;
    _out_1 = ptr->mStateExpression ;
    _out_2 = ptr->mEndOfStateExpression ;
    _out_3 = ptr->mTransitionsList ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
modifier_popLast (C_Compiler & inLexique,
                GGS_uint & _out_0,
                GGS_AC_boolExpression & _out_1,
                GGS_location & _out_2,
                GGS_L_transitionDefinition & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStateIndex ;
    _out_1 = ptr->mStateExpression ;
    _out_2 = ptr->mEndOfStateExpression ;
    _out_3 = ptr->mTransitionsList ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_L_stateDefinition::
reader_mStateIndexAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_uint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mStateIndex ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_L_stateDefinition::
reader_mStateExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_AC_boolExpression  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mStateExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_L_stateDefinition::
reader_mEndOfStateExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEndOfStateExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_transitionDefinition  GGS_L_stateDefinition::
reader_mTransitionsListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_L_transitionDefinition  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTransitionsList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
modifier_setMStateIndexAtIndex (C_Compiler & inLexique,
                              const GGS_uint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mStateIndex = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
modifier_setMStateExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_AC_boolExpression  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mStateExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
modifier_setMEndOfStateExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEndOfStateExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
modifier_setMTransitionsListAtIndex (C_Compiler & inLexique,
                              const GGS_L_transitionDefinition  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTransitionsList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_L_stateDefinition::cEnumerator::_mStateIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mStateIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_boolExpression  & GGS_L_stateDefinition::cEnumerator::_mStateExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mStateExpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_L_stateDefinition::cEnumerator::_mEndOfStateExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEndOfStateExpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_transitionDefinition  & GGS_L_stateDefinition::cEnumerator::_mTransitionsList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTransitionsList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_L_stateDefinition::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_L_stateDefinition * p = NULL ;
    macroMyNew (p, GGS_L_stateDefinition (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_stateDefinition GGS_L_stateDefinition::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_L_stateDefinition result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_L_stateDefinition * p = dynamic_cast <const GGS_L_stateDefinition *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_L_stateDefinition, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_L_stateDefinition::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_L_stateDefinition ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@L_statesDefinitionList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_statesDefinitionList::
elementOf_GGS_L_statesDefinitionList (const GGS_uint & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mStateIndex (argument_0),
mStateLocation (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_statesDefinitionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_statesDefinitionList * ptr = dynamic_cast <const elementOf_GGS_L_statesDefinitionList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStateIndex.operator_isEqual (ptr->mStateIndex).boolValue ()
         && mStateLocation.operator_isEqual (ptr->mStateLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_statesDefinitionList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStateIndex.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStateLocation.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@L_statesDefinitionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_L_statesDefinitionList ("L_statesDefinitionList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList::
internalAppendValues (const GGS_uint & argument_0,
                    const GGS_location & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList::
internalPrependValues (const GGS_uint & argument_0,
                    const GGS_location & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList::
addAssign_operation (const GGS_uint & argument_0,
                                const GGS_location & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_statesDefinitionList GGS_L_statesDefinitionList::
operator_concat (const GGS_L_statesDefinitionList & inOperand) const {
  GGS_L_statesDefinitionList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList::
dotAssign_operation (const GGS_L_statesDefinitionList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_L_statesDefinitionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_uint  p_0 = p->mStateIndex ;
          GGS_location  p_1 = p->mStateLocation ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_uint & argument_0,
                     const GGS_location & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mStateIndex,
                                ptr->mStateLocation
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_statesDefinitionList  GGS_L_statesDefinitionList::
constructor_emptyList (void) {
  GGS_L_statesDefinitionList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_statesDefinitionList  GGS_L_statesDefinitionList::
constructor_listWithValue (const GGS_uint & argument_0,
                                const GGS_location & argument_1) {
  GGS_L_statesDefinitionList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList::
internalSubListWithRange (GGS_L_statesDefinitionList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mStateIndex, ptr->mStateLocation) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_statesDefinitionList GGS_L_statesDefinitionList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_statesDefinitionList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_statesDefinitionList GGS_L_statesDefinitionList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_statesDefinitionList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_statesDefinitionList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@L_statesDefinitionList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList::
method_first (C_Compiler & inLexique,
              GGS_uint & _out_0,
              GGS_location & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStateIndex ;
    _out_1 = ptr->mStateLocation ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList::
method_last (C_Compiler & inLexique,
             GGS_uint & _out_0,
             GGS_location & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStateIndex ;
    _out_1 = ptr->mStateLocation ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_uint & _out_0,
                 GGS_location & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStateIndex ;
    _out_1 = ptr->mStateLocation ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList::
modifier_popLast (C_Compiler & inLexique,
                GGS_uint & _out_0,
                GGS_location & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStateIndex ;
    _out_1 = ptr->mStateLocation ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_L_statesDefinitionList::
reader_mStateIndexAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_uint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mStateIndex ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_L_statesDefinitionList::
reader_mStateLocationAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mStateLocation ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList::
modifier_setMStateIndexAtIndex (C_Compiler & inLexique,
                              const GGS_uint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mStateIndex = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList::
modifier_setMStateLocationAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mStateLocation = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_L_statesDefinitionList::cEnumerator::_mStateIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mStateIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_L_statesDefinitionList::cEnumerator::_mStateLocation (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mStateLocation ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_L_statesDefinitionList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_L_statesDefinitionList * p = NULL ;
    macroMyNew (p, GGS_L_statesDefinitionList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_statesDefinitionList GGS_L_statesDefinitionList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_L_statesDefinitionList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_L_statesDefinitionList * p = dynamic_cast <const GGS_L_statesDefinitionList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_L_statesDefinitionList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_L_statesDefinitionList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_L_statesDefinitionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_AC_machineDefinition'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_machineDefinition::
cPtr_AC_machineDefinition (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_machineDefinition * GGS_AC_machineDefinition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_AC_machineDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_AC_machineDefinition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_AC_machineDefinition::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@AC_machineDefinition:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_AC_machineDefinition::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_machineDefinition::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_AC_machineDefinition (& typeid (cPtr_AC_machineDefinition), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_AC_machineDefinition::galgasRTTI (void) const {
  return & gClassInfoFor__AC_machineDefinition ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_AC_machineDefinition'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_AC_machineDefinition ("AC_machineDefinition", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition::
GGS_AC_machineDefinition (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition::
GGS_AC_machineDefinition (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_AC_machineDefinition GGS_AC_machineDefinition::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_AC_machineDefinition result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_AC_machineDefinition *> (inPointer) != NULL)
      : (typeid (cPtr_AC_machineDefinition) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_AC_machineDefinition (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_AC_machineDefinition),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_AC_machineDefinition::actualTypeName (void) const {
  return "AC_machineDefinition" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_AC_machineDefinition::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__AC_machineDefinition ("AC_machineDefinition", & kTypeDescriptor_GGS_AC_machineDefinition) ;

//---------------------------------------------------------------------------*

GGS_object GGS_AC_machineDefinition::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_AC_machineDefinition * p = NULL ;
    macroMyNew (p, GGS_AC_machineDefinition (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition GGS_AC_machineDefinition::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_AC_machineDefinition result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_AC_machineDefinition * p = dynamic_cast <const GGS_AC_machineDefinition *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_AC_machineDefinition, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_AC_machineDefinition::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_AC_machineDefinition ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_M_modesMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_modesMap::e_M_modesMap (void) :
mIndex (),
mModeDefinition () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@M_modesMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_M_modesMap ("M_modesMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_M_modesMap::
elementOf_GGS_M_modesMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_M_modesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_modesMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mIndex.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mModeDefinition.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_modesMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_modesMap * ptr = dynamic_cast <const elementOf_GGS_M_modesMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mIndex.operator_isEqual (ptr->mInfo.mIndex)).boolValue ()
           && (mInfo.mModeDefinition.operator_isEqual (ptr->mInfo.mModeDefinition)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_modesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_modesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_modesMap * info = (e_M_modesMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_modesMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_modesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_modesMap * info = (e_M_modesMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_modesMap GGS_M_modesMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_modesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_modesMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_modesMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_modesMap::
operator_isEqual (const GGS_M_modesMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_modesMap::
operator_isNotEqual (const GGS_M_modesMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_modesMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_modesMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_uint & inParameter0,
                const GGS_AC_machineDefinition & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_modesMap info  ;
    info.mIndex = inParameter0 ;
    info.mModeDefinition = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_modesMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_AC_machineDefinition   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mIndex ;
    outParameter1 = node->mInfo.mModeDefinition ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_modesMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_modesMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0,
                                GGS_AC_machineDefinition   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_modesMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_modesMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0,
                                const GGS_AC_machineDefinition & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_modesMap GGS_M_modesMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_modesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_modesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_modesMap GGS_M_modesMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_modesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_modesMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @M_modesMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    PMSInt32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (elementID, s, inIndentation) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_M_modesMap::cEnumerator::_mIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_machineDefinition  & GGS_M_modesMap::cEnumerator::_mModeDefinition (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mModeDefinition ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_M_modesMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_M_modesMap * p = NULL ;
    macroMyNew (p, GGS_M_modesMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_modesMap GGS_M_modesMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_M_modesMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_M_modesMap * p = dynamic_cast <const GGS_M_modesMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_M_modesMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_M_modesMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_M_modesMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@ListForModes'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ListForModes::
elementOf_GGS_ListForModes (const GGS_uint & argument_0,
                                const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mSourceMode (argument_0),
mTargetMode (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_ListForModes::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_ListForModes * ptr = dynamic_cast <const elementOf_GGS_ListForModes *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSourceMode.operator_isEqual (ptr->mSourceMode).boolValue ()
         && mTargetMode.operator_isEqual (ptr->mTargetMode).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ListForModes::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSourceMode.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTargetMode.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           List '@ListForModes'                            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_ListForModes ("ListForModes", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_ListForModes::
internalAppendValues (const GGS_uint & argument_0,
                    const GGS_uint & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ListForModes::
internalPrependValues (const GGS_uint & argument_0,
                    const GGS_uint & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ListForModes::
addAssign_operation (const GGS_uint & argument_0,
                                const GGS_uint & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_ListForModes GGS_ListForModes::
operator_concat (const GGS_ListForModes & inOperand) const {
  GGS_ListForModes result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ListForModes::
dotAssign_operation (const GGS_ListForModes inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_ListForModes * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_uint  p_0 = p->mSourceMode ;
          GGS_uint  p_1 = p->mTargetMode ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ListForModes::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_uint & argument_0,
                     const GGS_uint & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ListForModes::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mSourceMode,
                                ptr->mTargetMode
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ListForModes  GGS_ListForModes::
constructor_emptyList (void) {
  GGS_ListForModes result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ListForModes  GGS_ListForModes::
constructor_listWithValue (const GGS_uint & argument_0,
                                const GGS_uint & argument_1) {
  GGS_ListForModes result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ListForModes::
internalSubListWithRange (GGS_ListForModes & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mSourceMode, ptr->mTargetMode) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ListForModes GGS_ListForModes::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_ListForModes result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ListForModes GGS_ListForModes::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_ListForModes result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ListForModes::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@ListForModes", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_ListForModes::
method_first (C_Compiler & inLexique,
              GGS_uint & _out_0,
              GGS_uint & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSourceMode ;
    _out_1 = ptr->mTargetMode ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ListForModes::
method_last (C_Compiler & inLexique,
             GGS_uint & _out_0,
             GGS_uint & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSourceMode ;
    _out_1 = ptr->mTargetMode ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ListForModes::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_uint & _out_0,
                 GGS_uint & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSourceMode ;
    _out_1 = ptr->mTargetMode ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ListForModes::
modifier_popLast (C_Compiler & inLexique,
                GGS_uint & _out_0,
                GGS_uint & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSourceMode ;
    _out_1 = ptr->mTargetMode ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_ListForModes::
reader_mSourceModeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_uint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSourceMode ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_ListForModes::
reader_mTargetModeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_uint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTargetMode ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ListForModes::
modifier_setMSourceModeAtIndex (C_Compiler & inLexique,
                              const GGS_uint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSourceMode = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ListForModes::
modifier_setMTargetModeAtIndex (C_Compiler & inLexique,
                              const GGS_uint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTargetMode = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_ListForModes::cEnumerator::_mSourceMode (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSourceMode ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_ListForModes::cEnumerator::_mTargetMode (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTargetMode ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_ListForModes::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_ListForModes * p = NULL ;
    macroMyNew (p, GGS_ListForModes (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ListForModes GGS_ListForModes::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_ListForModes result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_ListForModes * p = dynamic_cast <const GGS_ListForModes *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_ListForModes, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_ListForModes::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_ListForModes ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'cPtr_C_substractiveModalCompositionComponent'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_substractiveModalCompositionComponent::
cPtr_C_substractiveModalCompositionComponent (const GGS_M_modesMap & argument_0,
                                const GGS_ListForModes & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mModeMap (argument_0),
mExclusionList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_substractiveModalCompositionComponent * GGS_C_substractiveModalCompositionComponent::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_substractiveModalCompositionComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_substractiveModalCompositionComponent *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_substractiveModalCompositionComponent::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_substractiveModalCompositionComponent * ptr = dynamic_cast <const cPtr_C_substractiveModalCompositionComponent *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mModeMap.operator_isEqual (ptr->mModeMap).boolValue ()
         && mExclusionList.operator_isEqual (ptr->mExclusionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_substractiveModalCompositionComponent::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_substractiveModalCompositionComponent:"
           << mModeMap.reader_description (inIndentation + 1)
           << mExclusionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_substractiveModalCompositionComponent::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_substractiveModalCompositionComponent::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_substractiveModalCompositionComponent (& typeid (cPtr_C_substractiveModalCompositionComponent), & typeid (cPtr_AC_machineDefinition), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_substractiveModalCompositionComponent::galgasRTTI (void) const {
  return & gClassInfoFor__C_substractiveModalCompositionComponent ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_substractiveModalCompositionComponent::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_substractiveModalCompositionComponent (mModeMap, mExclusionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_C_substractiveModalCompositionComponent'         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_substractiveModalCompositionComponent ("C_substractiveModalCompositionComponent", true, & kTypeDescriptor_GGS_AC_machineDefinition) ;

//---------------------------------------------------------------------------*

GGS_C_substractiveModalCompositionComponent::
GGS_C_substractiveModalCompositionComponent (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_substractiveModalCompositionComponent::
GGS_C_substractiveModalCompositionComponent (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_substractiveModalCompositionComponent GGS_C_substractiveModalCompositionComponent::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_substractiveModalCompositionComponent result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_substractiveModalCompositionComponent *> (inPointer) != NULL)
      : (typeid (cPtr_C_substractiveModalCompositionComponent) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_substractiveModalCompositionComponent (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_substractiveModalCompositionComponent),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_substractiveModalCompositionComponent GGS_C_substractiveModalCompositionComponent::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_M_modesMap & argument_0,
                 const GGS_ListForModes & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_substractiveModalCompositionComponent result ;
  macroMyNew (result.mPointer, cPtr_C_substractiveModalCompositionComponent (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_modesMap  GGS_C_substractiveModalCompositionComponent::
reader_mModeMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_modesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_substractiveModalCompositionComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_substractiveModalCompositionComponent *) mPointer)->mModeMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ListForModes  GGS_C_substractiveModalCompositionComponent::
reader_mExclusionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ListForModes   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_substractiveModalCompositionComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_substractiveModalCompositionComponent *) mPointer)->mExclusionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_substractiveModalCompositionComponent::actualTypeName (void) const {
  return "C_substractiveModalCompositionComponent" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_substractiveModalCompositionComponent ("C_substractiveModalCompositionComponent", gClassInfoFor__AC_machineDefinition, & kTypeDescriptor_GGS_C_substractiveModalCompositionComponent) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_substractiveModalCompositionComponent::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_substractiveModalCompositionComponent * p = NULL ;
    macroMyNew (p, GGS_C_substractiveModalCompositionComponent (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_substractiveModalCompositionComponent GGS_C_substractiveModalCompositionComponent::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_substractiveModalCompositionComponent result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_substractiveModalCompositionComponent * p = dynamic_cast <const GGS_C_substractiveModalCompositionComponent *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_substractiveModalCompositionComponent, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_substractiveModalCompositionComponent::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_substractiveModalCompositionComponent ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_C_additiveModalCompositionComponent'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_additiveModalCompositionComponent::
cPtr_C_additiveModalCompositionComponent (const GGS_M_modesMap & argument_0,
                                const GGS_ListForModes & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mModeMap (argument_0),
mInclusionList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_additiveModalCompositionComponent * GGS_C_additiveModalCompositionComponent::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_additiveModalCompositionComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_additiveModalCompositionComponent *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_additiveModalCompositionComponent::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_additiveModalCompositionComponent * ptr = dynamic_cast <const cPtr_C_additiveModalCompositionComponent *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mModeMap.operator_isEqual (ptr->mModeMap).boolValue ()
         && mInclusionList.operator_isEqual (ptr->mInclusionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_additiveModalCompositionComponent::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_additiveModalCompositionComponent:"
           << mModeMap.reader_description (inIndentation + 1)
           << mInclusionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_additiveModalCompositionComponent::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_additiveModalCompositionComponent::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_additiveModalCompositionComponent (& typeid (cPtr_C_additiveModalCompositionComponent), & typeid (cPtr_AC_machineDefinition), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_additiveModalCompositionComponent::galgasRTTI (void) const {
  return & gClassInfoFor__C_additiveModalCompositionComponent ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_additiveModalCompositionComponent::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_additiveModalCompositionComponent (mModeMap, mInclusionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_C_additiveModalCompositionComponent'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_additiveModalCompositionComponent ("C_additiveModalCompositionComponent", true, & kTypeDescriptor_GGS_AC_machineDefinition) ;

//---------------------------------------------------------------------------*

GGS_C_additiveModalCompositionComponent::
GGS_C_additiveModalCompositionComponent (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_additiveModalCompositionComponent::
GGS_C_additiveModalCompositionComponent (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_additiveModalCompositionComponent GGS_C_additiveModalCompositionComponent::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_additiveModalCompositionComponent result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_additiveModalCompositionComponent *> (inPointer) != NULL)
      : (typeid (cPtr_C_additiveModalCompositionComponent) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_additiveModalCompositionComponent (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_additiveModalCompositionComponent),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_additiveModalCompositionComponent GGS_C_additiveModalCompositionComponent::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_M_modesMap & argument_0,
                 const GGS_ListForModes & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_additiveModalCompositionComponent result ;
  macroMyNew (result.mPointer, cPtr_C_additiveModalCompositionComponent (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_modesMap  GGS_C_additiveModalCompositionComponent::
reader_mModeMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_modesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_additiveModalCompositionComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_additiveModalCompositionComponent *) mPointer)->mModeMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ListForModes  GGS_C_additiveModalCompositionComponent::
reader_mInclusionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ListForModes   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_additiveModalCompositionComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_additiveModalCompositionComponent *) mPointer)->mInclusionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_additiveModalCompositionComponent::actualTypeName (void) const {
  return "C_additiveModalCompositionComponent" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_additiveModalCompositionComponent ("C_additiveModalCompositionComponent", gClassInfoFor__AC_machineDefinition, & kTypeDescriptor_GGS_C_additiveModalCompositionComponent) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_additiveModalCompositionComponent::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_additiveModalCompositionComponent * p = NULL ;
    macroMyNew (p, GGS_C_additiveModalCompositionComponent (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_additiveModalCompositionComponent GGS_C_additiveModalCompositionComponent::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_additiveModalCompositionComponent result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_additiveModalCompositionComponent * p = dynamic_cast <const GGS_C_additiveModalCompositionComponent *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_additiveModalCompositionComponent, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_additiveModalCompositionComponent::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_additiveModalCompositionComponent ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'cPtr_C_trans'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_trans::
cPtr_C_trans (const GGS_AC_boolExpression & argument_0,
                                const GGS_AC_boolExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mSourceStateExpression (argument_0),
mTargetStateExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_trans * GGS_C_trans::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_trans *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_trans *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_trans::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_trans * ptr = dynamic_cast <const cPtr_C_trans *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSourceStateExpression.operator_isEqual (ptr->mSourceStateExpression).boolValue ()
         && mTargetStateExpression.operator_isEqual (ptr->mTargetStateExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_trans::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_trans:"
           << mSourceStateExpression.reader_description (inIndentation + 1)
           << mTargetStateExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_trans::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_trans::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_trans (& typeid (cPtr_C_trans), & typeid (cPtr_AC_machineDefinition), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_trans::galgasRTTI (void) const {
  return & gClassInfoFor__C_trans ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_trans::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_trans (mSourceStateExpression, mTargetStateExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        GALGAS class 'GGS_C_trans'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_trans ("C_trans", true, & kTypeDescriptor_GGS_AC_machineDefinition) ;

//---------------------------------------------------------------------------*

GGS_C_trans::
GGS_C_trans (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_trans::
GGS_C_trans (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_trans GGS_C_trans::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_trans result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_trans *> (inPointer) != NULL)
      : (typeid (cPtr_C_trans) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_trans (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_trans),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_trans GGS_C_trans::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_AC_boolExpression & argument_0,
                 const GGS_AC_boolExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_trans result ;
  macroMyNew (result.mPointer, cPtr_C_trans (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_C_trans::
reader_mSourceStateExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_boolExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_trans *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_trans *) mPointer)->mSourceStateExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_C_trans::
reader_mTargetStateExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_boolExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_trans *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_trans *) mPointer)->mTargetStateExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_trans::actualTypeName (void) const {
  return "C_trans" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_trans ("C_trans", gClassInfoFor__AC_machineDefinition, & kTypeDescriptor_GGS_C_trans) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_trans::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_trans * p = NULL ;
    macroMyNew (p, GGS_C_trans (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_trans GGS_C_trans::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_trans result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_trans * p = dynamic_cast <const GGS_C_trans *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_trans, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_trans::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_trans ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_C_importMachine'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_importMachine::
cPtr_C_importMachine (const GGS_uint & argument_0,
                                const GGS_L_translationVector & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mIndexOfImportedMachine (argument_0),
mTranslationVector (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_importMachine * GGS_C_importMachine::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_importMachine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_importMachine *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_importMachine::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_importMachine * ptr = dynamic_cast <const cPtr_C_importMachine *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIndexOfImportedMachine.operator_isEqual (ptr->mIndexOfImportedMachine).boolValue ()
         && mTranslationVector.operator_isEqual (ptr->mTranslationVector).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_importMachine::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_importMachine:"
           << mIndexOfImportedMachine.reader_description (inIndentation + 1)
           << mTranslationVector.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_importMachine::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_importMachine::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_importMachine (& typeid (cPtr_C_importMachine), & typeid (cPtr_AC_machineDefinition), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_importMachine::galgasRTTI (void) const {
  return & gClassInfoFor__C_importMachine ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_importMachine::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_importMachine (mIndexOfImportedMachine, mTranslationVector COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_importMachine'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_importMachine ("C_importMachine", true, & kTypeDescriptor_GGS_AC_machineDefinition) ;

//---------------------------------------------------------------------------*

GGS_C_importMachine::
GGS_C_importMachine (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_importMachine::
GGS_C_importMachine (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_importMachine GGS_C_importMachine::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_importMachine result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_importMachine *> (inPointer) != NULL)
      : (typeid (cPtr_C_importMachine) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_importMachine (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_importMachine),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_importMachine GGS_C_importMachine::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_uint & argument_0,
                 const GGS_L_translationVector & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_importMachine result ;
  macroMyNew (result.mPointer, cPtr_C_importMachine (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_importMachine::
reader_mIndexOfImportedMachine (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_importMachine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_importMachine *) mPointer)->mIndexOfImportedMachine ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_translationVector  GGS_C_importMachine::
reader_mTranslationVector (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_translationVector   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_importMachine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_importMachine *) mPointer)->mTranslationVector ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_importMachine::actualTypeName (void) const {
  return "C_importMachine" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_importMachine ("C_importMachine", gClassInfoFor__AC_machineDefinition, & kTypeDescriptor_GGS_C_importMachine) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_importMachine::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_importMachine * p = NULL ;
    macroMyNew (p, GGS_C_importMachine (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_importMachine GGS_C_importMachine::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_importMachine result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_importMachine * p = dynamic_cast <const GGS_C_importMachine *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_importMachine, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_importMachine::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_importMachine ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_C_explicitAutomatonDefinition'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_explicitAutomatonDefinition::
cPtr_C_explicitAutomatonDefinition (const GGS_M_stateMap & argument_0,
                                const GGS_L_statesDefinitionList & argument_1,
                                const GGS_L_statesDefinitionList & argument_2,
                                const GGS_L_stateDefinition & argument_3,
                                const GGS_location & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mStatesMap (argument_0),
mInitialStatesDefinitionList (argument_1),
mTerminalStatesDefinitionList (argument_2),
mStateDefinitionList (argument_3),
mEndOfDefinition (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_explicitAutomatonDefinition * GGS_C_explicitAutomatonDefinition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_explicitAutomatonDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_explicitAutomatonDefinition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_explicitAutomatonDefinition::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_explicitAutomatonDefinition * ptr = dynamic_cast <const cPtr_C_explicitAutomatonDefinition *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStatesMap.operator_isEqual (ptr->mStatesMap).boolValue ()
         && mInitialStatesDefinitionList.operator_isEqual (ptr->mInitialStatesDefinitionList).boolValue ()
         && mTerminalStatesDefinitionList.operator_isEqual (ptr->mTerminalStatesDefinitionList).boolValue ()
         && mStateDefinitionList.operator_isEqual (ptr->mStateDefinitionList).boolValue ()
         && mEndOfDefinition.operator_isEqual (ptr->mEndOfDefinition).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_explicitAutomatonDefinition::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_explicitAutomatonDefinition:"
           << mStatesMap.reader_description (inIndentation + 1)
           << mInitialStatesDefinitionList.reader_description (inIndentation + 1)
           << mTerminalStatesDefinitionList.reader_description (inIndentation + 1)
           << mStateDefinitionList.reader_description (inIndentation + 1)
           << mEndOfDefinition.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_explicitAutomatonDefinition::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_explicitAutomatonDefinition::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_explicitAutomatonDefinition (& typeid (cPtr_C_explicitAutomatonDefinition), & typeid (cPtr_AC_machineDefinition), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_explicitAutomatonDefinition::galgasRTTI (void) const {
  return & gClassInfoFor__C_explicitAutomatonDefinition ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_explicitAutomatonDefinition::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_explicitAutomatonDefinition (mStatesMap, mInitialStatesDefinitionList, mTerminalStatesDefinitionList, mStateDefinitionList, mEndOfDefinition COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_C_explicitAutomatonDefinition'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_explicitAutomatonDefinition ("C_explicitAutomatonDefinition", true, & kTypeDescriptor_GGS_AC_machineDefinition) ;

//---------------------------------------------------------------------------*

GGS_C_explicitAutomatonDefinition::
GGS_C_explicitAutomatonDefinition (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_explicitAutomatonDefinition::
GGS_C_explicitAutomatonDefinition (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_explicitAutomatonDefinition GGS_C_explicitAutomatonDefinition::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_explicitAutomatonDefinition result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_explicitAutomatonDefinition *> (inPointer) != NULL)
      : (typeid (cPtr_C_explicitAutomatonDefinition) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_explicitAutomatonDefinition (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_explicitAutomatonDefinition),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_explicitAutomatonDefinition GGS_C_explicitAutomatonDefinition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_M_stateMap & argument_0,
                 const GGS_L_statesDefinitionList & argument_1,
                 const GGS_L_statesDefinitionList & argument_2,
                 const GGS_L_stateDefinition & argument_3,
                 const GGS_location & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_C_explicitAutomatonDefinition result ;
  macroMyNew (result.mPointer, cPtr_C_explicitAutomatonDefinition (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_stateMap  GGS_C_explicitAutomatonDefinition::
reader_mStatesMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_stateMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_explicitAutomatonDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_explicitAutomatonDefinition *) mPointer)->mStatesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_statesDefinitionList  GGS_C_explicitAutomatonDefinition::
reader_mInitialStatesDefinitionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_statesDefinitionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_explicitAutomatonDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_explicitAutomatonDefinition *) mPointer)->mInitialStatesDefinitionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_statesDefinitionList  GGS_C_explicitAutomatonDefinition::
reader_mTerminalStatesDefinitionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_statesDefinitionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_explicitAutomatonDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_explicitAutomatonDefinition *) mPointer)->mTerminalStatesDefinitionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_stateDefinition  GGS_C_explicitAutomatonDefinition::
reader_mStateDefinitionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_stateDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_explicitAutomatonDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_explicitAutomatonDefinition *) mPointer)->mStateDefinitionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_C_explicitAutomatonDefinition::
reader_mEndOfDefinition (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_explicitAutomatonDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_explicitAutomatonDefinition *) mPointer)->mEndOfDefinition ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_explicitAutomatonDefinition::actualTypeName (void) const {
  return "C_explicitAutomatonDefinition" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_explicitAutomatonDefinition ("C_explicitAutomatonDefinition", gClassInfoFor__AC_machineDefinition, & kTypeDescriptor_GGS_C_explicitAutomatonDefinition) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_explicitAutomatonDefinition::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_explicitAutomatonDefinition * p = NULL ;
    macroMyNew (p, GGS_C_explicitAutomatonDefinition (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_explicitAutomatonDefinition GGS_C_explicitAutomatonDefinition::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_explicitAutomatonDefinition result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_explicitAutomatonDefinition * p = dynamic_cast <const GGS_C_explicitAutomatonDefinition *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_explicitAutomatonDefinition, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_explicitAutomatonDefinition::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_explicitAutomatonDefinition ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_C_boolToSeqExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_boolToSeqExpression::
cPtr_C_boolToSeqExpression (const GGS_AC_boolExpression & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_boolToSeqExpression * GGS_C_boolToSeqExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_boolToSeqExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_boolToSeqExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_boolToSeqExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_boolToSeqExpression * ptr = dynamic_cast <const cPtr_C_boolToSeqExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_boolToSeqExpression::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_boolToSeqExpression:"
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_boolToSeqExpression::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_boolToSeqExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_boolToSeqExpression (& typeid (cPtr_C_boolToSeqExpression), & typeid (cPtr_AC_machineDefinition), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_boolToSeqExpression::galgasRTTI (void) const {
  return & gClassInfoFor__C_boolToSeqExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_boolToSeqExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_boolToSeqExpression (mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_boolToSeqExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_boolToSeqExpression ("C_boolToSeqExpression", true, & kTypeDescriptor_GGS_AC_machineDefinition) ;

//---------------------------------------------------------------------------*

GGS_C_boolToSeqExpression::
GGS_C_boolToSeqExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_boolToSeqExpression::
GGS_C_boolToSeqExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_boolToSeqExpression GGS_C_boolToSeqExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_boolToSeqExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_boolToSeqExpression *> (inPointer) != NULL)
      : (typeid (cPtr_C_boolToSeqExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_boolToSeqExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_boolToSeqExpression),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_boolToSeqExpression GGS_C_boolToSeqExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_AC_boolExpression & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_C_boolToSeqExpression result ;
  macroMyNew (result.mPointer, cPtr_C_boolToSeqExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_boolExpression  GGS_C_boolToSeqExpression::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_boolExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_boolToSeqExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_boolToSeqExpression *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_boolToSeqExpression::actualTypeName (void) const {
  return "C_boolToSeqExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_boolToSeqExpression ("C_boolToSeqExpression", gClassInfoFor__AC_machineDefinition, & kTypeDescriptor_GGS_C_boolToSeqExpression) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_boolToSeqExpression::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_boolToSeqExpression * p = NULL ;
    macroMyNew (p, GGS_C_boolToSeqExpression (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_boolToSeqExpression GGS_C_boolToSeqExpression::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_boolToSeqExpression result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_boolToSeqExpression * p = dynamic_cast <const GGS_C_boolToSeqExpression *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_boolToSeqExpression, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_boolToSeqExpression::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_boolToSeqExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_C_existsDefinition'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_existsDefinition::
cPtr_C_existsDefinition (const GGS_uint & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_AC_machineDefinition & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mPreviousVariableCount (argument_0),
mTotalVariableCount (argument_1),
mOperand (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_existsDefinition * GGS_C_existsDefinition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_existsDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_existsDefinition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_existsDefinition::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_existsDefinition * ptr = dynamic_cast <const cPtr_C_existsDefinition *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPreviousVariableCount.operator_isEqual (ptr->mPreviousVariableCount).boolValue ()
         && mTotalVariableCount.operator_isEqual (ptr->mTotalVariableCount).boolValue ()
         && mOperand.operator_isEqual (ptr->mOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_existsDefinition::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_existsDefinition:"
           << mPreviousVariableCount.reader_description (inIndentation + 1)
           << mTotalVariableCount.reader_description (inIndentation + 1)
           << mOperand.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_existsDefinition::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_existsDefinition::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_existsDefinition (& typeid (cPtr_C_existsDefinition), & typeid (cPtr_AC_machineDefinition), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_existsDefinition::galgasRTTI (void) const {
  return & gClassInfoFor__C_existsDefinition ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_existsDefinition::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_existsDefinition (mPreviousVariableCount, mTotalVariableCount, mOperand COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_existsDefinition'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_existsDefinition ("C_existsDefinition", true, & kTypeDescriptor_GGS_AC_machineDefinition) ;

//---------------------------------------------------------------------------*

GGS_C_existsDefinition::
GGS_C_existsDefinition (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_existsDefinition::
GGS_C_existsDefinition (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_existsDefinition GGS_C_existsDefinition::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_existsDefinition result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_existsDefinition *> (inPointer) != NULL)
      : (typeid (cPtr_C_existsDefinition) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_existsDefinition (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_existsDefinition),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_existsDefinition GGS_C_existsDefinition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_uint & argument_0,
                 const GGS_uint & argument_1,
                 const GGS_AC_machineDefinition & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_C_existsDefinition result ;
  macroMyNew (result.mPointer, cPtr_C_existsDefinition (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_existsDefinition::
reader_mPreviousVariableCount (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_existsDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_existsDefinition *) mPointer)->mPreviousVariableCount ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_existsDefinition::
reader_mTotalVariableCount (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_existsDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_existsDefinition *) mPointer)->mTotalVariableCount ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_existsDefinition::
reader_mOperand (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_existsDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_existsDefinition *) mPointer)->mOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_existsDefinition::actualTypeName (void) const {
  return "C_existsDefinition" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_existsDefinition ("C_existsDefinition", gClassInfoFor__AC_machineDefinition, & kTypeDescriptor_GGS_C_existsDefinition) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_existsDefinition::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_existsDefinition * p = NULL ;
    macroMyNew (p, GGS_C_existsDefinition (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_existsDefinition GGS_C_existsDefinition::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_existsDefinition result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_existsDefinition * p = dynamic_cast <const GGS_C_existsDefinition *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_existsDefinition, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_existsDefinition::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_existsDefinition ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_C_forallDefinition'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_forallDefinition::
cPtr_C_forallDefinition (const GGS_uint & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_AC_machineDefinition & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mPreviousVariableCount (argument_0),
mTotalVariableCount (argument_1),
mOperand (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_forallDefinition * GGS_C_forallDefinition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_forallDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_forallDefinition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_forallDefinition::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_forallDefinition * ptr = dynamic_cast <const cPtr_C_forallDefinition *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPreviousVariableCount.operator_isEqual (ptr->mPreviousVariableCount).boolValue ()
         && mTotalVariableCount.operator_isEqual (ptr->mTotalVariableCount).boolValue ()
         && mOperand.operator_isEqual (ptr->mOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_forallDefinition::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_forallDefinition:"
           << mPreviousVariableCount.reader_description (inIndentation + 1)
           << mTotalVariableCount.reader_description (inIndentation + 1)
           << mOperand.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_forallDefinition::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_forallDefinition::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_forallDefinition (& typeid (cPtr_C_forallDefinition), & typeid (cPtr_AC_machineDefinition), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_forallDefinition::galgasRTTI (void) const {
  return & gClassInfoFor__C_forallDefinition ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_forallDefinition::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_forallDefinition (mPreviousVariableCount, mTotalVariableCount, mOperand COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_forallDefinition'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_forallDefinition ("C_forallDefinition", true, & kTypeDescriptor_GGS_AC_machineDefinition) ;

//---------------------------------------------------------------------------*

GGS_C_forallDefinition::
GGS_C_forallDefinition (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_forallDefinition::
GGS_C_forallDefinition (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_forallDefinition GGS_C_forallDefinition::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_forallDefinition result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_forallDefinition *> (inPointer) != NULL)
      : (typeid (cPtr_C_forallDefinition) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_forallDefinition (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_forallDefinition),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_forallDefinition GGS_C_forallDefinition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_uint & argument_0,
                 const GGS_uint & argument_1,
                 const GGS_AC_machineDefinition & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_C_forallDefinition result ;
  macroMyNew (result.mPointer, cPtr_C_forallDefinition (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_forallDefinition::
reader_mPreviousVariableCount (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_forallDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_forallDefinition *) mPointer)->mPreviousVariableCount ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_forallDefinition::
reader_mTotalVariableCount (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_forallDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_forallDefinition *) mPointer)->mTotalVariableCount ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_forallDefinition::
reader_mOperand (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_forallDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_forallDefinition *) mPointer)->mOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_forallDefinition::actualTypeName (void) const {
  return "C_forallDefinition" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_forallDefinition ("C_forallDefinition", gClassInfoFor__AC_machineDefinition, & kTypeDescriptor_GGS_C_forallDefinition) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_forallDefinition::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_forallDefinition * p = NULL ;
    macroMyNew (p, GGS_C_forallDefinition (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_forallDefinition GGS_C_forallDefinition::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_forallDefinition result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_forallDefinition * p = dynamic_cast <const GGS_C_forallDefinition *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_forallDefinition, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_forallDefinition::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_forallDefinition ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_C_parallelComposition'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_parallelComposition::
cPtr_C_parallelComposition (const GGS_AC_machineDefinition & argument_0,
                                const GGS_AC_machineDefinition & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mLeftOperand (argument_0),
mRightOperand (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_parallelComposition * GGS_C_parallelComposition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parallelComposition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_parallelComposition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_parallelComposition::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_parallelComposition * ptr = dynamic_cast <const cPtr_C_parallelComposition *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftOperand.operator_isEqual (ptr->mLeftOperand).boolValue ()
         && mRightOperand.operator_isEqual (ptr->mRightOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_parallelComposition::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_parallelComposition:"
           << mLeftOperand.reader_description (inIndentation + 1)
           << mRightOperand.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_parallelComposition::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_parallelComposition::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_parallelComposition (& typeid (cPtr_C_parallelComposition), & typeid (cPtr_AC_machineDefinition), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_parallelComposition::galgasRTTI (void) const {
  return & gClassInfoFor__C_parallelComposition ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_parallelComposition::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_parallelComposition (mLeftOperand, mRightOperand COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_parallelComposition'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_parallelComposition ("C_parallelComposition", true, & kTypeDescriptor_GGS_AC_machineDefinition) ;

//---------------------------------------------------------------------------*

GGS_C_parallelComposition::
GGS_C_parallelComposition (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_parallelComposition::
GGS_C_parallelComposition (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_parallelComposition GGS_C_parallelComposition::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_parallelComposition result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_parallelComposition *> (inPointer) != NULL)
      : (typeid (cPtr_C_parallelComposition) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_parallelComposition (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_parallelComposition),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_parallelComposition GGS_C_parallelComposition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_AC_machineDefinition & argument_0,
                 const GGS_AC_machineDefinition & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_parallelComposition result ;
  macroMyNew (result.mPointer, cPtr_C_parallelComposition (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_parallelComposition::
reader_mLeftOperand (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parallelComposition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_parallelComposition *) mPointer)->mLeftOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_parallelComposition::
reader_mRightOperand (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parallelComposition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_parallelComposition *) mPointer)->mRightOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_parallelComposition::actualTypeName (void) const {
  return "C_parallelComposition" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_parallelComposition ("C_parallelComposition", gClassInfoFor__AC_machineDefinition, & kTypeDescriptor_GGS_C_parallelComposition) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_parallelComposition::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_parallelComposition * p = NULL ;
    macroMyNew (p, GGS_C_parallelComposition (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_parallelComposition GGS_C_parallelComposition::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_parallelComposition result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_parallelComposition * p = dynamic_cast <const GGS_C_parallelComposition *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_parallelComposition, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_parallelComposition::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_parallelComposition ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_C_orComposition'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_orComposition::
cPtr_C_orComposition (const GGS_AC_machineDefinition & argument_0,
                                const GGS_AC_machineDefinition & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mLeftOperand (argument_0),
mRightOperand (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_orComposition * GGS_C_orComposition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_orComposition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_orComposition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_orComposition::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_orComposition * ptr = dynamic_cast <const cPtr_C_orComposition *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftOperand.operator_isEqual (ptr->mLeftOperand).boolValue ()
         && mRightOperand.operator_isEqual (ptr->mRightOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_orComposition::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_orComposition:"
           << mLeftOperand.reader_description (inIndentation + 1)
           << mRightOperand.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_orComposition::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_orComposition::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_orComposition (& typeid (cPtr_C_orComposition), & typeid (cPtr_AC_machineDefinition), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_orComposition::galgasRTTI (void) const {
  return & gClassInfoFor__C_orComposition ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_orComposition::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_orComposition (mLeftOperand, mRightOperand COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_orComposition'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_orComposition ("C_orComposition", true, & kTypeDescriptor_GGS_AC_machineDefinition) ;

//---------------------------------------------------------------------------*

GGS_C_orComposition::
GGS_C_orComposition (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_orComposition::
GGS_C_orComposition (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_orComposition GGS_C_orComposition::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_orComposition result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_orComposition *> (inPointer) != NULL)
      : (typeid (cPtr_C_orComposition) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_orComposition (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_orComposition),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_orComposition GGS_C_orComposition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_AC_machineDefinition & argument_0,
                 const GGS_AC_machineDefinition & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_orComposition result ;
  macroMyNew (result.mPointer, cPtr_C_orComposition (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_orComposition::
reader_mLeftOperand (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_orComposition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_orComposition *) mPointer)->mLeftOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_orComposition::
reader_mRightOperand (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_orComposition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_orComposition *) mPointer)->mRightOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_orComposition::actualTypeName (void) const {
  return "C_orComposition" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_orComposition ("C_orComposition", gClassInfoFor__AC_machineDefinition, & kTypeDescriptor_GGS_C_orComposition) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_orComposition::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_orComposition * p = NULL ;
    macroMyNew (p, GGS_C_orComposition (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_orComposition GGS_C_orComposition::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_orComposition result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_orComposition * p = dynamic_cast <const GGS_C_orComposition *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_orComposition, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_orComposition::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_orComposition ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_C_strongModalComposition'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_strongModalComposition::
cPtr_C_strongModalComposition (const GGS_AC_machineDefinition & argument_0,
                                const GGS_location & argument_1,
                                const GGS_AC_machineDefinition & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mLeftOperand (argument_0),
mErrorLocation (argument_1),
mRightOperand (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_strongModalComposition * GGS_C_strongModalComposition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_strongModalComposition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_strongModalComposition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_strongModalComposition::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_strongModalComposition * ptr = dynamic_cast <const cPtr_C_strongModalComposition *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftOperand.operator_isEqual (ptr->mLeftOperand).boolValue ()
         && mErrorLocation.operator_isEqual (ptr->mErrorLocation).boolValue ()
         && mRightOperand.operator_isEqual (ptr->mRightOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_strongModalComposition::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_strongModalComposition:"
           << mLeftOperand.reader_description (inIndentation + 1)
           << mErrorLocation.reader_description (inIndentation + 1)
           << mRightOperand.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_strongModalComposition::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_strongModalComposition::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_strongModalComposition (& typeid (cPtr_C_strongModalComposition), & typeid (cPtr_AC_machineDefinition), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_strongModalComposition::galgasRTTI (void) const {
  return & gClassInfoFor__C_strongModalComposition ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_strongModalComposition::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_strongModalComposition (mLeftOperand, mErrorLocation, mRightOperand COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_C_strongModalComposition'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_strongModalComposition ("C_strongModalComposition", true, & kTypeDescriptor_GGS_AC_machineDefinition) ;

//---------------------------------------------------------------------------*

GGS_C_strongModalComposition::
GGS_C_strongModalComposition (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_strongModalComposition::
GGS_C_strongModalComposition (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_strongModalComposition GGS_C_strongModalComposition::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_strongModalComposition result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_strongModalComposition *> (inPointer) != NULL)
      : (typeid (cPtr_C_strongModalComposition) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_strongModalComposition (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_strongModalComposition),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_strongModalComposition GGS_C_strongModalComposition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_AC_machineDefinition & argument_0,
                 const GGS_location & argument_1,
                 const GGS_AC_machineDefinition & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_C_strongModalComposition result ;
  macroMyNew (result.mPointer, cPtr_C_strongModalComposition (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_strongModalComposition::
reader_mLeftOperand (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_strongModalComposition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_strongModalComposition *) mPointer)->mLeftOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_C_strongModalComposition::
reader_mErrorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_strongModalComposition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_strongModalComposition *) mPointer)->mErrorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_strongModalComposition::
reader_mRightOperand (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_strongModalComposition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_strongModalComposition *) mPointer)->mRightOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_strongModalComposition::actualTypeName (void) const {
  return "C_strongModalComposition" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_strongModalComposition ("C_strongModalComposition", gClassInfoFor__AC_machineDefinition, & kTypeDescriptor_GGS_C_strongModalComposition) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_strongModalComposition::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_strongModalComposition * p = NULL ;
    macroMyNew (p, GGS_C_strongModalComposition (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_strongModalComposition GGS_C_strongModalComposition::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_strongModalComposition result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_strongModalComposition * p = dynamic_cast <const GGS_C_strongModalComposition *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_strongModalComposition, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_strongModalComposition::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_strongModalComposition ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_C_weakModalComposition'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_weakModalComposition::
cPtr_C_weakModalComposition (const GGS_AC_machineDefinition & argument_0,
                                const GGS_location & argument_1,
                                const GGS_AC_machineDefinition & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mLeftOperand (argument_0),
mErrorLocation (argument_1),
mRightOperand (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_weakModalComposition * GGS_C_weakModalComposition::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_weakModalComposition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_weakModalComposition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_weakModalComposition::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_weakModalComposition * ptr = dynamic_cast <const cPtr_C_weakModalComposition *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftOperand.operator_isEqual (ptr->mLeftOperand).boolValue ()
         && mErrorLocation.operator_isEqual (ptr->mErrorLocation).boolValue ()
         && mRightOperand.operator_isEqual (ptr->mRightOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_weakModalComposition::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_weakModalComposition:"
           << mLeftOperand.reader_description (inIndentation + 1)
           << mErrorLocation.reader_description (inIndentation + 1)
           << mRightOperand.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_weakModalComposition::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_weakModalComposition::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_weakModalComposition (& typeid (cPtr_C_weakModalComposition), & typeid (cPtr_AC_machineDefinition), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_weakModalComposition::galgasRTTI (void) const {
  return & gClassInfoFor__C_weakModalComposition ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_weakModalComposition::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_weakModalComposition (mLeftOperand, mErrorLocation, mRightOperand COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_weakModalComposition'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_weakModalComposition ("C_weakModalComposition", true, & kTypeDescriptor_GGS_AC_machineDefinition) ;

//---------------------------------------------------------------------------*

GGS_C_weakModalComposition::
GGS_C_weakModalComposition (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_weakModalComposition::
GGS_C_weakModalComposition (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_weakModalComposition GGS_C_weakModalComposition::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_weakModalComposition result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_weakModalComposition *> (inPointer) != NULL)
      : (typeid (cPtr_C_weakModalComposition) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_weakModalComposition (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_weakModalComposition),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_weakModalComposition GGS_C_weakModalComposition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_AC_machineDefinition & argument_0,
                 const GGS_location & argument_1,
                 const GGS_AC_machineDefinition & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_C_weakModalComposition result ;
  macroMyNew (result.mPointer, cPtr_C_weakModalComposition (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_weakModalComposition::
reader_mLeftOperand (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_weakModalComposition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_weakModalComposition *) mPointer)->mLeftOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_C_weakModalComposition::
reader_mErrorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_weakModalComposition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_weakModalComposition *) mPointer)->mErrorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_weakModalComposition::
reader_mRightOperand (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_weakModalComposition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_weakModalComposition *) mPointer)->mRightOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_weakModalComposition::actualTypeName (void) const {
  return "C_weakModalComposition" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_weakModalComposition ("C_weakModalComposition", gClassInfoFor__AC_machineDefinition, & kTypeDescriptor_GGS_C_weakModalComposition) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_weakModalComposition::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_weakModalComposition * p = NULL ;
    macroMyNew (p, GGS_C_weakModalComposition (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_weakModalComposition GGS_C_weakModalComposition::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_weakModalComposition result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_weakModalComposition * p = dynamic_cast <const GGS_C_weakModalComposition *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_weakModalComposition, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_weakModalComposition::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_weakModalComposition ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_C_fullSaturationOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_fullSaturationOperation::
cPtr_C_fullSaturationOperation (const GGS_AC_machineDefinition & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mOperand (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_fullSaturationOperation * GGS_C_fullSaturationOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_fullSaturationOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_fullSaturationOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_fullSaturationOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_fullSaturationOperation * ptr = dynamic_cast <const cPtr_C_fullSaturationOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperand.operator_isEqual (ptr->mOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_fullSaturationOperation::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_fullSaturationOperation:"
           << mOperand.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_fullSaturationOperation::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_fullSaturationOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_fullSaturationOperation (& typeid (cPtr_C_fullSaturationOperation), & typeid (cPtr_AC_machineDefinition), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_fullSaturationOperation::galgasRTTI (void) const {
  return & gClassInfoFor__C_fullSaturationOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_fullSaturationOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_fullSaturationOperation (mOperand COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_C_fullSaturationOperation'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_fullSaturationOperation ("C_fullSaturationOperation", true, & kTypeDescriptor_GGS_AC_machineDefinition) ;

//---------------------------------------------------------------------------*

GGS_C_fullSaturationOperation::
GGS_C_fullSaturationOperation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_fullSaturationOperation::
GGS_C_fullSaturationOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_fullSaturationOperation GGS_C_fullSaturationOperation::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_fullSaturationOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_fullSaturationOperation *> (inPointer) != NULL)
      : (typeid (cPtr_C_fullSaturationOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_fullSaturationOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_fullSaturationOperation),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_fullSaturationOperation GGS_C_fullSaturationOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_AC_machineDefinition & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_C_fullSaturationOperation result ;
  macroMyNew (result.mPointer, cPtr_C_fullSaturationOperation (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_fullSaturationOperation::
reader_mOperand (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_fullSaturationOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_fullSaturationOperation *) mPointer)->mOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_fullSaturationOperation::actualTypeName (void) const {
  return "C_fullSaturationOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_fullSaturationOperation ("C_fullSaturationOperation", gClassInfoFor__AC_machineDefinition, & kTypeDescriptor_GGS_C_fullSaturationOperation) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_fullSaturationOperation::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_fullSaturationOperation * p = NULL ;
    macroMyNew (p, GGS_C_fullSaturationOperation (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_fullSaturationOperation GGS_C_fullSaturationOperation::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_fullSaturationOperation result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_fullSaturationOperation * p = dynamic_cast <const GGS_C_fullSaturationOperation *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_fullSaturationOperation, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_fullSaturationOperation::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_fullSaturationOperation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_C_complementationOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_complementationOperation::
cPtr_C_complementationOperation (const GGS_AC_machineDefinition & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mOperand (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_complementationOperation * GGS_C_complementationOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_complementationOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_complementationOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_complementationOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_complementationOperation * ptr = dynamic_cast <const cPtr_C_complementationOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperand.operator_isEqual (ptr->mOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_complementationOperation::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_complementationOperation:"
           << mOperand.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_complementationOperation::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_complementationOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_complementationOperation (& typeid (cPtr_C_complementationOperation), & typeid (cPtr_AC_machineDefinition), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_complementationOperation::galgasRTTI (void) const {
  return & gClassInfoFor__C_complementationOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_complementationOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_complementationOperation (mOperand COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_C_complementationOperation'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_complementationOperation ("C_complementationOperation", true, & kTypeDescriptor_GGS_AC_machineDefinition) ;

//---------------------------------------------------------------------------*

GGS_C_complementationOperation::
GGS_C_complementationOperation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_complementationOperation::
GGS_C_complementationOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_complementationOperation GGS_C_complementationOperation::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_complementationOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_complementationOperation *> (inPointer) != NULL)
      : (typeid (cPtr_C_complementationOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_complementationOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_complementationOperation),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_complementationOperation GGS_C_complementationOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_AC_machineDefinition & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_C_complementationOperation result ;
  macroMyNew (result.mPointer, cPtr_C_complementationOperation (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_complementationOperation::
reader_mOperand (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_complementationOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_complementationOperation *) mPointer)->mOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_complementationOperation::actualTypeName (void) const {
  return "C_complementationOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_complementationOperation ("C_complementationOperation", gClassInfoFor__AC_machineDefinition, & kTypeDescriptor_GGS_C_complementationOperation) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_complementationOperation::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_complementationOperation * p = NULL ;
    macroMyNew (p, GGS_C_complementationOperation (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_complementationOperation GGS_C_complementationOperation::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_complementationOperation result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_complementationOperation * p = dynamic_cast <const GGS_C_complementationOperation *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_complementationOperation, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_complementationOperation::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_complementationOperation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_C_suppressTerminalStatesOperation'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_suppressTerminalStatesOperation::
cPtr_C_suppressTerminalStatesOperation (const GGS_AC_machineDefinition & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mOperand (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_suppressTerminalStatesOperation * GGS_C_suppressTerminalStatesOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_suppressTerminalStatesOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_suppressTerminalStatesOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_suppressTerminalStatesOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_suppressTerminalStatesOperation * ptr = dynamic_cast <const cPtr_C_suppressTerminalStatesOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperand.operator_isEqual (ptr->mOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_suppressTerminalStatesOperation::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_suppressTerminalStatesOperation:"
           << mOperand.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_suppressTerminalStatesOperation::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_suppressTerminalStatesOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_suppressTerminalStatesOperation (& typeid (cPtr_C_suppressTerminalStatesOperation), & typeid (cPtr_AC_machineDefinition), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_suppressTerminalStatesOperation::galgasRTTI (void) const {
  return & gClassInfoFor__C_suppressTerminalStatesOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_suppressTerminalStatesOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_suppressTerminalStatesOperation (mOperand COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_C_suppressTerminalStatesOperation'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_suppressTerminalStatesOperation ("C_suppressTerminalStatesOperation", true, & kTypeDescriptor_GGS_AC_machineDefinition) ;

//---------------------------------------------------------------------------*

GGS_C_suppressTerminalStatesOperation::
GGS_C_suppressTerminalStatesOperation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_suppressTerminalStatesOperation::
GGS_C_suppressTerminalStatesOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_suppressTerminalStatesOperation GGS_C_suppressTerminalStatesOperation::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_suppressTerminalStatesOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_suppressTerminalStatesOperation *> (inPointer) != NULL)
      : (typeid (cPtr_C_suppressTerminalStatesOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_suppressTerminalStatesOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_suppressTerminalStatesOperation),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_suppressTerminalStatesOperation GGS_C_suppressTerminalStatesOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_AC_machineDefinition & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_C_suppressTerminalStatesOperation result ;
  macroMyNew (result.mPointer, cPtr_C_suppressTerminalStatesOperation (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_suppressTerminalStatesOperation::
reader_mOperand (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_suppressTerminalStatesOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_suppressTerminalStatesOperation *) mPointer)->mOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_suppressTerminalStatesOperation::actualTypeName (void) const {
  return "C_suppressTerminalStatesOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_suppressTerminalStatesOperation ("C_suppressTerminalStatesOperation", gClassInfoFor__AC_machineDefinition, & kTypeDescriptor_GGS_C_suppressTerminalStatesOperation) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_suppressTerminalStatesOperation::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_suppressTerminalStatesOperation * p = NULL ;
    macroMyNew (p, GGS_C_suppressTerminalStatesOperation (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_suppressTerminalStatesOperation GGS_C_suppressTerminalStatesOperation::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_suppressTerminalStatesOperation result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_suppressTerminalStatesOperation * p = dynamic_cast <const GGS_C_suppressTerminalStatesOperation *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_suppressTerminalStatesOperation, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_suppressTerminalStatesOperation::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_suppressTerminalStatesOperation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_C_suppressInitialStatesOperation'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_suppressInitialStatesOperation::
cPtr_C_suppressInitialStatesOperation (const GGS_AC_machineDefinition & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_machineDefinition (THERE),
mOperand (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_suppressInitialStatesOperation * GGS_C_suppressInitialStatesOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_suppressInitialStatesOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_suppressInitialStatesOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_suppressInitialStatesOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_suppressInitialStatesOperation * ptr = dynamic_cast <const cPtr_C_suppressInitialStatesOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperand.operator_isEqual (ptr->mOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_suppressInitialStatesOperation::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_suppressInitialStatesOperation:"
           << mOperand.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_suppressInitialStatesOperation::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_suppressInitialStatesOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_suppressInitialStatesOperation (& typeid (cPtr_C_suppressInitialStatesOperation), & typeid (cPtr_AC_machineDefinition), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_suppressInitialStatesOperation::galgasRTTI (void) const {
  return & gClassInfoFor__C_suppressInitialStatesOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_suppressInitialStatesOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_suppressInitialStatesOperation (mOperand COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_C_suppressInitialStatesOperation'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_suppressInitialStatesOperation ("C_suppressInitialStatesOperation", true, & kTypeDescriptor_GGS_AC_machineDefinition) ;

//---------------------------------------------------------------------------*

GGS_C_suppressInitialStatesOperation::
GGS_C_suppressInitialStatesOperation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_suppressInitialStatesOperation::
GGS_C_suppressInitialStatesOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_suppressInitialStatesOperation GGS_C_suppressInitialStatesOperation::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_suppressInitialStatesOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_suppressInitialStatesOperation *> (inPointer) != NULL)
      : (typeid (cPtr_C_suppressInitialStatesOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_suppressInitialStatesOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_suppressInitialStatesOperation),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_suppressInitialStatesOperation GGS_C_suppressInitialStatesOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_AC_machineDefinition & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_C_suppressInitialStatesOperation result ;
  macroMyNew (result.mPointer, cPtr_C_suppressInitialStatesOperation (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_suppressInitialStatesOperation::
reader_mOperand (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_suppressInitialStatesOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_suppressInitialStatesOperation *) mPointer)->mOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_suppressInitialStatesOperation::actualTypeName (void) const {
  return "C_suppressInitialStatesOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_suppressInitialStatesOperation ("C_suppressInitialStatesOperation", gClassInfoFor__AC_machineDefinition, & kTypeDescriptor_GGS_C_suppressInitialStatesOperation) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_suppressInitialStatesOperation::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_suppressInitialStatesOperation * p = NULL ;
    macroMyNew (p, GGS_C_suppressInitialStatesOperation (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_suppressInitialStatesOperation GGS_C_suppressInitialStatesOperation::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_suppressInitialStatesOperation result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_suppressInitialStatesOperation * p = dynamic_cast <const GGS_C_suppressInitialStatesOperation *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_suppressInitialStatesOperation, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_suppressInitialStatesOperation::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_suppressInitialStatesOperation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'cPtr_AC_job'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_job::
cPtr_AC_job (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_job * GGS_AC_job::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_AC_job *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_AC_job *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_AC_job::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@AC_job:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_AC_job::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_job::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_AC_job (& typeid (cPtr_AC_job), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_AC_job::galgasRTTI (void) const {
  return & gClassInfoFor__AC_job ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        GALGAS class 'GGS_AC_job'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_AC_job ("AC_job", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_AC_job::
GGS_AC_job (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_job::
GGS_AC_job (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_AC_job GGS_AC_job::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_AC_job result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_AC_job *> (inPointer) != NULL)
      : (typeid (cPtr_AC_job) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_AC_job (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_AC_job),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_AC_job::actualTypeName (void) const {
  return "AC_job" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_AC_job::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__AC_job ("AC_job", & kTypeDescriptor_GGS_AC_job) ;

//---------------------------------------------------------------------------*

GGS_object GGS_AC_job::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_AC_job * p = NULL ;
    macroMyNew (p, GGS_AC_job (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_job GGS_AC_job::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_AC_job result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_AC_job * p = dynamic_cast <const GGS_AC_job *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_AC_job, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_AC_job::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_AC_job ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_C_machineCheck'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_machineCheck::
cPtr_C_machineCheck (const GGS_uint & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_AC_job (THERE),
mMachineIndex (argument_0),
mCheckMachineIsBoolean (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_machineCheck * GGS_C_machineCheck::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineCheck *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_machineCheck *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_machineCheck::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_machineCheck * ptr = dynamic_cast <const cPtr_C_machineCheck *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMachineIndex.operator_isEqual (ptr->mMachineIndex).boolValue ()
         && mCheckMachineIsBoolean.operator_isEqual (ptr->mCheckMachineIsBoolean).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_machineCheck::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_machineCheck:"
           << mMachineIndex.reader_description (inIndentation + 1)
           << mCheckMachineIsBoolean.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_machineCheck::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_machineCheck::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_machineCheck (& typeid (cPtr_C_machineCheck), & typeid (cPtr_AC_job), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_machineCheck::galgasRTTI (void) const {
  return & gClassInfoFor__C_machineCheck ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_machineCheck::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_machineCheck (mMachineIndex, mCheckMachineIsBoolean COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_machineCheck'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_machineCheck ("C_machineCheck", true, & kTypeDescriptor_GGS_AC_job) ;

//---------------------------------------------------------------------------*

GGS_C_machineCheck::
GGS_C_machineCheck (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_machineCheck::
GGS_C_machineCheck (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_machineCheck GGS_C_machineCheck::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_machineCheck result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_machineCheck *> (inPointer) != NULL)
      : (typeid (cPtr_C_machineCheck) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_machineCheck (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_machineCheck),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_machineCheck GGS_C_machineCheck::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_uint & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_machineCheck result ;
  macroMyNew (result.mPointer, cPtr_C_machineCheck (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_machineCheck::
reader_mMachineIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineCheck *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineCheck *) mPointer)->mMachineIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_machineCheck::
reader_mCheckMachineIsBoolean (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineCheck *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineCheck *) mPointer)->mCheckMachineIsBoolean ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_machineCheck::actualTypeName (void) const {
  return "C_machineCheck" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_machineCheck ("C_machineCheck", gClassInfoFor__AC_job, & kTypeDescriptor_GGS_C_machineCheck) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_machineCheck::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_machineCheck * p = NULL ;
    macroMyNew (p, GGS_C_machineCheck (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_machineCheck GGS_C_machineCheck::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_machineCheck result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_machineCheck * p = dynamic_cast <const GGS_C_machineCheck *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_machineCheck, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_machineCheck::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_machineCheck ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_C_machineCheckIdentical'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_machineCheckIdentical::
cPtr_C_machineCheckIdentical (const GGS_uint & argument_0,
                                const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_AC_job (THERE),
mMachineIndex1 (argument_0),
mMachineIndex2 (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_machineCheckIdentical * GGS_C_machineCheckIdentical::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineCheckIdentical *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_machineCheckIdentical *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_machineCheckIdentical::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_machineCheckIdentical * ptr = dynamic_cast <const cPtr_C_machineCheckIdentical *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMachineIndex1.operator_isEqual (ptr->mMachineIndex1).boolValue ()
         && mMachineIndex2.operator_isEqual (ptr->mMachineIndex2).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_machineCheckIdentical::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_machineCheckIdentical:"
           << mMachineIndex1.reader_description (inIndentation + 1)
           << mMachineIndex2.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_machineCheckIdentical::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_machineCheckIdentical::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_machineCheckIdentical (& typeid (cPtr_C_machineCheckIdentical), & typeid (cPtr_AC_job), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_machineCheckIdentical::galgasRTTI (void) const {
  return & gClassInfoFor__C_machineCheckIdentical ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_machineCheckIdentical::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_machineCheckIdentical (mMachineIndex1, mMachineIndex2 COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_machineCheckIdentical'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_machineCheckIdentical ("C_machineCheckIdentical", true, & kTypeDescriptor_GGS_AC_job) ;

//---------------------------------------------------------------------------*

GGS_C_machineCheckIdentical::
GGS_C_machineCheckIdentical (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_machineCheckIdentical::
GGS_C_machineCheckIdentical (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_machineCheckIdentical GGS_C_machineCheckIdentical::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_machineCheckIdentical result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_machineCheckIdentical *> (inPointer) != NULL)
      : (typeid (cPtr_C_machineCheckIdentical) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_machineCheckIdentical (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_machineCheckIdentical),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_machineCheckIdentical GGS_C_machineCheckIdentical::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_uint & argument_0,
                 const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_machineCheckIdentical result ;
  macroMyNew (result.mPointer, cPtr_C_machineCheckIdentical (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_machineCheckIdentical::
reader_mMachineIndex1 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineCheckIdentical *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineCheckIdentical *) mPointer)->mMachineIndex1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_machineCheckIdentical::
reader_mMachineIndex2 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineCheckIdentical *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineCheckIdentical *) mPointer)->mMachineIndex2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_machineCheckIdentical::actualTypeName (void) const {
  return "C_machineCheckIdentical" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_machineCheckIdentical ("C_machineCheckIdentical", gClassInfoFor__AC_job, & kTypeDescriptor_GGS_C_machineCheckIdentical) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_machineCheckIdentical::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_machineCheckIdentical * p = NULL ;
    macroMyNew (p, GGS_C_machineCheckIdentical (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_machineCheckIdentical GGS_C_machineCheckIdentical::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_machineCheckIdentical result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_machineCheckIdentical * p = dynamic_cast <const GGS_C_machineCheckIdentical *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_machineCheckIdentical, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_machineCheckIdentical::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_machineCheckIdentical ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_C_machineComponent'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_machineComponent::
cPtr_C_machineComponent (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_uint & argument_2,
                                const GGS_uint & argument_3,
                                const GGS_M_variablesMap & argument_4,
                                const GGS_AC_machineDefinition & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_AC_job (THERE),
mMachineName (argument_0),
mMachineIndex (argument_1),
mInputVariableCount (argument_2),
mInputAndInternalVariableCount (argument_3),
mVariablesMap (argument_4),
mDefinition (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_machineComponent * GGS_C_machineComponent::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_machineComponent *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_machineComponent::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_machineComponent * ptr = dynamic_cast <const cPtr_C_machineComponent *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMachineName.operator_isEqual (ptr->mMachineName).boolValue ()
         && mMachineIndex.operator_isEqual (ptr->mMachineIndex).boolValue ()
         && mInputVariableCount.operator_isEqual (ptr->mInputVariableCount).boolValue ()
         && mInputAndInternalVariableCount.operator_isEqual (ptr->mInputAndInternalVariableCount).boolValue ()
         && mVariablesMap.operator_isEqual (ptr->mVariablesMap).boolValue ()
         && mDefinition.operator_isEqual (ptr->mDefinition).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_machineComponent::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_machineComponent:"
           << mMachineName.reader_description (inIndentation + 1)
           << mMachineIndex.reader_description (inIndentation + 1)
           << mInputVariableCount.reader_description (inIndentation + 1)
           << mInputAndInternalVariableCount.reader_description (inIndentation + 1)
           << mVariablesMap.reader_description (inIndentation + 1)
           << mDefinition.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_machineComponent::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_machineComponent::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_machineComponent (& typeid (cPtr_C_machineComponent), & typeid (cPtr_AC_job), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_machineComponent::galgasRTTI (void) const {
  return & gClassInfoFor__C_machineComponent ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_machineComponent::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_machineComponent (mMachineName, mMachineIndex, mInputVariableCount, mInputAndInternalVariableCount, mVariablesMap, mDefinition COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_machineComponent'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_machineComponent ("C_machineComponent", true, & kTypeDescriptor_GGS_AC_job) ;

//---------------------------------------------------------------------------*

GGS_C_machineComponent::
GGS_C_machineComponent (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_machineComponent::
GGS_C_machineComponent (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_machineComponent GGS_C_machineComponent::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_machineComponent result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_machineComponent *> (inPointer) != NULL)
      : (typeid (cPtr_C_machineComponent) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_machineComponent (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_machineComponent),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_machineComponent GGS_C_machineComponent::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_uint & argument_1,
                 const GGS_uint & argument_2,
                 const GGS_uint & argument_3,
                 const GGS_M_variablesMap & argument_4,
                 const GGS_AC_machineDefinition & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_C_machineComponent result ;
  macroMyNew (result.mPointer, cPtr_C_machineComponent (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_machineComponent::
reader_mMachineName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineComponent *) mPointer)->mMachineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_machineComponent::
reader_mMachineIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineComponent *) mPointer)->mMachineIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_machineComponent::
reader_mInputVariableCount (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineComponent *) mPointer)->mInputVariableCount ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_machineComponent::
reader_mInputAndInternalVariableCount (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineComponent *) mPointer)->mInputAndInternalVariableCount ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_variablesMap  GGS_C_machineComponent::
reader_mVariablesMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_variablesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineComponent *) mPointer)->mVariablesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition  GGS_C_machineComponent::
reader_mDefinition (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_machineDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineComponent *) mPointer)->mDefinition ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_machineComponent::actualTypeName (void) const {
  return "C_machineComponent" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_machineComponent ("C_machineComponent", gClassInfoFor__AC_job, & kTypeDescriptor_GGS_C_machineComponent) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_machineComponent::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_machineComponent * p = NULL ;
    macroMyNew (p, GGS_C_machineComponent (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_machineComponent GGS_C_machineComponent::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_machineComponent result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_machineComponent * p = dynamic_cast <const GGS_C_machineComponent *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_machineComponent, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_machineComponent::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_machineComponent ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_C_machineDefinedByAdditiveModalComp'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_machineDefinedByAdditiveModalComp::
cPtr_C_machineDefinedByAdditiveModalComp (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_uint & argument_2,
                                const GGS_uint & argument_3,
                                const GGS_M_variablesMap & argument_4,
                                const GGS_M_modesMap & argument_5,
                                const GGS_ListForModes & argument_6
                                COMMA_LOCATION_ARGS)
:cPtr_AC_job (THERE),
mMachineName (argument_0),
mMachineIndex (argument_1),
mInputVariableCount (argument_2),
mInputAndInternalVariableCount (argument_3),
mVariablesMap (argument_4),
mModeMap (argument_5),
mInclusionList (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_machineDefinedByAdditiveModalComp * GGS_C_machineDefinedByAdditiveModalComp::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedByAdditiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_machineDefinedByAdditiveModalComp *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_machineDefinedByAdditiveModalComp::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_machineDefinedByAdditiveModalComp * ptr = dynamic_cast <const cPtr_C_machineDefinedByAdditiveModalComp *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMachineName.operator_isEqual (ptr->mMachineName).boolValue ()
         && mMachineIndex.operator_isEqual (ptr->mMachineIndex).boolValue ()
         && mInputVariableCount.operator_isEqual (ptr->mInputVariableCount).boolValue ()
         && mInputAndInternalVariableCount.operator_isEqual (ptr->mInputAndInternalVariableCount).boolValue ()
         && mVariablesMap.operator_isEqual (ptr->mVariablesMap).boolValue ()
         && mModeMap.operator_isEqual (ptr->mModeMap).boolValue ()
         && mInclusionList.operator_isEqual (ptr->mInclusionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_machineDefinedByAdditiveModalComp::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_machineDefinedByAdditiveModalComp:"
           << mMachineName.reader_description (inIndentation + 1)
           << mMachineIndex.reader_description (inIndentation + 1)
           << mInputVariableCount.reader_description (inIndentation + 1)
           << mInputAndInternalVariableCount.reader_description (inIndentation + 1)
           << mVariablesMap.reader_description (inIndentation + 1)
           << mModeMap.reader_description (inIndentation + 1)
           << mInclusionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_machineDefinedByAdditiveModalComp::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_machineDefinedByAdditiveModalComp::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_machineDefinedByAdditiveModalComp (& typeid (cPtr_C_machineDefinedByAdditiveModalComp), & typeid (cPtr_AC_job), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_machineDefinedByAdditiveModalComp::galgasRTTI (void) const {
  return & gClassInfoFor__C_machineDefinedByAdditiveModalComp ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_machineDefinedByAdditiveModalComp::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_machineDefinedByAdditiveModalComp (mMachineName, mMachineIndex, mInputVariableCount, mInputAndInternalVariableCount, mVariablesMap, mModeMap, mInclusionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_C_machineDefinedByAdditiveModalComp'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_machineDefinedByAdditiveModalComp ("C_machineDefinedByAdditiveModalComp", true, & kTypeDescriptor_GGS_AC_job) ;

//---------------------------------------------------------------------------*

GGS_C_machineDefinedByAdditiveModalComp::
GGS_C_machineDefinedByAdditiveModalComp (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_machineDefinedByAdditiveModalComp::
GGS_C_machineDefinedByAdditiveModalComp (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_machineDefinedByAdditiveModalComp GGS_C_machineDefinedByAdditiveModalComp::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_machineDefinedByAdditiveModalComp result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_machineDefinedByAdditiveModalComp *> (inPointer) != NULL)
      : (typeid (cPtr_C_machineDefinedByAdditiveModalComp) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_machineDefinedByAdditiveModalComp (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_machineDefinedByAdditiveModalComp),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_machineDefinedByAdditiveModalComp GGS_C_machineDefinedByAdditiveModalComp::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_uint & argument_1,
                 const GGS_uint & argument_2,
                 const GGS_uint & argument_3,
                 const GGS_M_variablesMap & argument_4,
                 const GGS_M_modesMap & argument_5,
                 const GGS_ListForModes & argument_6
                                COMMA_LOCATION_ARGS) {
  GGS_C_machineDefinedByAdditiveModalComp result ;
  macroMyNew (result.mPointer, cPtr_C_machineDefinedByAdditiveModalComp (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_machineDefinedByAdditiveModalComp::
reader_mMachineName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedByAdditiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineDefinedByAdditiveModalComp *) mPointer)->mMachineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_machineDefinedByAdditiveModalComp::
reader_mMachineIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedByAdditiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineDefinedByAdditiveModalComp *) mPointer)->mMachineIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_machineDefinedByAdditiveModalComp::
reader_mInputVariableCount (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedByAdditiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineDefinedByAdditiveModalComp *) mPointer)->mInputVariableCount ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_machineDefinedByAdditiveModalComp::
reader_mInputAndInternalVariableCount (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedByAdditiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineDefinedByAdditiveModalComp *) mPointer)->mInputAndInternalVariableCount ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_variablesMap  GGS_C_machineDefinedByAdditiveModalComp::
reader_mVariablesMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_variablesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedByAdditiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineDefinedByAdditiveModalComp *) mPointer)->mVariablesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_modesMap  GGS_C_machineDefinedByAdditiveModalComp::
reader_mModeMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_modesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedByAdditiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineDefinedByAdditiveModalComp *) mPointer)->mModeMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ListForModes  GGS_C_machineDefinedByAdditiveModalComp::
reader_mInclusionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ListForModes   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedByAdditiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineDefinedByAdditiveModalComp *) mPointer)->mInclusionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_machineDefinedByAdditiveModalComp::actualTypeName (void) const {
  return "C_machineDefinedByAdditiveModalComp" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_machineDefinedByAdditiveModalComp ("C_machineDefinedByAdditiveModalComp", gClassInfoFor__AC_job, & kTypeDescriptor_GGS_C_machineDefinedByAdditiveModalComp) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_machineDefinedByAdditiveModalComp::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_machineDefinedByAdditiveModalComp * p = NULL ;
    macroMyNew (p, GGS_C_machineDefinedByAdditiveModalComp (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_machineDefinedByAdditiveModalComp GGS_C_machineDefinedByAdditiveModalComp::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_machineDefinedByAdditiveModalComp result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_machineDefinedByAdditiveModalComp * p = dynamic_cast <const GGS_C_machineDefinedByAdditiveModalComp *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_machineDefinedByAdditiveModalComp, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_machineDefinedByAdditiveModalComp::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_machineDefinedByAdditiveModalComp ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'cPtr_C_machineDefinedBySubstractiveModalComp'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_machineDefinedBySubstractiveModalComp::
cPtr_C_machineDefinedBySubstractiveModalComp (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_uint & argument_2,
                                const GGS_uint & argument_3,
                                const GGS_M_variablesMap & argument_4,
                                const GGS_M_modesMap & argument_5,
                                const GGS_ListForModes & argument_6
                                COMMA_LOCATION_ARGS)
:cPtr_AC_job (THERE),
mMachineName (argument_0),
mMachineIndex (argument_1),
mInputVariableCount (argument_2),
mInputAndInternalVariableCount (argument_3),
mVariablesMap (argument_4),
mModeMap (argument_5),
mExclusionList (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_machineDefinedBySubstractiveModalComp * GGS_C_machineDefinedBySubstractiveModalComp::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedBySubstractiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_machineDefinedBySubstractiveModalComp *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_machineDefinedBySubstractiveModalComp::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_machineDefinedBySubstractiveModalComp * ptr = dynamic_cast <const cPtr_C_machineDefinedBySubstractiveModalComp *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMachineName.operator_isEqual (ptr->mMachineName).boolValue ()
         && mMachineIndex.operator_isEqual (ptr->mMachineIndex).boolValue ()
         && mInputVariableCount.operator_isEqual (ptr->mInputVariableCount).boolValue ()
         && mInputAndInternalVariableCount.operator_isEqual (ptr->mInputAndInternalVariableCount).boolValue ()
         && mVariablesMap.operator_isEqual (ptr->mVariablesMap).boolValue ()
         && mModeMap.operator_isEqual (ptr->mModeMap).boolValue ()
         && mExclusionList.operator_isEqual (ptr->mExclusionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_machineDefinedBySubstractiveModalComp::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_machineDefinedBySubstractiveModalComp:"
           << mMachineName.reader_description (inIndentation + 1)
           << mMachineIndex.reader_description (inIndentation + 1)
           << mInputVariableCount.reader_description (inIndentation + 1)
           << mInputAndInternalVariableCount.reader_description (inIndentation + 1)
           << mVariablesMap.reader_description (inIndentation + 1)
           << mModeMap.reader_description (inIndentation + 1)
           << mExclusionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_machineDefinedBySubstractiveModalComp::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_machineDefinedBySubstractiveModalComp::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_machineDefinedBySubstractiveModalComp (& typeid (cPtr_C_machineDefinedBySubstractiveModalComp), & typeid (cPtr_AC_job), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_machineDefinedBySubstractiveModalComp::galgasRTTI (void) const {
  return & gClassInfoFor__C_machineDefinedBySubstractiveModalComp ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_machineDefinedBySubstractiveModalComp::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_machineDefinedBySubstractiveModalComp (mMachineName, mMachineIndex, mInputVariableCount, mInputAndInternalVariableCount, mVariablesMap, mModeMap, mExclusionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_C_machineDefinedBySubstractiveModalComp'         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_machineDefinedBySubstractiveModalComp ("C_machineDefinedBySubstractiveModalComp", true, & kTypeDescriptor_GGS_AC_job) ;

//---------------------------------------------------------------------------*

GGS_C_machineDefinedBySubstractiveModalComp::
GGS_C_machineDefinedBySubstractiveModalComp (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_machineDefinedBySubstractiveModalComp::
GGS_C_machineDefinedBySubstractiveModalComp (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_machineDefinedBySubstractiveModalComp GGS_C_machineDefinedBySubstractiveModalComp::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_machineDefinedBySubstractiveModalComp result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_machineDefinedBySubstractiveModalComp *> (inPointer) != NULL)
      : (typeid (cPtr_C_machineDefinedBySubstractiveModalComp) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_machineDefinedBySubstractiveModalComp (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_machineDefinedBySubstractiveModalComp),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_machineDefinedBySubstractiveModalComp GGS_C_machineDefinedBySubstractiveModalComp::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_uint & argument_1,
                 const GGS_uint & argument_2,
                 const GGS_uint & argument_3,
                 const GGS_M_variablesMap & argument_4,
                 const GGS_M_modesMap & argument_5,
                 const GGS_ListForModes & argument_6
                                COMMA_LOCATION_ARGS) {
  GGS_C_machineDefinedBySubstractiveModalComp result ;
  macroMyNew (result.mPointer, cPtr_C_machineDefinedBySubstractiveModalComp (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_machineDefinedBySubstractiveModalComp::
reader_mMachineName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedBySubstractiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineDefinedBySubstractiveModalComp *) mPointer)->mMachineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_machineDefinedBySubstractiveModalComp::
reader_mMachineIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedBySubstractiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineDefinedBySubstractiveModalComp *) mPointer)->mMachineIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_machineDefinedBySubstractiveModalComp::
reader_mInputVariableCount (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedBySubstractiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineDefinedBySubstractiveModalComp *) mPointer)->mInputVariableCount ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_machineDefinedBySubstractiveModalComp::
reader_mInputAndInternalVariableCount (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedBySubstractiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineDefinedBySubstractiveModalComp *) mPointer)->mInputAndInternalVariableCount ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_variablesMap  GGS_C_machineDefinedBySubstractiveModalComp::
reader_mVariablesMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_variablesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedBySubstractiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineDefinedBySubstractiveModalComp *) mPointer)->mVariablesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_modesMap  GGS_C_machineDefinedBySubstractiveModalComp::
reader_mModeMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_modesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedBySubstractiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineDefinedBySubstractiveModalComp *) mPointer)->mModeMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ListForModes  GGS_C_machineDefinedBySubstractiveModalComp::
reader_mExclusionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ListForModes   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_machineDefinedBySubstractiveModalComp *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_machineDefinedBySubstractiveModalComp *) mPointer)->mExclusionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_machineDefinedBySubstractiveModalComp::actualTypeName (void) const {
  return "C_machineDefinedBySubstractiveModalComp" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_machineDefinedBySubstractiveModalComp ("C_machineDefinedBySubstractiveModalComp", gClassInfoFor__AC_job, & kTypeDescriptor_GGS_C_machineDefinedBySubstractiveModalComp) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_machineDefinedBySubstractiveModalComp::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_machineDefinedBySubstractiveModalComp * p = NULL ;
    macroMyNew (p, GGS_C_machineDefinedBySubstractiveModalComp (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_machineDefinedBySubstractiveModalComp GGS_C_machineDefinedBySubstractiveModalComp::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_machineDefinedBySubstractiveModalComp result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_machineDefinedBySubstractiveModalComp * p = dynamic_cast <const GGS_C_machineDefinedBySubstractiveModalComp *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_machineDefinedBySubstractiveModalComp, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_machineDefinedBySubstractiveModalComp::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_machineDefinedBySubstractiveModalComp ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@L_inputConfigurationForScenario'             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_inputConfigurationForScenario::
elementOf_GGS_L_inputConfigurationForScenario (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mInputValue (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_inputConfigurationForScenario::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_inputConfigurationForScenario * ptr = dynamic_cast <const elementOf_GGS_L_inputConfigurationForScenario *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInputValue.operator_isEqual (ptr->mInputValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_inputConfigurationForScenario::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInputValue.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@L_inputConfigurationForScenario'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_L_inputConfigurationForScenario ("L_inputConfigurationForScenario", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_L_inputConfigurationForScenario::
internalAppendValues (const GGS_luint & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_inputConfigurationForScenario::
internalPrependValues (const GGS_luint & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_inputConfigurationForScenario::
addAssign_operation (const GGS_luint & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_inputConfigurationForScenario GGS_L_inputConfigurationForScenario::
operator_concat (const GGS_L_inputConfigurationForScenario & inOperand) const {
  GGS_L_inputConfigurationForScenario result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_inputConfigurationForScenario::
dotAssign_operation (const GGS_L_inputConfigurationForScenario inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_L_inputConfigurationForScenario * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_luint  p_0 = p->mInputValue ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_inputConfigurationForScenario::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_luint & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_inputConfigurationForScenario::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mInputValue
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_inputConfigurationForScenario  GGS_L_inputConfigurationForScenario::
constructor_emptyList (void) {
  GGS_L_inputConfigurationForScenario result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_inputConfigurationForScenario  GGS_L_inputConfigurationForScenario::
constructor_listWithValue (const GGS_luint & argument_0) {
  GGS_L_inputConfigurationForScenario result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_inputConfigurationForScenario::
internalSubListWithRange (GGS_L_inputConfigurationForScenario & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mInputValue) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_inputConfigurationForScenario GGS_L_inputConfigurationForScenario::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_inputConfigurationForScenario result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_inputConfigurationForScenario GGS_L_inputConfigurationForScenario::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_inputConfigurationForScenario result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_inputConfigurationForScenario::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@L_inputConfigurationForScenario", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_L_inputConfigurationForScenario::
method_first (C_Compiler & inLexique,
              GGS_luint & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInputValue ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_inputConfigurationForScenario::
method_last (C_Compiler & inLexique,
             GGS_luint & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInputValue ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_inputConfigurationForScenario::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_luint & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInputValue ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_inputConfigurationForScenario::
modifier_popLast (C_Compiler & inLexique,
                GGS_luint & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInputValue ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_L_inputConfigurationForScenario::
reader_mInputValueAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_luint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInputValue ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_inputConfigurationForScenario::
modifier_setMInputValueAtIndex (C_Compiler & inLexique,
                              const GGS_luint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInputValue = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_L_inputConfigurationForScenario::cEnumerator::_mInputValue (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInputValue ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_L_inputConfigurationForScenario::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_L_inputConfigurationForScenario * p = NULL ;
    macroMyNew (p, GGS_L_inputConfigurationForScenario (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_inputConfigurationForScenario GGS_L_inputConfigurationForScenario::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_L_inputConfigurationForScenario result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_L_inputConfigurationForScenario * p = dynamic_cast <const GGS_L_inputConfigurationForScenario *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_L_inputConfigurationForScenario, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_L_inputConfigurationForScenario::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_L_inputConfigurationForScenario ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@L_inputScenario'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_inputScenario::
elementOf_GGS_L_inputScenario (const GGS_L_inputConfigurationForScenario & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mInputConfiguration (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_inputScenario::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_inputScenario * ptr = dynamic_cast <const elementOf_GGS_L_inputScenario *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInputConfiguration.operator_isEqual (ptr->mInputConfiguration).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_inputScenario::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInputConfiguration.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@L_inputScenario'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_L_inputScenario ("L_inputScenario", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_L_inputScenario::
internalAppendValues (const GGS_L_inputConfigurationForScenario & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_inputScenario::
internalPrependValues (const GGS_L_inputConfigurationForScenario & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_inputScenario::
addAssign_operation (const GGS_L_inputConfigurationForScenario & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_inputScenario GGS_L_inputScenario::
operator_concat (const GGS_L_inputScenario & inOperand) const {
  GGS_L_inputScenario result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_inputScenario::
dotAssign_operation (const GGS_L_inputScenario inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_L_inputScenario * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_L_inputConfigurationForScenario  p_0 = p->mInputConfiguration ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_inputScenario::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_L_inputConfigurationForScenario & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_inputScenario::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mInputConfiguration
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_inputScenario  GGS_L_inputScenario::
constructor_emptyList (void) {
  GGS_L_inputScenario result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_inputScenario  GGS_L_inputScenario::
constructor_listWithValue (const GGS_L_inputConfigurationForScenario & argument_0) {
  GGS_L_inputScenario result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_inputScenario::
internalSubListWithRange (GGS_L_inputScenario & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mInputConfiguration) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_inputScenario GGS_L_inputScenario::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_inputScenario result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_inputScenario GGS_L_inputScenario::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_inputScenario result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_inputScenario::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@L_inputScenario", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_L_inputScenario::
method_first (C_Compiler & inLexique,
              GGS_L_inputConfigurationForScenario & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInputConfiguration ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_inputScenario::
method_last (C_Compiler & inLexique,
             GGS_L_inputConfigurationForScenario & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInputConfiguration ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_inputScenario::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_L_inputConfigurationForScenario & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInputConfiguration ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_inputScenario::
modifier_popLast (C_Compiler & inLexique,
                GGS_L_inputConfigurationForScenario & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInputConfiguration ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_inputConfigurationForScenario  GGS_L_inputScenario::
reader_mInputConfigurationAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_L_inputConfigurationForScenario  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInputConfiguration ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_inputScenario::
modifier_setMInputConfigurationAtIndex (C_Compiler & inLexique,
                              const GGS_L_inputConfigurationForScenario  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInputConfiguration = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_inputConfigurationForScenario  & GGS_L_inputScenario::cEnumerator::_mInputConfiguration (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInputConfiguration ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_L_inputScenario::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_L_inputScenario * p = NULL ;
    macroMyNew (p, GGS_L_inputScenario (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_inputScenario GGS_L_inputScenario::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_L_inputScenario result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_L_inputScenario * p = dynamic_cast <const GGS_L_inputScenario *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_L_inputScenario, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_L_inputScenario::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_L_inputScenario ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@L_scenarioList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_scenarioList::
elementOf_GGS_L_scenarioList (const GGS_lstring & argument_0,
                                const GGS_L_inputScenario & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mScenarioTitle (argument_0),
mInputScenario (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_scenarioList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_scenarioList * ptr = dynamic_cast <const elementOf_GGS_L_scenarioList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mScenarioTitle.operator_isEqual (ptr->mScenarioTitle).boolValue ()
         && mInputScenario.operator_isEqual (ptr->mInputScenario).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_scenarioList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mScenarioTitle.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInputScenario.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@L_scenarioList'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_L_scenarioList ("L_scenarioList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_L_scenarioList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_L_inputScenario & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_scenarioList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_L_inputScenario & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_scenarioList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_L_inputScenario & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_scenarioList GGS_L_scenarioList::
operator_concat (const GGS_L_scenarioList & inOperand) const {
  GGS_L_scenarioList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_scenarioList::
dotAssign_operation (const GGS_L_scenarioList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_L_scenarioList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mScenarioTitle ;
          GGS_L_inputScenario  p_1 = p->mInputScenario ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_scenarioList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_L_inputScenario & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_scenarioList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mScenarioTitle,
                                ptr->mInputScenario
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_scenarioList  GGS_L_scenarioList::
constructor_emptyList (void) {
  GGS_L_scenarioList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_scenarioList  GGS_L_scenarioList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_L_inputScenario & argument_1) {
  GGS_L_scenarioList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_scenarioList::
internalSubListWithRange (GGS_L_scenarioList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mScenarioTitle, ptr->mInputScenario) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_scenarioList GGS_L_scenarioList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_scenarioList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_scenarioList GGS_L_scenarioList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_scenarioList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_scenarioList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@L_scenarioList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_L_scenarioList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_L_inputScenario & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mScenarioTitle ;
    _out_1 = ptr->mInputScenario ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_scenarioList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_L_inputScenario & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mScenarioTitle ;
    _out_1 = ptr->mInputScenario ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_scenarioList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_L_inputScenario & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mScenarioTitle ;
    _out_1 = ptr->mInputScenario ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_scenarioList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_L_inputScenario & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mScenarioTitle ;
    _out_1 = ptr->mInputScenario ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_L_scenarioList::
reader_mScenarioTitleAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mScenarioTitle ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_inputScenario  GGS_L_scenarioList::
reader_mInputScenarioAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_L_inputScenario  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInputScenario ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_scenarioList::
modifier_setMScenarioTitleAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mScenarioTitle = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_scenarioList::
modifier_setMInputScenarioAtIndex (C_Compiler & inLexique,
                              const GGS_L_inputScenario  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInputScenario = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_L_scenarioList::cEnumerator::_mScenarioTitle (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mScenarioTitle ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_inputScenario  & GGS_L_scenarioList::cEnumerator::_mInputScenario (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInputScenario ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_L_scenarioList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_L_scenarioList * p = NULL ;
    macroMyNew (p, GGS_L_scenarioList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_scenarioList GGS_L_scenarioList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_L_scenarioList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_L_scenarioList * p = dynamic_cast <const GGS_L_scenarioList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_L_scenarioList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_L_scenarioList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_L_scenarioList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_C_scenarioComponent'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_scenarioComponent::
cPtr_C_scenarioComponent (const GGS_uint & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_uint & argument_2,
                                const GGS_M_variablesMap & argument_3,
                                const GGS_L_scenarioList & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_AC_job (THERE),
mMachineIndex (argument_0),
mInputVariableCount (argument_1),
mInputAndInternalVariableCount (argument_2),
mVariablesMap (argument_3),
mScenarioList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_scenarioComponent * GGS_C_scenarioComponent::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_scenarioComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_scenarioComponent *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_scenarioComponent::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_scenarioComponent * ptr = dynamic_cast <const cPtr_C_scenarioComponent *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMachineIndex.operator_isEqual (ptr->mMachineIndex).boolValue ()
         && mInputVariableCount.operator_isEqual (ptr->mInputVariableCount).boolValue ()
         && mInputAndInternalVariableCount.operator_isEqual (ptr->mInputAndInternalVariableCount).boolValue ()
         && mVariablesMap.operator_isEqual (ptr->mVariablesMap).boolValue ()
         && mScenarioList.operator_isEqual (ptr->mScenarioList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_scenarioComponent::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_scenarioComponent:"
           << mMachineIndex.reader_description (inIndentation + 1)
           << mInputVariableCount.reader_description (inIndentation + 1)
           << mInputAndInternalVariableCount.reader_description (inIndentation + 1)
           << mVariablesMap.reader_description (inIndentation + 1)
           << mScenarioList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_scenarioComponent::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_scenarioComponent::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_scenarioComponent (& typeid (cPtr_C_scenarioComponent), & typeid (cPtr_AC_job), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_scenarioComponent::galgasRTTI (void) const {
  return & gClassInfoFor__C_scenarioComponent ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_scenarioComponent::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_scenarioComponent (mMachineIndex, mInputVariableCount, mInputAndInternalVariableCount, mVariablesMap, mScenarioList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_scenarioComponent'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_scenarioComponent ("C_scenarioComponent", true, & kTypeDescriptor_GGS_AC_job) ;

//---------------------------------------------------------------------------*

GGS_C_scenarioComponent::
GGS_C_scenarioComponent (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_scenarioComponent::
GGS_C_scenarioComponent (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_scenarioComponent GGS_C_scenarioComponent::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_scenarioComponent result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_scenarioComponent *> (inPointer) != NULL)
      : (typeid (cPtr_C_scenarioComponent) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_scenarioComponent (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_scenarioComponent),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_scenarioComponent GGS_C_scenarioComponent::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_uint & argument_0,
                 const GGS_uint & argument_1,
                 const GGS_uint & argument_2,
                 const GGS_M_variablesMap & argument_3,
                 const GGS_L_scenarioList & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_C_scenarioComponent result ;
  macroMyNew (result.mPointer, cPtr_C_scenarioComponent (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_scenarioComponent::
reader_mMachineIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_scenarioComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_scenarioComponent *) mPointer)->mMachineIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_scenarioComponent::
reader_mInputVariableCount (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_scenarioComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_scenarioComponent *) mPointer)->mInputVariableCount ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_scenarioComponent::
reader_mInputAndInternalVariableCount (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_scenarioComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_scenarioComponent *) mPointer)->mInputAndInternalVariableCount ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_variablesMap  GGS_C_scenarioComponent::
reader_mVariablesMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_variablesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_scenarioComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_scenarioComponent *) mPointer)->mVariablesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_scenarioList  GGS_C_scenarioComponent::
reader_mScenarioList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_scenarioList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_scenarioComponent *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_scenarioComponent *) mPointer)->mScenarioList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_scenarioComponent::actualTypeName (void) const {
  return "C_scenarioComponent" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_scenarioComponent ("C_scenarioComponent", gClassInfoFor__AC_job, & kTypeDescriptor_GGS_C_scenarioComponent) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_scenarioComponent::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_scenarioComponent * p = NULL ;
    macroMyNew (p, GGS_C_scenarioComponent (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_scenarioComponent GGS_C_scenarioComponent::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_scenarioComponent result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_scenarioComponent * p = dynamic_cast <const GGS_C_scenarioComponent *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_scenarioComponent, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_scenarioComponent::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_scenarioComponent ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_typeUse_AND'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUse_AND::
cPtr_typeUse_AND (LOCATION_ARGS)
:cPtr_AC_job (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUse_AND * GGS_typeUse_AND::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUse_AND *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeUse_AND *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeUse_AND::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeUse_AND::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeUse_AND:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeUse_AND::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeUse_AND::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeUse_AND (& typeid (cPtr_typeUse_AND), & typeid (cPtr_AC_job), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeUse_AND::galgasRTTI (void) const {
  return & gClassInfoFor__typeUse_AND ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeUse_AND'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeUse_AND ("typeUse_AND", true, & kTypeDescriptor_GGS_AC_job) ;

//---------------------------------------------------------------------------*

GGS_typeUse_AND::
GGS_typeUse_AND (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_AND::
GGS_typeUse_AND (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeUse_AND GGS_typeUse_AND::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeUse_AND result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeUse_AND *> (inPointer) != NULL)
      : (typeid (cPtr_typeUse_AND) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeUse_AND (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeUse_AND),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeUse_AND * gSingleton_typeUse_AND = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeUse_AND (void) {
  macroDetachPointer (gSingleton_typeUse_AND, cPtr_typeUse_AND) ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_AND GGS_typeUse_AND::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeUse_AND result ;
  if (NULL == gSingleton_typeUse_AND) {
    macroMyNew (gSingleton_typeUse_AND, cPtr_typeUse_AND (THERE)) ;
    registerReleaseRoutine (cleanUp_typeUse_AND) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeUse_AND) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeUse_AND::actualTypeName (void) const {
  return "typeUse_AND" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeUse_AND ("typeUse_AND", gClassInfoFor__AC_job, & kTypeDescriptor_GGS_typeUse_AND) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeUse_AND::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeUse_AND * p = NULL ;
    macroMyNew (p, GGS_typeUse_AND (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_AND GGS_typeUse_AND::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeUse_AND result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeUse_AND * p = dynamic_cast <const GGS_typeUse_AND *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeUse_AND, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeUse_AND::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeUse_AND ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_typeUse_ITE'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUse_ITE::
cPtr_typeUse_ITE (LOCATION_ARGS)
:cPtr_AC_job (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUse_ITE * GGS_typeUse_ITE::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUse_ITE *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeUse_ITE *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeUse_ITE::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeUse_ITE::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeUse_ITE:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeUse_ITE::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeUse_ITE::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeUse_ITE (& typeid (cPtr_typeUse_ITE), & typeid (cPtr_AC_job), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeUse_ITE::galgasRTTI (void) const {
  return & gClassInfoFor__typeUse_ITE ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeUse_ITE'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeUse_ITE ("typeUse_ITE", true, & kTypeDescriptor_GGS_AC_job) ;

//---------------------------------------------------------------------------*

GGS_typeUse_ITE::
GGS_typeUse_ITE (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_ITE::
GGS_typeUse_ITE (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeUse_ITE GGS_typeUse_ITE::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeUse_ITE result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeUse_ITE *> (inPointer) != NULL)
      : (typeid (cPtr_typeUse_ITE) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeUse_ITE (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeUse_ITE),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeUse_ITE * gSingleton_typeUse_ITE = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeUse_ITE (void) {
  macroDetachPointer (gSingleton_typeUse_ITE, cPtr_typeUse_ITE) ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_ITE GGS_typeUse_ITE::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeUse_ITE result ;
  if (NULL == gSingleton_typeUse_ITE) {
    macroMyNew (gSingleton_typeUse_ITE, cPtr_typeUse_ITE (THERE)) ;
    registerReleaseRoutine (cleanUp_typeUse_ITE) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeUse_ITE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeUse_ITE::actualTypeName (void) const {
  return "typeUse_ITE" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeUse_ITE ("typeUse_ITE", gClassInfoFor__AC_job, & kTypeDescriptor_GGS_typeUse_ITE) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeUse_ITE::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeUse_ITE * p = NULL ;
    macroMyNew (p, GGS_typeUse_ITE (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_ITE GGS_typeUse_ITE::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeUse_ITE result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeUse_ITE * p = dynamic_cast <const GGS_typeUse_ITE *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeUse_ITE, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeUse_ITE::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeUse_ITE ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeUse_AND_ITE'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUse_AND_ITE::
cPtr_typeUse_AND_ITE (LOCATION_ARGS)
:cPtr_AC_job (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUse_AND_ITE * GGS_typeUse_AND_ITE::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUse_AND_ITE *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeUse_AND_ITE *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeUse_AND_ITE::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeUse_AND_ITE::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeUse_AND_ITE:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeUse_AND_ITE::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeUse_AND_ITE::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeUse_AND_ITE (& typeid (cPtr_typeUse_AND_ITE), & typeid (cPtr_AC_job), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeUse_AND_ITE::galgasRTTI (void) const {
  return & gClassInfoFor__typeUse_AND_ITE ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeUse_AND_ITE'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeUse_AND_ITE ("typeUse_AND_ITE", true, & kTypeDescriptor_GGS_AC_job) ;

//---------------------------------------------------------------------------*

GGS_typeUse_AND_ITE::
GGS_typeUse_AND_ITE (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_AND_ITE::
GGS_typeUse_AND_ITE (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeUse_AND_ITE GGS_typeUse_AND_ITE::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeUse_AND_ITE result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeUse_AND_ITE *> (inPointer) != NULL)
      : (typeid (cPtr_typeUse_AND_ITE) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeUse_AND_ITE (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeUse_AND_ITE),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeUse_AND_ITE * gSingleton_typeUse_AND_ITE = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeUse_AND_ITE (void) {
  macroDetachPointer (gSingleton_typeUse_AND_ITE, cPtr_typeUse_AND_ITE) ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_AND_ITE GGS_typeUse_AND_ITE::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeUse_AND_ITE result ;
  if (NULL == gSingleton_typeUse_AND_ITE) {
    macroMyNew (gSingleton_typeUse_AND_ITE, cPtr_typeUse_AND_ITE (THERE)) ;
    registerReleaseRoutine (cleanUp_typeUse_AND_ITE) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeUse_AND_ITE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeUse_AND_ITE::actualTypeName (void) const {
  return "typeUse_AND_ITE" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeUse_AND_ITE ("typeUse_AND_ITE", gClassInfoFor__AC_job, & kTypeDescriptor_GGS_typeUse_AND_ITE) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeUse_AND_ITE::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeUse_AND_ITE * p = NULL ;
    macroMyNew (p, GGS_typeUse_AND_ITE (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_AND_ITE GGS_typeUse_AND_ITE::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeUse_AND_ITE result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeUse_AND_ITE * p = dynamic_cast <const GGS_typeUse_AND_ITE *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeUse_AND_ITE, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeUse_AND_ITE::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeUse_AND_ITE ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeResize_AND_cache'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeResize_AND_cache::
cPtr_typeResize_AND_cache (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_job (THERE),
mNewSize (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeResize_AND_cache * GGS_typeResize_AND_cache::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeResize_AND_cache *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeResize_AND_cache *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeResize_AND_cache::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeResize_AND_cache * ptr = dynamic_cast <const cPtr_typeResize_AND_cache *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mNewSize.operator_isEqual (ptr->mNewSize).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeResize_AND_cache::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeResize_AND_cache:"
           << mNewSize.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeResize_AND_cache::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeResize_AND_cache::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeResize_AND_cache (& typeid (cPtr_typeResize_AND_cache), & typeid (cPtr_AC_job), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeResize_AND_cache::galgasRTTI (void) const {
  return & gClassInfoFor__typeResize_AND_cache ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeResize_AND_cache::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeResize_AND_cache (mNewSize COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeResize_AND_cache'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeResize_AND_cache ("typeResize_AND_cache", true, & kTypeDescriptor_GGS_AC_job) ;

//---------------------------------------------------------------------------*

GGS_typeResize_AND_cache::
GGS_typeResize_AND_cache (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeResize_AND_cache::
GGS_typeResize_AND_cache (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeResize_AND_cache GGS_typeResize_AND_cache::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeResize_AND_cache result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeResize_AND_cache *> (inPointer) != NULL)
      : (typeid (cPtr_typeResize_AND_cache) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeResize_AND_cache (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeResize_AND_cache),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeResize_AND_cache GGS_typeResize_AND_cache::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeResize_AND_cache result ;
  macroMyNew (result.mPointer, cPtr_typeResize_AND_cache (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeResize_AND_cache::
reader_mNewSize (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeResize_AND_cache *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeResize_AND_cache *) mPointer)->mNewSize ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeResize_AND_cache::actualTypeName (void) const {
  return "typeResize_AND_cache" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeResize_AND_cache ("typeResize_AND_cache", gClassInfoFor__AC_job, & kTypeDescriptor_GGS_typeResize_AND_cache) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeResize_AND_cache::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeResize_AND_cache * p = NULL ;
    macroMyNew (p, GGS_typeResize_AND_cache (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeResize_AND_cache GGS_typeResize_AND_cache::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeResize_AND_cache result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeResize_AND_cache * p = dynamic_cast <const GGS_typeResize_AND_cache *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeResize_AND_cache, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeResize_AND_cache::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeResize_AND_cache ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeResize_ITE_cache'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeResize_ITE_cache::
cPtr_typeResize_ITE_cache (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_job (THERE),
mNewSize (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeResize_ITE_cache * GGS_typeResize_ITE_cache::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeResize_ITE_cache *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeResize_ITE_cache *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeResize_ITE_cache::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeResize_ITE_cache * ptr = dynamic_cast <const cPtr_typeResize_ITE_cache *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mNewSize.operator_isEqual (ptr->mNewSize).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeResize_ITE_cache::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeResize_ITE_cache:"
           << mNewSize.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeResize_ITE_cache::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeResize_ITE_cache::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeResize_ITE_cache (& typeid (cPtr_typeResize_ITE_cache), & typeid (cPtr_AC_job), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeResize_ITE_cache::galgasRTTI (void) const {
  return & gClassInfoFor__typeResize_ITE_cache ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeResize_ITE_cache::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeResize_ITE_cache (mNewSize COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeResize_ITE_cache'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeResize_ITE_cache ("typeResize_ITE_cache", true, & kTypeDescriptor_GGS_AC_job) ;

//---------------------------------------------------------------------------*

GGS_typeResize_ITE_cache::
GGS_typeResize_ITE_cache (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeResize_ITE_cache::
GGS_typeResize_ITE_cache (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeResize_ITE_cache GGS_typeResize_ITE_cache::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeResize_ITE_cache result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeResize_ITE_cache *> (inPointer) != NULL)
      : (typeid (cPtr_typeResize_ITE_cache) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeResize_ITE_cache (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeResize_ITE_cache),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeResize_ITE_cache GGS_typeResize_ITE_cache::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeResize_ITE_cache result ;
  macroMyNew (result.mPointer, cPtr_typeResize_ITE_cache (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeResize_ITE_cache::
reader_mNewSize (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeResize_ITE_cache *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeResize_ITE_cache *) mPointer)->mNewSize ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeResize_ITE_cache::actualTypeName (void) const {
  return "typeResize_ITE_cache" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeResize_ITE_cache ("typeResize_ITE_cache", gClassInfoFor__AC_job, & kTypeDescriptor_GGS_typeResize_ITE_cache) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeResize_ITE_cache::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeResize_ITE_cache * p = NULL ;
    macroMyNew (p, GGS_typeResize_ITE_cache (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeResize_ITE_cache GGS_typeResize_ITE_cache::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeResize_ITE_cache result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeResize_ITE_cache * p = dynamic_cast <const GGS_typeResize_ITE_cache *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeResize_ITE_cache, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeResize_ITE_cache::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeResize_ITE_cache ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_typeResizeMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeResizeMap::
cPtr_typeResizeMap (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_job (THERE),
mNewSize (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeResizeMap * GGS_typeResizeMap::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeResizeMap *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeResizeMap *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeResizeMap::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeResizeMap * ptr = dynamic_cast <const cPtr_typeResizeMap *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mNewSize.operator_isEqual (ptr->mNewSize).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeResizeMap::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeResizeMap:"
           << mNewSize.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeResizeMap::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeResizeMap::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeResizeMap (& typeid (cPtr_typeResizeMap), & typeid (cPtr_AC_job), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeResizeMap::galgasRTTI (void) const {
  return & gClassInfoFor__typeResizeMap ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeResizeMap::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeResizeMap (mNewSize COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeResizeMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeResizeMap ("typeResizeMap", true, & kTypeDescriptor_GGS_AC_job) ;

//---------------------------------------------------------------------------*

GGS_typeResizeMap::
GGS_typeResizeMap (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeResizeMap::
GGS_typeResizeMap (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeResizeMap GGS_typeResizeMap::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeResizeMap result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeResizeMap *> (inPointer) != NULL)
      : (typeid (cPtr_typeResizeMap) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeResizeMap (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeResizeMap),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeResizeMap GGS_typeResizeMap::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeResizeMap result ;
  macroMyNew (result.mPointer, cPtr_typeResizeMap (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeResizeMap::
reader_mNewSize (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeResizeMap *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeResizeMap *) mPointer)->mNewSize ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeResizeMap::actualTypeName (void) const {
  return "typeResizeMap" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeResizeMap ("typeResizeMap", gClassInfoFor__AC_job, & kTypeDescriptor_GGS_typeResizeMap) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeResizeMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeResizeMap * p = NULL ;
    macroMyNew (p, GGS_typeResizeMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeResizeMap GGS_typeResizeMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeResizeMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeResizeMap * p = dynamic_cast <const GGS_typeResizeMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeResizeMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeResizeMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeResizeMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeDisplayBDDstats'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDisplayBDDstats::
cPtr_typeDisplayBDDstats (LOCATION_ARGS)
:cPtr_AC_job (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDisplayBDDstats * GGS_typeDisplayBDDstats::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDisplayBDDstats *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDisplayBDDstats *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDisplayBDDstats::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDisplayBDDstats::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeDisplayBDDstats:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDisplayBDDstats::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDisplayBDDstats::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDisplayBDDstats (& typeid (cPtr_typeDisplayBDDstats), & typeid (cPtr_AC_job), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeDisplayBDDstats::galgasRTTI (void) const {
  return & gClassInfoFor__typeDisplayBDDstats ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDisplayBDDstats'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeDisplayBDDstats ("typeDisplayBDDstats", true, & kTypeDescriptor_GGS_AC_job) ;

//---------------------------------------------------------------------------*

GGS_typeDisplayBDDstats::
GGS_typeDisplayBDDstats (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDisplayBDDstats::
GGS_typeDisplayBDDstats (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeDisplayBDDstats GGS_typeDisplayBDDstats::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDisplayBDDstats result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDisplayBDDstats *> (inPointer) != NULL)
      : (typeid (cPtr_typeDisplayBDDstats) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeDisplayBDDstats (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDisplayBDDstats),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeDisplayBDDstats * gSingleton_typeDisplayBDDstats = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeDisplayBDDstats (void) {
  macroDetachPointer (gSingleton_typeDisplayBDDstats, cPtr_typeDisplayBDDstats) ;
}

//---------------------------------------------------------------------------*

GGS_typeDisplayBDDstats GGS_typeDisplayBDDstats::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeDisplayBDDstats result ;
  if (NULL == gSingleton_typeDisplayBDDstats) {
    macroMyNew (gSingleton_typeDisplayBDDstats, cPtr_typeDisplayBDDstats (THERE)) ;
    registerReleaseRoutine (cleanUp_typeDisplayBDDstats) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeDisplayBDDstats) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDisplayBDDstats::actualTypeName (void) const {
  return "typeDisplayBDDstats" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeDisplayBDDstats ("typeDisplayBDDstats", gClassInfoFor__AC_job, & kTypeDescriptor_GGS_typeDisplayBDDstats) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeDisplayBDDstats::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeDisplayBDDstats * p = NULL ;
    macroMyNew (p, GGS_typeDisplayBDDstats (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDisplayBDDstats GGS_typeDisplayBDDstats::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeDisplayBDDstats result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeDisplayBDDstats * p = dynamic_cast <const GGS_typeDisplayBDDstats *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeDisplayBDDstats, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeDisplayBDDstats::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeDisplayBDDstats ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       Element of list '@L_jobList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_jobList::
elementOf_GGS_L_jobList (const GGS_AC_job & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mComponent (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_jobList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_jobList * ptr = dynamic_cast <const elementOf_GGS_L_jobList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mComponent.operator_isEqual (ptr->mComponent).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_jobList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mComponent.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            List '@L_jobList'                              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_L_jobList ("L_jobList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_L_jobList::
internalAppendValues (const GGS_AC_job & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_jobList::
internalPrependValues (const GGS_AC_job & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_jobList::
addAssign_operation (const GGS_AC_job & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_jobList GGS_L_jobList::
operator_concat (const GGS_L_jobList & inOperand) const {
  GGS_L_jobList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_jobList::
dotAssign_operation (const GGS_L_jobList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_L_jobList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_AC_job  p_0 = p->mComponent ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_jobList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_AC_job & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_jobList::
insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mComponent
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_jobList  GGS_L_jobList::
constructor_emptyList (void) {
  GGS_L_jobList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_jobList  GGS_L_jobList::
constructor_listWithValue (const GGS_AC_job & argument_0) {
  GGS_L_jobList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_jobList::
internalSubListWithRange (GGS_L_jobList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mComponent) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_jobList GGS_L_jobList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_jobList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_jobList GGS_L_jobList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_jobList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_jobList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@L_jobList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_L_jobList::
method_first (C_Compiler & inLexique,
              GGS_AC_job & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mComponent ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_jobList::
method_last (C_Compiler & inLexique,
             GGS_AC_job & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mComponent ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_jobList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_AC_job & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mComponent ;
    insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_jobList::
modifier_popLast (C_Compiler & inLexique,
                GGS_AC_job & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mComponent ;
    insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_AC_job  GGS_L_jobList::
reader_mComponentAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_AC_job  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mComponent ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_jobList::
modifier_setMComponentAtIndex (C_Compiler & inLexique,
                              const GGS_AC_job  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mComponent = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_job  & GGS_L_jobList::cEnumerator::_mComponent (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mComponent ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_L_jobList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_L_jobList * p = NULL ;
    macroMyNew (p, GGS_L_jobList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_jobList GGS_L_jobList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_L_jobList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_L_jobList * p = dynamic_cast <const GGS_L_jobList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_L_jobList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_L_jobList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_L_jobList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_M_machinesMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_machinesMap::e_M_machinesMap (void) :
mIndex (),
mInputVariableCount (),
mInputAndInternalVariableCount (),
mVariablesMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map '@M_machinesMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_M_machinesMap ("M_machinesMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_M_machinesMap::
elementOf_GGS_M_machinesMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_M_machinesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_machinesMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mIndex.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mInputVariableCount.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mInputAndInternalVariableCount.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mVariablesMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_machinesMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_machinesMap * ptr = dynamic_cast <const elementOf_GGS_M_machinesMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mIndex.operator_isEqual (ptr->mInfo.mIndex)).boolValue ()
           && (mInfo.mInputVariableCount.operator_isEqual (ptr->mInfo.mInputVariableCount)).boolValue ()
           && (mInfo.mInputAndInternalVariableCount.operator_isEqual (ptr->mInfo.mInputAndInternalVariableCount)).boolValue ()
           && (mInfo.mVariablesMap.operator_isEqual (ptr->mInfo.mVariablesMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_machinesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_machinesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_machinesMap * info = (e_M_machinesMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_machinesMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_machinesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_machinesMap * info = (e_M_machinesMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_machinesMap GGS_M_machinesMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_machinesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_machinesMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_machinesMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_machinesMap::
operator_isEqual (const GGS_M_machinesMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_machinesMap::
operator_isNotEqual (const GGS_M_machinesMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_machinesMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_machinesMap::
removeElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_uint & outParameter0,
                GGS_uint & outParameter1,
                GGS_uint & outParameter2,
                GGS_M_variablesMap & outParameter3,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  AC_galgas_map_element * removedElement = NULL ;
  PMSInt32 elementID = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    removedElement = internalRemove (inKey) ;
    if (removedElement == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
      outParameter0.drop () ;
      outParameter1.drop () ;
      outParameter2.drop () ;
      outParameter3.drop () ;
    }else{
      cElement * ptr = (cElement *) removedElement ;
      elementID = ptr->mID ;
      outParameter0 = ptr->mInfo.mIndex ;
      outParameter1 = ptr->mInfo.mInputVariableCount ;
      outParameter2 = ptr->mInfo.mInputAndInternalVariableCount ;
      outParameter3 = ptr->mInfo.mVariablesMap ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
  macroMyDelete (removedElement, cElement) ;
}

//---------------------------------------------------------------------------*

void GGS_M_machinesMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_uint & inParameter0,
                const GGS_uint & inParameter1,
                const GGS_uint & inParameter2,
                const GGS_M_variablesMap & inParameter3,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inParameter3.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_machinesMap info  ;
    info.mIndex = inParameter0 ;
    info.mInputVariableCount = inParameter1 ;
    info.mInputAndInternalVariableCount = inParameter2 ;
    info.mVariablesMap = inParameter3 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_machinesMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_uint   & outParameter1,
               GGS_uint   & outParameter2,
               GGS_M_variablesMap   & outParameter3,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    outParameter3.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mIndex ;
    outParameter1 = node->mInfo.mInputVariableCount ;
    outParameter2 = node->mInfo.mInputAndInternalVariableCount ;
    outParameter3 = node->mInfo.mVariablesMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_machinesMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('c'),
  TO_UNICODE ('h'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_machinesMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0,
                                GGS_uint   & outParameter1,
                                GGS_uint   & outParameter2,
                                GGS_M_variablesMap   & outParameter3 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  outParameter3,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_machinesMap::kRemoveMessage_removeKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('c'),
  TO_UNICODE ('h'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_machinesMap::
modifier_removeKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint & outParameter0,
                                GGS_uint & outParameter1,
                                GGS_uint & outParameter2,
                                GGS_M_variablesMap & outParameter3 COMMA_LOCATION_ARGS) {
  removeElement (inLexique,
                  kRemoveMessage_removeKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  outParameter3,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_machinesMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('c'),
  TO_UNICODE ('h'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_machinesMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0,
                                const GGS_uint & inParameter1,
                                const GGS_uint & inParameter2,
                                const GGS_M_variablesMap & inParameter3 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_machinesMap GGS_M_machinesMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_machinesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_machinesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_machinesMap GGS_M_machinesMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_machinesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_machinesMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @M_machinesMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    PMSInt32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (elementID, s, inIndentation) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_M_machinesMap::cEnumerator::_mIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_M_machinesMap::cEnumerator::_mInputVariableCount (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mInputVariableCount ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_M_machinesMap::cEnumerator::_mInputAndInternalVariableCount (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mInputAndInternalVariableCount ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_M_variablesMap  & GGS_M_machinesMap::cEnumerator::_mVariablesMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mVariablesMap ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_M_machinesMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_M_machinesMap * p = NULL ;
    macroMyNew (p, GGS_M_machinesMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_machinesMap GGS_M_machinesMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_M_machinesMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_M_machinesMap * p = dynamic_cast <const GGS_M_machinesMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_M_machinesMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_M_machinesMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_M_machinesMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Implementation of 'semanticContext' struct                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticContext ("semanticContext", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_semanticContext::GGS_semanticContext (void) :
componentsMap (),
machinesMap () {
}

//---------------------------------------------------------------------------*

GGS_semanticContext::~GGS_semanticContext (void) {
}

//---------------------------------------------------------------------------*

void GGS_semanticContext::drop (void) {
  componentsMap.drop () ;
  machinesMap.drop () ;
}

//---------------------------------------------------------------------------*

bool GGS_semanticContext::isBuilt (void) const {
  return componentsMap.isBuilt ()
    && machinesMap.isBuilt () ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticContext::
operator_isEqual (const GGS_semanticContext & inOperand) const {
  return componentsMap.operator_isEqual (inOperand.componentsMap)
    .operator_and (machinesMap.operator_isEqual (inOperand.machinesMap)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticContext::
operator_isNotEqual (const GGS_semanticContext & inOperand) const {
  return componentsMap.operator_isNotEqual (inOperand.componentsMap)
    .operator_or (machinesMap.operator_isNotEqual (inOperand.machinesMap)) ;
}

//---------------------------------------------------------------------------*

GGS_semanticContext GGS_semanticContext::
constructor_new (const GGS_L_jobList & argument_0,
                 const GGS_M_machinesMap & argument_1) {
  GGS_semanticContext result ;
  result.componentsMap = argument_0 ;
  result.machinesMap = argument_1 ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticContext::
reader_description (const PMSInt32 inIndentation) const {
  C_String _s ;
  _s << "<struct @semanticContext" ;
  if (isBuilt ()) {
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "componentsMap " ;
    _s << componentsMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "machinesMap " ;
    _s << machinesMap.reader_description (inIndentation + 1) ;
  }else{
    _s << "not built" ;
  }
  _s << "\n" ;
  _s.writeStringMultiple ("| ", inIndentation) ;
  _s << ">" ;
  return GGS_string (true, _s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_semanticContext::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticContext * p = NULL ;
    macroMyNew (p, GGS_semanticContext (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticContext GGS_semanticContext::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticContext result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticContext * p = dynamic_cast <const GGS_semanticContext *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticContext, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticContext::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticContext ;
}

//---------------------------------------------------------------------------*

