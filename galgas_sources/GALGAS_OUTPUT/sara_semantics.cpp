//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'sara_semantics.cpp'                          *
//               Generated by version 0.14.1 (LL(1) grammar)                 *
//                      march 2nd, 2005, at 17h55'48"                        *
//                                                                           *
// This program is free software; you can redistribute it and/or modify it   *
// under the terms of the GNU General Public License as published by the     *
// Free Software Foundation.                                                 *
//                                                                           *
// This program is distributed in the hope it will be useful, but WITHOUT    *
// ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or     *
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for  *
// more details.                                                             *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "files/C_text_file_write.h"
#include "sara_semantics.h"


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'M_variablesMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_M_variablesMap::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_variablesMap & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_variablesMap::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_M_variablesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_M_variablesMap * info = (e_M_variablesMap *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_M_variablesMap::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_M_variablesMap::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_variablesMap GGS_M_variablesMap::constructor_empty (void) {
  GGS_M_variablesMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_variablesMap::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_variablesMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_variablesMap::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
     insulateMap () ;
    e_M_variablesMap info  ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_variablesMap::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_M_variablesMap (C_lexique & inLexique,
                                GGS_M_variablesMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' variable is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_M_variablesMap (C_lexique & lexique_var_,
                                GGS_M_variablesMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' variable has been already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map 'M_stateMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_M_stateMap::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_stateMap & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_stateMap::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_M_stateMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_M_stateMap * info = (e_M_stateMap *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_M_stateMap::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_M_stateMap::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_stateMap GGS_M_stateMap::constructor_empty (void) {
  GGS_M_stateMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_stateMap::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_stateMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_stateMap::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
     insulateMap () ;
    e_M_stateMap info  ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_stateMap::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_M_stateMap (C_lexique & inLexique,
                                GGS_M_stateMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' state is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_M_stateMap (C_lexique & lexique_var_,
                                GGS_M_stateMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' state has been already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void defineState_M_stateMap (C_lexique & lexique_var_,
                                GGS_M_stateMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' state has been already defined",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_AC_expression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_AC_expression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_expression::
GGS_AC_expression (void) {
  mPointer = (cPtr_AC_expression *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_expression::
GGS_AC_expression (const GGS_AC_expression & inOperand) {
  mPointer = (cPtr_AC_expression *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_expression::
~GGS_AC_expression (void) {
  macroDetachPointer (mPointer, cPtr_AC_expression) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_expression::
operator = (const GGS_AC_expression & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

bool GGS_AC_expression::isBuilt (void) const {
  bool result = false ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->isBuilt () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_AC_expression::
operator = (cPtr_AC_expression * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_AC_expression::
GGS_AC_expression (cPtr_AC_expression * inSource) {
  mPointer = (cPtr_AC_expression *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

cPtr_AC_expression * GGS_AC_expression
::operator () (void) const {
  macroValidPointer (mPointer) ;
  return mPointer ;
}

//---------------------------------------------------------------------------*

void GGS_AC_expression
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_expression) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_andExpression'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_andExpression::cPtr_C_andExpression (const GGS_AC_expression & argument_0,
                                const GGS_AC_expression & argument_1)
:mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_andExpression::isBuilt (void) const {
  return mLeftExpression.isBuilt () &&
       mRightExpression.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_andExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_andExpression * GGS_C_andExpression::
    constructor_new (const GGS_AC_expression & argument_0,
                                const GGS_AC_expression & argument_1) {
    cPtr_C_andExpression * ptr_ = (cPtr_C_andExpression *) NULL ;
    macroMyNew (ptr_, cPtr_C_andExpression (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'C_orExpression'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_orExpression::cPtr_C_orExpression (const GGS_AC_expression & argument_0,
                                const GGS_AC_expression & argument_1)
:mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_orExpression::isBuilt (void) const {
  return mLeftExpression.isBuilt () &&
       mRightExpression.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_orExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_orExpression * GGS_C_orExpression::
    constructor_new (const GGS_AC_expression & argument_0,
                                const GGS_AC_expression & argument_1) {
    cPtr_C_orExpression * ptr_ = (cPtr_C_orExpression *) NULL ;
    macroMyNew (ptr_, cPtr_C_orExpression (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_xorExpression'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_xorExpression::cPtr_C_xorExpression (const GGS_AC_expression & argument_0,
                                const GGS_AC_expression & argument_1)
:mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_xorExpression::isBuilt (void) const {
  return mLeftExpression.isBuilt () &&
       mRightExpression.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_xorExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_xorExpression * GGS_C_xorExpression::
    constructor_new (const GGS_AC_expression & argument_0,
                                const GGS_AC_expression & argument_1) {
    cPtr_C_xorExpression * ptr_ = (cPtr_C_xorExpression *) NULL ;
    macroMyNew (ptr_, cPtr_C_xorExpression (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_impliesExpression'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_impliesExpression::cPtr_C_impliesExpression (const GGS_AC_expression & argument_0,
                                const GGS_AC_expression & argument_1)
:mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_impliesExpression::isBuilt (void) const {
  return mLeftExpression.isBuilt () &&
       mRightExpression.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_impliesExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_impliesExpression * GGS_C_impliesExpression::
    constructor_new (const GGS_AC_expression & argument_0,
                                const GGS_AC_expression & argument_1) {
    cPtr_C_impliesExpression * ptr_ = (cPtr_C_impliesExpression *) NULL ;
    macroMyNew (ptr_, cPtr_C_impliesExpression (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'C_equalExpression'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_equalExpression::cPtr_C_equalExpression (const GGS_AC_expression & argument_0,
                                const GGS_AC_expression & argument_1)
:mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_equalExpression::isBuilt (void) const {
  return mLeftExpression.isBuilt () &&
       mRightExpression.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_equalExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_equalExpression * GGS_C_equalExpression::
    constructor_new (const GGS_AC_expression & argument_0,
                                const GGS_AC_expression & argument_1) {
    cPtr_C_equalExpression * ptr_ = (cPtr_C_equalExpression *) NULL ;
    macroMyNew (ptr_, cPtr_C_equalExpression (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_notExpression'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_notExpression::cPtr_C_notExpression (const GGS_AC_expression & argument_0)
:mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_notExpression::isBuilt (void) const {
  return mExpression.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_notExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_notExpression * GGS_C_notExpression::
    constructor_new (const GGS_AC_expression & argument_0) {
    cPtr_C_notExpression * ptr_ = (cPtr_C_notExpression *) NULL ;
    macroMyNew (ptr_, cPtr_C_notExpression (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_VariableExpression'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_VariableExpression::cPtr_C_VariableExpression (const GGS_luint & argument_0)
:mInputVarIndex (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_VariableExpression::isBuilt (void) const {
  return mInputVarIndex.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_VariableExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_VariableExpression * GGS_C_VariableExpression::
    constructor_new (const GGS_luint & argument_0) {
    cPtr_C_VariableExpression * ptr_ = (cPtr_C_VariableExpression *) NULL ;
    macroMyNew (ptr_, cPtr_C_VariableExpression (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_trueExpression'                          *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_C_trueExpression::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_trueExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_trueExpression * GGS_C_trueExpression::
    constructor_new () {
    cPtr_C_trueExpression * ptr_ = (cPtr_C_trueExpression *) NULL ;
    macroMyNew (ptr_, cPtr_C_trueExpression ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'C_falseExpression'                          *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_C_falseExpression::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_falseExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_falseExpression * GGS_C_falseExpression::
    constructor_new () {
    cPtr_C_falseExpression * ptr_ = (cPtr_C_falseExpression *) NULL ;
    macroMyNew (ptr_, cPtr_C_falseExpression ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              Class element of list 'L_transitionDefinition'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_transitionDefinition::element_type::
element_type (const GGS_AC_expression & argument_0,
                                const GGS_location & argument_1,
                                const GGS_luint & argument_2) {
  mNextItem = (element_type *) NULL ;
  mActionExpression = argument_0 ;
  mEndOfExpression = argument_1 ;
  mTargetStateIndex = argument_2 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class list 'L_transitionDefinition'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_transitionDefinition
::GGS_L_transitionDefinition (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_transitionDefinition::~GGS_L_transitionDefinition (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_transitionDefinition::GGS_L_transitionDefinition (const GGS_L_transitionDefinition & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition
::operator = (const GGS_L_transitionDefinition & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
internalAppendItem (const GGS_AC_expression & argument_0,
                                const GGS_location & argument_1,
                                const GGS_luint & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition::
addAssign_operation (const GGS_AC_expression & argument_0,
                                const GGS_location & argument_1,
                                const GGS_luint & argument_2) {
  if (isBuilt ()
                 && argument_0.isBuilt ()
                 && argument_1.isBuilt ()
                 && argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mActionExpression,
                                p->mEndOfExpression,
                                p->mTargetStateIndex) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_transitionDefinition  GGS_L_transitionDefinition::
constructor_empty (void) {
  GGS_L_transitionDefinition result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_transitionDefinition
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Class element of list 'L_stateDefinition'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_stateDefinition::element_type::
element_type (const GGS_luint & argument_0,
                                const GGS_AC_expression & argument_1,
                                const GGS_location & argument_2,
                                const GGS_L_transitionDefinition & argument_3) {
  mNextItem = (element_type *) NULL ;
  mStateIndex = argument_0 ;
  mStateExpression = argument_1 ;
  mEndOfStateExpression = argument_2 ;
  mTransitionsList = argument_3 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class list 'L_stateDefinition'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_stateDefinition
::GGS_L_stateDefinition (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_stateDefinition::~GGS_L_stateDefinition (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_stateDefinition::GGS_L_stateDefinition (const GGS_L_stateDefinition & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition
::operator = (const GGS_L_stateDefinition & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
internalAppendItem (const GGS_luint & argument_0,
                                const GGS_AC_expression & argument_1,
                                const GGS_location & argument_2,
                                const GGS_L_transitionDefinition & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition::
addAssign_operation (const GGS_luint & argument_0,
                                const GGS_AC_expression & argument_1,
                                const GGS_location & argument_2,
                                const GGS_L_transitionDefinition & argument_3) {
  if (isBuilt ()
                 && argument_0.isBuilt ()
                 && argument_1.isBuilt ()
                 && argument_2.isBuilt ()
                 && argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mStateIndex,
                                p->mStateExpression,
                                p->mEndOfStateExpression,
                                p->mTransitionsList) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_stateDefinition  GGS_L_stateDefinition::
constructor_empty (void) {
  GGS_L_stateDefinition result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_stateDefinition
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Class element of list 'L_statesDefinitionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_statesDefinitionList::element_type::
element_type (const GGS_luint & argument_0,
                                const GGS_location & argument_1) {
  mNextItem = (element_type *) NULL ;
  mStateIndex = argument_0 ;
  mStateLocation = argument_1 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class list 'L_statesDefinitionList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_statesDefinitionList
::GGS_L_statesDefinitionList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_statesDefinitionList::~GGS_L_statesDefinitionList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_statesDefinitionList::GGS_L_statesDefinitionList (const GGS_L_statesDefinitionList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList
::operator = (const GGS_L_statesDefinitionList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList::
internalAppendItem (const GGS_luint & argument_0,
                                const GGS_location & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList::
addAssign_operation (const GGS_luint & argument_0,
                                const GGS_location & argument_1) {
  if (isBuilt ()
                 && argument_0.isBuilt ()
                 && argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mStateIndex,
                                p->mStateLocation) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_statesDefinitionList  GGS_L_statesDefinitionList::
constructor_empty (void) {
  GGS_L_statesDefinitionList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_statesDefinitionList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_AC_machineDefinition'                 *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_AC_machineDefinition'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_machineDefinition::
GGS_AC_machineDefinition (void) {
  mPointer = (cPtr_AC_machineDefinition *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition::
GGS_AC_machineDefinition (const GGS_AC_machineDefinition & inOperand) {
  mPointer = (cPtr_AC_machineDefinition *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition::
~GGS_AC_machineDefinition (void) {
  macroDetachPointer (mPointer, cPtr_AC_machineDefinition) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_machineDefinition::
operator = (const GGS_AC_machineDefinition & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

bool GGS_AC_machineDefinition::isBuilt (void) const {
  bool result = false ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->isBuilt () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_AC_machineDefinition::
operator = (cPtr_AC_machineDefinition * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_AC_machineDefinition::
GGS_AC_machineDefinition (cPtr_AC_machineDefinition * inSource) {
  mPointer = (cPtr_AC_machineDefinition *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

cPtr_AC_machineDefinition * GGS_AC_machineDefinition
::operator () (void) const {
  macroValidPointer (mPointer) ;
  return mPointer ;
}

//---------------------------------------------------------------------------*

void GGS_AC_machineDefinition
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_machineDefinition) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map 'M_modesMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_M_modesMap::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_modesMap & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_modesMap::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_M_modesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_M_modesMap * info = (e_M_modesMap *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_M_modesMap::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_M_modesMap::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_modesMap GGS_M_modesMap::constructor_empty (void) {
  GGS_M_modesMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_modesMap::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_modesMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_modesMap::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_AC_machineDefinition &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()) {
     insulateMap () ;
    e_M_modesMap info  ;
    info.mModeDefinition = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_modesMap::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_AC_machineDefinition   * outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mModeDefinition ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_M_modesMap (C_lexique & inLexique,
                                GGS_M_modesMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_AC_machineDefinition   * outParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' mode is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_M_modesMap (C_lexique & lexique_var_,
                                GGS_M_modesMap & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_AC_machineDefinition & inParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' mode has been already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Class element of list 'L_exclusionListForModes'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_exclusionListForModes::element_type::
element_type (const GGS_luint & argument_0,
                                const GGS_luint & argument_1) {
  mNextItem = (element_type *) NULL ;
  mExcludedSourceMode = argument_0 ;
  mExcludedTargetMode = argument_1 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class list 'L_exclusionListForModes'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_exclusionListForModes
::GGS_L_exclusionListForModes (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_exclusionListForModes::~GGS_L_exclusionListForModes (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_exclusionListForModes::GGS_L_exclusionListForModes (const GGS_L_exclusionListForModes & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_exclusionListForModes
::operator = (const GGS_L_exclusionListForModes & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_exclusionListForModes
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_exclusionListForModes::
internalAppendItem (const GGS_luint & argument_0,
                                const GGS_luint & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_exclusionListForModes::
addAssign_operation (const GGS_luint & argument_0,
                                const GGS_luint & argument_1) {
  if (isBuilt ()
                 && argument_0.isBuilt ()
                 && argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_exclusionListForModes
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mExcludedSourceMode,
                                p->mExcludedTargetMode) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_exclusionListForModes  GGS_L_exclusionListForModes::
constructor_empty (void) {
  GGS_L_exclusionListForModes result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_exclusionListForModes
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'C_modalCompositionComponent'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_modalCompositionComponent::cPtr_C_modalCompositionComponent (const GGS_M_modesMap & argument_0,
                                const GGS_L_exclusionListForModes & argument_1)
:mModeMap (argument_0),
mExclusionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_modalCompositionComponent::isBuilt (void) const {
  return mModeMap.isBuilt () &&
       mExclusionList.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_C_modalCompositionComponent'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_modalCompositionComponent * GGS_C_modalCompositionComponent::
    constructor_new (const GGS_M_modesMap & argument_0,
                                const GGS_L_exclusionListForModes & argument_1) {
    cPtr_C_modalCompositionComponent * ptr_ = (cPtr_C_modalCompositionComponent *) NULL ;
    macroMyNew (ptr_, cPtr_C_modalCompositionComponent (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Class element of list 'L_translationVector'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_translationVector::element_type::
element_type (const GGS_luint & argument_0) {
  mNextItem = (element_type *) NULL ;
  mTargetSlot = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class list 'L_translationVector'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_translationVector
::GGS_L_translationVector (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_translationVector::~GGS_L_translationVector (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_translationVector::GGS_L_translationVector (const GGS_L_translationVector & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector
::operator = (const GGS_L_translationVector & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector::
internalAppendItem (const GGS_luint & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector::
addAssign_operation (const GGS_luint & argument_0) {
  if (isBuilt ()
                 && argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mTargetSlot) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_translationVector  GGS_L_translationVector::
constructor_empty (void) {
  GGS_L_translationVector result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_translationVector
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_importMachine'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_importMachine::cPtr_C_importMachine (const GGS_uint & argument_0,
                                const GGS_L_translationVector & argument_1)
:mIndexOfImportedMachine (argument_0),
mTranslationVector (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_importMachine::isBuilt (void) const {
  return mIndexOfImportedMachine.isBuilt () &&
       mTranslationVector.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_importMachine'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_importMachine * GGS_C_importMachine::
    constructor_new (const GGS_uint & argument_0,
                                const GGS_L_translationVector & argument_1) {
    cPtr_C_importMachine * ptr_ = (cPtr_C_importMachine *) NULL ;
    macroMyNew (ptr_, cPtr_C_importMachine (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'C_explicitAutomatonDefinition'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_explicitAutomatonDefinition::cPtr_C_explicitAutomatonDefinition (const GGS_M_stateMap & argument_0,
                                const GGS_L_statesDefinitionList & argument_1,
                                const GGS_L_statesDefinitionList & argument_2,
                                const GGS_L_stateDefinition & argument_3,
                                const GGS_location & argument_4)
:mStatesMap (argument_0),
mInitialStatesDefinitionList (argument_1),
mTerminalStatesDefinitionList (argument_2),
mStateDefinitionList (argument_3),
mEndOfDefinition (argument_4) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_explicitAutomatonDefinition::isBuilt (void) const {
  return mStatesMap.isBuilt () &&
       mInitialStatesDefinitionList.isBuilt () &&
       mTerminalStatesDefinitionList.isBuilt () &&
       mStateDefinitionList.isBuilt () &&
       mEndOfDefinition.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_C_explicitAutomatonDefinition'              *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_explicitAutomatonDefinition * GGS_C_explicitAutomatonDefinition::
    constructor_new (const GGS_M_stateMap & argument_0,
                                const GGS_L_statesDefinitionList & argument_1,
                                const GGS_L_statesDefinitionList & argument_2,
                                const GGS_L_stateDefinition & argument_3,
                                const GGS_location & argument_4) {
    cPtr_C_explicitAutomatonDefinition * ptr_ = (cPtr_C_explicitAutomatonDefinition *) NULL ;
    macroMyNew (ptr_, cPtr_C_explicitAutomatonDefinition (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_variableDefinition'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_variableDefinition::cPtr_C_variableDefinition (const GGS_luint & argument_0)
:mInputOutputVariableIndex (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_variableDefinition::isBuilt (void) const {
  return mInputOutputVariableIndex.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_variableDefinition'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_variableDefinition * GGS_C_variableDefinition::
    constructor_new (const GGS_luint & argument_0) {
    cPtr_C_variableDefinition * ptr_ = (cPtr_C_variableDefinition *) NULL ;
    macroMyNew (ptr_, cPtr_C_variableDefinition (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'C_existsDefinition'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_existsDefinition::cPtr_C_existsDefinition (const GGS_uint & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_AC_machineDefinition & argument_2)
:mPreviousVariableCount (argument_0),
mTotalVariableCount (argument_1),
mOperand (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_existsDefinition::isBuilt (void) const {
  return mPreviousVariableCount.isBuilt () &&
       mTotalVariableCount.isBuilt () &&
       mOperand.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_existsDefinition'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_existsDefinition * GGS_C_existsDefinition::
    constructor_new (const GGS_uint & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_AC_machineDefinition & argument_2) {
    cPtr_C_existsDefinition * ptr_ = (cPtr_C_existsDefinition *) NULL ;
    macroMyNew (ptr_, cPtr_C_existsDefinition (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_andComposition'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_andComposition::cPtr_C_andComposition (const GGS_AC_machineDefinition & argument_0,
                                const GGS_AC_machineDefinition & argument_1)
:mLeftOperand (argument_0),
mRightOperand (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_andComposition::isBuilt (void) const {
  return mLeftOperand.isBuilt () &&
       mRightOperand.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_andComposition'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_andComposition * GGS_C_andComposition::
    constructor_new (const GGS_AC_machineDefinition & argument_0,
                                const GGS_AC_machineDefinition & argument_1) {
    cPtr_C_andComposition * ptr_ = (cPtr_C_andComposition *) NULL ;
    macroMyNew (ptr_, cPtr_C_andComposition (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_orComposition'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_orComposition::cPtr_C_orComposition (const GGS_AC_machineDefinition & argument_0,
                                const GGS_AC_machineDefinition & argument_1)
:mLeftOperand (argument_0),
mRightOperand (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_orComposition::isBuilt (void) const {
  return mLeftOperand.isBuilt () &&
       mRightOperand.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_orComposition'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_orComposition * GGS_C_orComposition::
    constructor_new (const GGS_AC_machineDefinition & argument_0,
                                const GGS_AC_machineDefinition & argument_1) {
    cPtr_C_orComposition * ptr_ = (cPtr_C_orComposition *) NULL ;
    macroMyNew (ptr_, cPtr_C_orComposition (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'C_equalComposition'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_equalComposition::cPtr_C_equalComposition (const GGS_AC_machineDefinition & argument_0,
                                const GGS_AC_machineDefinition & argument_1)
:mLeftOperand (argument_0),
mRightOperand (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_equalComposition::isBuilt (void) const {
  return mLeftOperand.isBuilt () &&
       mRightOperand.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_equalComposition'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_equalComposition * GGS_C_equalComposition::
    constructor_new (const GGS_AC_machineDefinition & argument_0,
                                const GGS_AC_machineDefinition & argument_1) {
    cPtr_C_equalComposition * ptr_ = (cPtr_C_equalComposition *) NULL ;
    macroMyNew (ptr_, cPtr_C_equalComposition (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_xorComposition'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_xorComposition::cPtr_C_xorComposition (const GGS_AC_machineDefinition & argument_0,
                                const GGS_AC_machineDefinition & argument_1)
:mLeftOperand (argument_0),
mRightOperand (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_xorComposition::isBuilt (void) const {
  return mLeftOperand.isBuilt () &&
       mRightOperand.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_xorComposition'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_xorComposition * GGS_C_xorComposition::
    constructor_new (const GGS_AC_machineDefinition & argument_0,
                                const GGS_AC_machineDefinition & argument_1) {
    cPtr_C_xorComposition * ptr_ = (cPtr_C_xorComposition *) NULL ;
    macroMyNew (ptr_, cPtr_C_xorComposition (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_impliesComposition'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_impliesComposition::cPtr_C_impliesComposition (const GGS_AC_machineDefinition & argument_0,
                                const GGS_AC_machineDefinition & argument_1)
:mLeftOperand (argument_0),
mRightOperand (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_impliesComposition::isBuilt (void) const {
  return mLeftOperand.isBuilt () &&
       mRightOperand.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_impliesComposition'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_impliesComposition * GGS_C_impliesComposition::
    constructor_new (const GGS_AC_machineDefinition & argument_0,
                                const GGS_AC_machineDefinition & argument_1) {
    cPtr_C_impliesComposition * ptr_ = (cPtr_C_impliesComposition *) NULL ;
    macroMyNew (ptr_, cPtr_C_impliesComposition (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'C_strongModalComposition'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_strongModalComposition::cPtr_C_strongModalComposition (const GGS_AC_machineDefinition & argument_0,
                                const GGS_location & argument_1,
                                const GGS_AC_machineDefinition & argument_2)
:mLeftOperand (argument_0),
mErrorLocation (argument_1),
mRightOperand (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_strongModalComposition::isBuilt (void) const {
  return mLeftOperand.isBuilt () &&
       mErrorLocation.isBuilt () &&
       mRightOperand.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_C_strongModalComposition'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_strongModalComposition * GGS_C_strongModalComposition::
    constructor_new (const GGS_AC_machineDefinition & argument_0,
                                const GGS_location & argument_1,
                                const GGS_AC_machineDefinition & argument_2) {
    cPtr_C_strongModalComposition * ptr_ = (cPtr_C_strongModalComposition *) NULL ;
    macroMyNew (ptr_, cPtr_C_strongModalComposition (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'C_weakModalComposition'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_weakModalComposition::cPtr_C_weakModalComposition (const GGS_AC_machineDefinition & argument_0,
                                const GGS_location & argument_1,
                                const GGS_AC_machineDefinition & argument_2)
:mLeftOperand (argument_0),
mErrorLocation (argument_1),
mRightOperand (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_weakModalComposition::isBuilt (void) const {
  return mLeftOperand.isBuilt () &&
       mErrorLocation.isBuilt () &&
       mRightOperand.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_weakModalComposition'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_weakModalComposition * GGS_C_weakModalComposition::
    constructor_new (const GGS_AC_machineDefinition & argument_0,
                                const GGS_location & argument_1,
                                const GGS_AC_machineDefinition & argument_2) {
    cPtr_C_weakModalComposition * ptr_ = (cPtr_C_weakModalComposition *) NULL ;
    macroMyNew (ptr_, cPtr_C_weakModalComposition (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_notComposition'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_notComposition::cPtr_C_notComposition (const GGS_AC_machineDefinition & argument_0)
:mOperand (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_notComposition::isBuilt (void) const {
  return mOperand.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_notComposition'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_notComposition * GGS_C_notComposition::
    constructor_new (const GGS_AC_machineDefinition & argument_0) {
    cPtr_C_notComposition * ptr_ = (cPtr_C_notComposition *) NULL ;
    macroMyNew (ptr_, cPtr_C_notComposition (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'C_fullSaturationOperation'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_fullSaturationOperation::cPtr_C_fullSaturationOperation (const GGS_AC_machineDefinition & argument_0)
:mOperand (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_fullSaturationOperation::isBuilt (void) const {
  return mOperand.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_C_fullSaturationOperation'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_fullSaturationOperation * GGS_C_fullSaturationOperation::
    constructor_new (const GGS_AC_machineDefinition & argument_0) {
    cPtr_C_fullSaturationOperation * ptr_ = (cPtr_C_fullSaturationOperation *) NULL ;
    macroMyNew (ptr_, cPtr_C_fullSaturationOperation (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'C_suppressTerminalStatesOperation'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_suppressTerminalStatesOperation::cPtr_C_suppressTerminalStatesOperation (const GGS_AC_machineDefinition & argument_0)
:mOperand (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_suppressTerminalStatesOperation::isBuilt (void) const {
  return mOperand.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_C_suppressTerminalStatesOperation'            *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_suppressTerminalStatesOperation * GGS_C_suppressTerminalStatesOperation::
    constructor_new (const GGS_AC_machineDefinition & argument_0) {
    cPtr_C_suppressTerminalStatesOperation * ptr_ = (cPtr_C_suppressTerminalStatesOperation *) NULL ;
    macroMyNew (ptr_, cPtr_C_suppressTerminalStatesOperation (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       abstract class 'cPtr_AC_job'                        *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                        GALGAS class 'GGS_AC_job'                          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_job::
GGS_AC_job (void) {
  mPointer = (cPtr_AC_job *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_AC_job::
GGS_AC_job (const GGS_AC_job & inOperand) {
  mPointer = (cPtr_AC_job *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_job::
~GGS_AC_job (void) {
  macroDetachPointer (mPointer, cPtr_AC_job) ;
}

//---------------------------------------------------------------------------*

void GGS_AC_job::
operator = (const GGS_AC_job & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

bool GGS_AC_job::isBuilt (void) const {
  bool result = false ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->isBuilt () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_AC_job::
operator = (cPtr_AC_job * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_AC_job::
GGS_AC_job (cPtr_AC_job * inSource) {
  mPointer = (cPtr_AC_job *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

cPtr_AC_job * GGS_AC_job
::operator () (void) const {
  macroValidPointer (mPointer) ;
  return mPointer ;
}

//---------------------------------------------------------------------------*

void GGS_AC_job
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_AC_job) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'C_machineCheck'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_machineCheck::cPtr_C_machineCheck (const GGS_luint & argument_0)
:mMachineIndex (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_machineCheck::isBuilt (void) const {
  return mMachineIndex.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_machineCheck'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_machineCheck * GGS_C_machineCheck::
    constructor_new (const GGS_luint & argument_0) {
    cPtr_C_machineCheck * ptr_ = (cPtr_C_machineCheck *) NULL ;
    macroMyNew (ptr_, cPtr_C_machineCheck (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'C_machineComponent'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_machineComponent::cPtr_C_machineComponent (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_uint & argument_2,
                                const GGS_uint & argument_3,
                                const GGS_M_variablesMap & argument_4,
                                const GGS_AC_machineDefinition & argument_5)
:mMachineName (argument_0),
mMachineIndex (argument_1),
mInputVariableCount (argument_2),
mInputAndInternalVariableCount (argument_3),
mVariablesMap (argument_4),
mDefinition (argument_5) {
}

//---------------------------------------------------------------------------*

bool cPtr_C_machineComponent::isBuilt (void) const {
  return mMachineName.isBuilt () &&
       mMachineIndex.isBuilt () &&
       mInputVariableCount.isBuilt () &&
       mInputAndInternalVariableCount.isBuilt () &&
       mVariablesMap.isBuilt () &&
       mDefinition.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_machineComponent'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_machineComponent * GGS_C_machineComponent::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_uint & argument_2,
                                const GGS_uint & argument_3,
                                const GGS_M_variablesMap & argument_4,
                                const GGS_AC_machineDefinition & argument_5) {
    cPtr_C_machineComponent * ptr_ = (cPtr_C_machineComponent *) NULL ;
    macroMyNew (ptr_, cPtr_C_machineComponent (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeUse_AND'                             *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeUse_AND::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeUse_AND'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeUse_AND * GGS_typeUse_AND::
    constructor_new () {
    cPtr_typeUse_AND * ptr_ = (cPtr_typeUse_AND *) NULL ;
    macroMyNew (ptr_, cPtr_typeUse_AND ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeUse_ITE'                             *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeUse_ITE::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeUse_ITE'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeUse_ITE * GGS_typeUse_ITE::
    constructor_new () {
    cPtr_typeUse_ITE * ptr_ = (cPtr_typeUse_ITE *) NULL ;
    macroMyNew (ptr_, cPtr_typeUse_ITE ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeUse_AND_ITE'                           *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeUse_AND_ITE::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeUse_AND_ITE'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeUse_AND_ITE * GGS_typeUse_AND_ITE::
    constructor_new () {
    cPtr_typeUse_AND_ITE * ptr_ = (cPtr_typeUse_AND_ITE *) NULL ;
    macroMyNew (ptr_, cPtr_typeUse_AND_ITE ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeResize_AND_cache'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeResize_AND_cache::cPtr_typeResize_AND_cache (const GGS_luint & argument_0)
:mNewSize (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeResize_AND_cache::isBuilt (void) const {
  return mNewSize.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeResize_AND_cache'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeResize_AND_cache * GGS_typeResize_AND_cache::
    constructor_new (const GGS_luint & argument_0) {
    cPtr_typeResize_AND_cache * ptr_ = (cPtr_typeResize_AND_cache *) NULL ;
    macroMyNew (ptr_, cPtr_typeResize_AND_cache (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeResize_ITE_cache'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeResize_ITE_cache::cPtr_typeResize_ITE_cache (const GGS_luint & argument_0)
:mNewSize (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeResize_ITE_cache::isBuilt (void) const {
  return mNewSize.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeResize_ITE_cache'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeResize_ITE_cache * GGS_typeResize_ITE_cache::
    constructor_new (const GGS_luint & argument_0) {
    cPtr_typeResize_ITE_cache * ptr_ = (cPtr_typeResize_ITE_cache *) NULL ;
    macroMyNew (ptr_, cPtr_typeResize_ITE_cache (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeResizeMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeResizeMap::cPtr_typeResizeMap (const GGS_luint & argument_0)
:mNewSize (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeResizeMap::isBuilt (void) const {
  return mNewSize.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeResizeMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeResizeMap * GGS_typeResizeMap::
    constructor_new (const GGS_luint & argument_0) {
    cPtr_typeResizeMap * ptr_ = (cPtr_typeResizeMap *) NULL ;
    macroMyNew (ptr_, cPtr_typeResizeMap (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeDisplayBDDstats'                         *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeDisplayBDDstats::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDisplayBDDstats'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeDisplayBDDstats * GGS_typeDisplayBDDstats::
    constructor_new () {
    cPtr_typeDisplayBDDstats * ptr_ = (cPtr_typeDisplayBDDstats *) NULL ;
    macroMyNew (ptr_, cPtr_typeDisplayBDDstats ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    Class element of list 'L_jobList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_jobList::element_type::
element_type (const GGS_AC_job & argument_0) {
  mNextItem = (element_type *) NULL ;
  mComponent = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class list 'L_jobList'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_jobList
::GGS_L_jobList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_jobList::~GGS_L_jobList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_jobList::GGS_L_jobList (const GGS_L_jobList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_jobList
::operator = (const GGS_L_jobList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_jobList
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_jobList::
internalAppendItem (const GGS_AC_job & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_jobList::
addAssign_operation (const GGS_AC_job & argument_0) {
  if (isBuilt ()
                 && argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_jobList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mComponent) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_jobList  GGS_L_jobList::
constructor_empty (void) {
  GGS_L_jobList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_jobList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'M_machinesMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_M_machinesMap::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_machinesMap & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_machinesMap::
new_element (void * inKey, void * inInfo) {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  M_assert (reinterpret_cast <e_M_machinesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_M_machinesMap * info = (e_M_machinesMap *) inInfo ;
  macroMyNew (p, element_type (* key, getCount (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_M_machinesMap::element_type::compareKeys (void * inKey) const {
  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_string GGS_M_machinesMap::element_type::getStringForKey (void) const {
  C_string result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_machinesMap GGS_M_machinesMap::constructor_empty (void) {
  GGS_M_machinesMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_machinesMap::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_machinesMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_machinesMap::
insertElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_uint &  inParameter0,
               const GGS_uint &  inParameter1,
               const GGS_M_variablesMap &  inParameter2,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()
                 && inParameter1.isBuilt ()
                 && inParameter2.isBuilt ()) {
     insulateMap () ;
    e_M_machinesMap info  ;
    info.mInputVariableCount = inParameter0 ;
    info.mInputAndInternalVariableCount = inParameter1 ;
    info.mVariablesMap = inParameter2 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_machinesMap::
searchElement (C_lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_uint   * outParameter0,
               GGS_uint   * outParameter1,
               GGS_M_variablesMap   * outParameter2,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_string keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outParameter1 != NULL) {
      outParameter1->drop_operation () ;
    }
    if (outParameter2 != NULL) {
      outParameter2->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mInputVariableCount ;
    }
    if (outParameter1 != NULL) {
      * outParameter1 = node->mInfo.mInputAndInternalVariableCount ;
    }
    if (outParameter2 != NULL) {
      * outParameter2 = node->mInfo.mVariablesMap ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_M_machinesMap (C_lexique & inLexique,
                                GGS_M_machinesMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_uint   * outParameter0,
                                GGS_uint   * outParameter1,
                                GGS_M_variablesMap   * outParameter2,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' machine is not defined",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outParameter1,
                       outParameter2,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_M_machinesMap (C_lexique & lexique_var_,
                                GGS_M_machinesMap & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0,
                                const GGS_uint & inParameter1,
                                const GGS_M_variablesMap & inParameter2,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' machine has been already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       inParameter1,
                       inParameter2,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

