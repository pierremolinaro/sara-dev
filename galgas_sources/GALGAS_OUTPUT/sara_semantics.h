//---------------------------------------------------------------------------*
//                                                                           *
//                         File 'sara_semantics.h'                           *
//               Generated by version 0.14.1 (LL(1) grammar)                 *
//                     february 8th, 2005, at 18h26'35"                      *
//                                                                           *
// This program is free software; you can redistribute it and/or modify it   *
// under the terms of the GNU General Public License as published by the     *
// Free Software Foundation.                                                 *
//                                                                           *
// This program is distributed in the hope it will be useful, but WITHOUT    *
// ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or     *
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for  *
// more details.                                                             *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#ifndef sara_semantics_DEFINED
#define sara_semantics_DEFINED

#include <string.h>

// Include predefined semantics types definition *
#include "memory/C_reference_count.h"
#include "galgas/AC_galgas_io.h"
#include "galgas/GGS_location.h"
#include "galgas/GGS_lbool.h"
#include "galgas/GGS_lchar.h"
#include "galgas/GGS_lstring.h"
#include "galgas/GGS_ldfloat.h"
#include "galgas/GGS_luint.h"
#include "galgas/GGS_lsint.h"
#include "galgas/AC_galgas_map.h"
// Include scanner definition *
#include "galgas/C_lexique.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                  DECLARATIONS FOR MAP 'M_variablesMap'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class e_M_variablesMap {
} ;

//---------------------------------------------------------------------------*

class GGS_M_variablesMap : public AC_galgas_map {
//--- Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_M_variablesMap & inInfo) ;
  //--- Method for key compare
    public : virtual sint32 compareKeys (void * inKey) const ;
  //--- Method for getting key as C_string
    public : virtual C_string getStringForKey (void) const ;
  //--- Get pointers
    public : inline element_type * getNextItem (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * getInfPtr (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * getSupPtr (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : const GGS_lstring mKey ;
    public : e_M_variablesMap mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * getRoot (void) const { return (element_type *) mRoot ; }
  public : inline element_type * getFirstItem (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * getLastItem (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;
//--- 'empty' constructor
  public : static GGS_M_variablesMap constructor_empty (void) ;
//--- 'hasKey' reader
  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- Insert an element
  public : void insertElement (C_lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_luint * outIndex) ;
//--- Search for an element
  public : void searchElement (C_lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*

void searchKey_M_variablesMap (C_lexique & inLexique,
                                GGS_M_variablesMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*

void insertKey_M_variablesMap (C_lexique & inLexique,
                                GGS_M_variablesMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    DECLARATIONS FOR MAP 'M_stateMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class e_M_stateMap {
} ;

//---------------------------------------------------------------------------*

class GGS_M_stateMap : public AC_galgas_map {
//--- Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_M_stateMap & inInfo) ;
  //--- Method for key compare
    public : virtual sint32 compareKeys (void * inKey) const ;
  //--- Method for getting key as C_string
    public : virtual C_string getStringForKey (void) const ;
  //--- Get pointers
    public : inline element_type * getNextItem (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * getInfPtr (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * getSupPtr (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : const GGS_lstring mKey ;
    public : e_M_stateMap mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * getRoot (void) const { return (element_type *) mRoot ; }
  public : inline element_type * getFirstItem (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * getLastItem (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;
//--- 'empty' constructor
  public : static GGS_M_stateMap constructor_empty (void) ;
//--- 'hasKey' reader
  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- Insert an element
  public : void insertElement (C_lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_luint * outIndex) ;
//--- Search for an element
  public : void searchElement (C_lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*

void searchKey_M_stateMap (C_lexique & inLexique,
                                GGS_M_stateMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*

void insertKey_M_stateMap (C_lexique & inLexique,
                                GGS_M_stateMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*

void defineState_M_stateMap (C_lexique & inLexique,
                                GGS_M_stateMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_luint * outIndex) ;

class cPtr_AC_expression ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_AC_expression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_AC_expression {
  protected : cPtr_AC_expression * mPointer ;
  public : GGS_AC_expression (void) ;
  public : GGS_AC_expression (const GGS_AC_expression &) ;
  public : virtual ~GGS_AC_expression (void) ;
  public : void operator = (const GGS_AC_expression &) ;
  public : bool isBuilt (void) const ;
  public : inline bool isEqualTo (const GGS_AC_expression & operand_) const {
    return mPointer == operand_.mPointer ;
  }
  public : void operator = (cPtr_AC_expression * inSource) ;
  public : GGS_AC_expression (cPtr_AC_expression * inSource) ;
  public : inline cPtr_AC_expression * getPtr (void) const {
    return mPointer ;
  }
  public : void drop_operation (void) ;
  public : cPtr_AC_expression * operator () (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class list 'L_transitionDefinition'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_L_transitionDefinition {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_AC_expression  mActionExpression ;
    public : GGS_location  mEndOfExpression ;
    public : GGS_luint  mTargetStateIndex ;
    public : element_type (const GGS_AC_expression & ,
                                const GGS_location & ,
                                const GGS_luint & ) ;

    public : inline element_type * getNextItem (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_L_transitionDefinition ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 getCount (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_L_transitionDefinition (void) ; // Default Constructor
  public : GGS_L_transitionDefinition (const GGS_L_transitionDefinition &) ; // Copy constructor
  public : void operator = (const GGS_L_transitionDefinition &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_L_transitionDefinition (void) ;

//--- Constructor 'new'
  public : static GGS_L_transitionDefinition constructor_empty (void) ;
//--- Get first item
  public : inline element_type * getFirstItem (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_AC_expression & argument_0,
                                const GGS_location & argument_1,
                                const GGS_luint & argument_2) ;
  protected : void internalAppendItem (const GGS_AC_expression & argument_0,
                                const GGS_location & argument_1,
                                const GGS_luint & argument_2) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class list 'L_stateDefinition'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_L_stateDefinition {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_luint  mStateIndex ;
    public : GGS_AC_expression  mStateExpression ;
    public : GGS_location  mEndOfStateExpression ;
    public : GGS_L_transitionDefinition  mTransitionsList ;
    public : element_type (const GGS_luint & ,
                                const GGS_AC_expression & ,
                                const GGS_location & ,
                                const GGS_L_transitionDefinition & ) ;

    public : inline element_type * getNextItem (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_L_stateDefinition ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 getCount (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_L_stateDefinition (void) ; // Default Constructor
  public : GGS_L_stateDefinition (const GGS_L_stateDefinition &) ; // Copy constructor
  public : void operator = (const GGS_L_stateDefinition &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_L_stateDefinition (void) ;

//--- Constructor 'new'
  public : static GGS_L_stateDefinition constructor_empty (void) ;
//--- Get first item
  public : inline element_type * getFirstItem (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_luint & argument_0,
                                const GGS_AC_expression & argument_1,
                                const GGS_location & argument_2,
                                const GGS_L_transitionDefinition & argument_3) ;
  protected : void internalAppendItem (const GGS_luint & argument_0,
                                const GGS_AC_expression & argument_1,
                                const GGS_location & argument_2,
                                const GGS_L_transitionDefinition & argument_3) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class list 'L_initialStatesDefinitionList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_L_initialStatesDefinitionList {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_luint  mInitialStateIndex ;
    public : GGS_location  mInitialStateLocation ;
    public : element_type (const GGS_luint & ,
                                const GGS_location & ) ;

    public : inline element_type * getNextItem (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_L_initialStatesDefinitionList ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 getCount (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_L_initialStatesDefinitionList (void) ; // Default Constructor
  public : GGS_L_initialStatesDefinitionList (const GGS_L_initialStatesDefinitionList &) ; // Copy constructor
  public : void operator = (const GGS_L_initialStatesDefinitionList &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_L_initialStatesDefinitionList (void) ;

//--- Constructor 'new'
  public : static GGS_L_initialStatesDefinitionList constructor_empty (void) ;
//--- Get first item
  public : inline element_type * getFirstItem (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_luint & argument_0,
                                const GGS_location & argument_1) ;
  protected : void internalAppendItem (const GGS_luint & argument_0,
                                const GGS_location & argument_1) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

class cPtr_AC_machineDefinition ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_AC_machineDefinition'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_AC_machineDefinition {
  protected : cPtr_AC_machineDefinition * mPointer ;
  public : GGS_AC_machineDefinition (void) ;
  public : GGS_AC_machineDefinition (const GGS_AC_machineDefinition &) ;
  public : virtual ~GGS_AC_machineDefinition (void) ;
  public : void operator = (const GGS_AC_machineDefinition &) ;
  public : bool isBuilt (void) const ;
  public : inline bool isEqualTo (const GGS_AC_machineDefinition & operand_) const {
    return mPointer == operand_.mPointer ;
  }
  public : void operator = (cPtr_AC_machineDefinition * inSource) ;
  public : GGS_AC_machineDefinition (cPtr_AC_machineDefinition * inSource) ;
  public : inline cPtr_AC_machineDefinition * getPtr (void) const {
    return mPointer ;
  }
  public : void drop_operation (void) ;
  public : cPtr_AC_machineDefinition * operator () (void) const ;
} ;

class cPtr_AC_component ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_AC_component'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_AC_component {
  protected : cPtr_AC_component * mPointer ;
  public : GGS_AC_component (void) ;
  public : GGS_AC_component (const GGS_AC_component &) ;
  public : virtual ~GGS_AC_component (void) ;
  public : void operator = (const GGS_AC_component &) ;
  public : bool isBuilt (void) const ;
  public : inline bool isEqualTo (const GGS_AC_component & operand_) const {
    return mPointer == operand_.mPointer ;
  }
  public : void operator = (cPtr_AC_component * inSource) ;
  public : GGS_AC_component (cPtr_AC_component * inSource) ;
  public : inline cPtr_AC_component * getPtr (void) const {
    return mPointer ;
  }
  public : void drop_operation (void) ;
  public : cPtr_AC_component * operator () (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  DECLARATIONS FOR MAP 'M_componentMap'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class e_M_componentMap {
  public : GGS_AC_component  mComponent ;
} ;

//---------------------------------------------------------------------------*

class GGS_M_componentMap : public AC_galgas_map {
//--- Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_M_componentMap & inInfo) ;
  //--- Method for key compare
    public : virtual sint32 compareKeys (void * inKey) const ;
  //--- Method for getting key as C_string
    public : virtual C_string getStringForKey (void) const ;
  //--- Get pointers
    public : inline element_type * getNextItem (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * getInfPtr (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * getSupPtr (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : const GGS_lstring mKey ;
    public : e_M_componentMap mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * getRoot (void) const { return (element_type *) mRoot ; }
  public : inline element_type * getFirstItem (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * getLastItem (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;
//--- 'empty' constructor
  public : static GGS_M_componentMap constructor_empty (void) ;
//--- 'hasKey' reader
  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- Insert an element
  public : void insertElement (C_lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               const GGS_AC_component & inParameter0,
                               GGS_luint * outIndex) ;
//--- Search for an element
  public : void searchElement (C_lexique & inLexique,
                               const char * inErrorMessagesArray [],
                               const GGS_lstring & inKey,
                               GGS_AC_component * outParameter0,
                               GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*

void insertKey_M_componentMap (C_lexique & inLexique,
                                GGS_M_componentMap & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_AC_component &  inParameter0,
                                GGS_luint * outIndex) ;

//---------------------------------------------------------------------------*

void defineState_M_componentMap (C_lexique & inLexique,
                                GGS_M_componentMap & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_AC_component &  inParameter0,
                                GGS_luint * outIndex) ;

#include "include_AC_expression.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_andExpression'                           *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_C_andExpression

#define macroInheritFrom_C_andExpression

class cPtr_C_andExpression : public cPtr_AC_expression {
  private : typedef cPtr_AC_expression inherited ;
  macroInheritFrom_AC_expression
  macro_C_andExpression
  public : cPtr_C_andExpression (const GGS_AC_expression & ,
                                const GGS_AC_expression & ) ;
  public : GGS_AC_expression  mLeftExpression ;
  public : GGS_AC_expression  mRightExpression ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_andExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_andExpression {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_C_andExpression * constructor_new (const GGS_AC_expression & argument_0,
                                const GGS_AC_expression & argument_1) ;
  #else
    public : inline static cPtr_C_andExpression * constructor_new (const GGS_AC_expression & argument_0,
                                const GGS_AC_expression & argument_1) {
      return new cPtr_C_andExpression(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'C_orExpression'                           *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_C_orExpression

#define macroInheritFrom_C_orExpression

class cPtr_C_orExpression : public cPtr_AC_expression {
  private : typedef cPtr_AC_expression inherited ;
  macroInheritFrom_AC_expression
  macro_C_orExpression
  public : cPtr_C_orExpression (const GGS_AC_expression & ,
                                const GGS_AC_expression & ) ;
  public : GGS_AC_expression  mLeftExpression ;
  public : GGS_AC_expression  mRightExpression ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_orExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_orExpression {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_C_orExpression * constructor_new (const GGS_AC_expression & argument_0,
                                const GGS_AC_expression & argument_1) ;
  #else
    public : inline static cPtr_C_orExpression * constructor_new (const GGS_AC_expression & argument_0,
                                const GGS_AC_expression & argument_1) {
      return new cPtr_C_orExpression(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_xorExpression'                           *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_C_xorExpression

#define macroInheritFrom_C_xorExpression

class cPtr_C_xorExpression : public cPtr_AC_expression {
  private : typedef cPtr_AC_expression inherited ;
  macroInheritFrom_AC_expression
  macro_C_xorExpression
  public : cPtr_C_xorExpression (const GGS_AC_expression & ,
                                const GGS_AC_expression & ) ;
  public : GGS_AC_expression  mLeftExpression ;
  public : GGS_AC_expression  mRightExpression ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_xorExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_xorExpression {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_C_xorExpression * constructor_new (const GGS_AC_expression & argument_0,
                                const GGS_AC_expression & argument_1) ;
  #else
    public : inline static cPtr_C_xorExpression * constructor_new (const GGS_AC_expression & argument_0,
                                const GGS_AC_expression & argument_1) {
      return new cPtr_C_xorExpression(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_impliesExpression'                         *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_C_impliesExpression

#define macroInheritFrom_C_impliesExpression

class cPtr_C_impliesExpression : public cPtr_AC_expression {
  private : typedef cPtr_AC_expression inherited ;
  macroInheritFrom_AC_expression
  macro_C_impliesExpression
  public : cPtr_C_impliesExpression (const GGS_AC_expression & ,
                                const GGS_AC_expression & ) ;
  public : GGS_AC_expression  mLeftExpression ;
  public : GGS_AC_expression  mRightExpression ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_impliesExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_impliesExpression {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_C_impliesExpression * constructor_new (const GGS_AC_expression & argument_0,
                                const GGS_AC_expression & argument_1) ;
  #else
    public : inline static cPtr_C_impliesExpression * constructor_new (const GGS_AC_expression & argument_0,
                                const GGS_AC_expression & argument_1) {
      return new cPtr_C_impliesExpression(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'C_equalExpression'                          *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_C_equalExpression

#define macroInheritFrom_C_equalExpression

class cPtr_C_equalExpression : public cPtr_AC_expression {
  private : typedef cPtr_AC_expression inherited ;
  macroInheritFrom_AC_expression
  macro_C_equalExpression
  public : cPtr_C_equalExpression (const GGS_AC_expression & ,
                                const GGS_AC_expression & ) ;
  public : GGS_AC_expression  mLeftExpression ;
  public : GGS_AC_expression  mRightExpression ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_equalExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_equalExpression {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_C_equalExpression * constructor_new (const GGS_AC_expression & argument_0,
                                const GGS_AC_expression & argument_1) ;
  #else
    public : inline static cPtr_C_equalExpression * constructor_new (const GGS_AC_expression & argument_0,
                                const GGS_AC_expression & argument_1) {
      return new cPtr_C_equalExpression(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_notExpression'                           *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_C_notExpression

#define macroInheritFrom_C_notExpression

class cPtr_C_notExpression : public cPtr_AC_expression {
  private : typedef cPtr_AC_expression inherited ;
  macroInheritFrom_AC_expression
  macro_C_notExpression
  public : cPtr_C_notExpression (const GGS_AC_expression & ) ;
  public : GGS_AC_expression  mExpression ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_notExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_notExpression {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_C_notExpression * constructor_new (const GGS_AC_expression & argument_0) ;
  #else
    public : inline static cPtr_C_notExpression * constructor_new (const GGS_AC_expression & argument_0) {
      return new cPtr_C_notExpression(argument_0) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_VariableExpression'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_C_VariableExpression

#define macroInheritFrom_C_VariableExpression

class cPtr_C_VariableExpression : public cPtr_AC_expression {
  private : typedef cPtr_AC_expression inherited ;
  macroInheritFrom_AC_expression
  macro_C_VariableExpression
  public : cPtr_C_VariableExpression (const GGS_luint & ) ;
  public : GGS_luint  mInputVarIndex ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_VariableExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_VariableExpression {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_C_VariableExpression * constructor_new (const GGS_luint & argument_0) ;
  #else
    public : inline static cPtr_C_VariableExpression * constructor_new (const GGS_luint & argument_0) {
      return new cPtr_C_VariableExpression(argument_0) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_trueExpression'                          *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_C_trueExpression

#define macroInheritFrom_C_trueExpression

class cPtr_C_trueExpression : public cPtr_AC_expression {
  private : typedef cPtr_AC_expression inherited ;
  macroInheritFrom_AC_expression
  macro_C_trueExpression
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_trueExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_trueExpression {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_C_trueExpression * constructor_new () ;
  #else
    public : inline static cPtr_C_trueExpression * constructor_new () {
      return new cPtr_C_trueExpression() ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'C_falseExpression'                          *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_C_falseExpression

#define macroInheritFrom_C_falseExpression

class cPtr_C_falseExpression : public cPtr_AC_expression {
  private : typedef cPtr_AC_expression inherited ;
  macroInheritFrom_AC_expression
  macro_C_falseExpression
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_falseExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_falseExpression {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_C_falseExpression * constructor_new () ;
  #else
    public : inline static cPtr_C_falseExpression * constructor_new () {
      return new cPtr_C_falseExpression() ;
    }
  #endif
} ;

#include "include_AC_machineDefinition.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'C_automatonDefinition'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_C_automatonDefinition

#define macroInheritFrom_C_automatonDefinition

class cPtr_C_automatonDefinition : public cPtr_AC_machineDefinition {
  private : typedef cPtr_AC_machineDefinition inherited ;
  macroInheritFrom_AC_machineDefinition
  macro_C_automatonDefinition
  public : cPtr_C_automatonDefinition (const GGS_M_stateMap & ,
                                const GGS_L_initialStatesDefinitionList & ,
                                const GGS_L_stateDefinition & ,
                                const GGS_location & ) ;
  public : GGS_M_stateMap  mStatesMap ;
  public : GGS_L_initialStatesDefinitionList  mInitialStatesDefinitionList ;
  public : GGS_L_stateDefinition  mStateDefinitionList ;
  public : GGS_location  mEndOfDefinition ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_automatonDefinition'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_automatonDefinition {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_C_automatonDefinition * constructor_new (const GGS_M_stateMap & argument_0,
                                const GGS_L_initialStatesDefinitionList & argument_1,
                                const GGS_L_stateDefinition & argument_2,
                                const GGS_location & argument_3) ;
  #else
    public : inline static cPtr_C_automatonDefinition * constructor_new (const GGS_M_stateMap & argument_0,
                                const GGS_L_initialStatesDefinitionList & argument_1,
                                const GGS_L_stateDefinition & argument_2,
                                const GGS_location & argument_3) {
      return new cPtr_C_automatonDefinition(argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_variableDefinition'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_C_variableDefinition

#define macroInheritFrom_C_variableDefinition

class cPtr_C_variableDefinition : public cPtr_AC_machineDefinition {
  private : typedef cPtr_AC_machineDefinition inherited ;
  macroInheritFrom_AC_machineDefinition
  macro_C_variableDefinition
  public : cPtr_C_variableDefinition (const GGS_luint & ) ;
  public : GGS_luint  mInputOutputVariableIndex ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_variableDefinition'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_variableDefinition {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_C_variableDefinition * constructor_new (const GGS_luint & argument_0) ;
  #else
    public : inline static cPtr_C_variableDefinition * constructor_new (const GGS_luint & argument_0) {
      return new cPtr_C_variableDefinition(argument_0) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'C_existsDefinition'                         *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_C_existsDefinition

#define macroInheritFrom_C_existsDefinition

class cPtr_C_existsDefinition : public cPtr_AC_machineDefinition {
  private : typedef cPtr_AC_machineDefinition inherited ;
  macroInheritFrom_AC_machineDefinition
  macro_C_existsDefinition
  public : cPtr_C_existsDefinition (const GGS_AC_machineDefinition & ,
                                const GGS_luint & ) ;
  public : GGS_AC_machineDefinition  mOperand ;
  public : GGS_luint  mInputOutputVariableIndex ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_existsDefinition'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_existsDefinition {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_C_existsDefinition * constructor_new (const GGS_AC_machineDefinition & argument_0,
                                const GGS_luint & argument_1) ;
  #else
    public : inline static cPtr_C_existsDefinition * constructor_new (const GGS_AC_machineDefinition & argument_0,
                                const GGS_luint & argument_1) {
      return new cPtr_C_existsDefinition(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_andComposition'                          *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_C_andComposition

#define macroInheritFrom_C_andComposition

class cPtr_C_andComposition : public cPtr_AC_machineDefinition {
  private : typedef cPtr_AC_machineDefinition inherited ;
  macroInheritFrom_AC_machineDefinition
  macro_C_andComposition
  public : cPtr_C_andComposition (const GGS_AC_machineDefinition & ,
                                const GGS_AC_machineDefinition & ) ;
  public : GGS_AC_machineDefinition  mLeftOperand ;
  public : GGS_AC_machineDefinition  mRightOperand ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_andComposition'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_andComposition {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_C_andComposition * constructor_new (const GGS_AC_machineDefinition & argument_0,
                                const GGS_AC_machineDefinition & argument_1) ;
  #else
    public : inline static cPtr_C_andComposition * constructor_new (const GGS_AC_machineDefinition & argument_0,
                                const GGS_AC_machineDefinition & argument_1) {
      return new cPtr_C_andComposition(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_orComposition'                           *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_C_orComposition

#define macroInheritFrom_C_orComposition

class cPtr_C_orComposition : public cPtr_AC_machineDefinition {
  private : typedef cPtr_AC_machineDefinition inherited ;
  macroInheritFrom_AC_machineDefinition
  macro_C_orComposition
  public : cPtr_C_orComposition (const GGS_AC_machineDefinition & ,
                                const GGS_AC_machineDefinition & ) ;
  public : GGS_AC_machineDefinition  mLeftOperand ;
  public : GGS_AC_machineDefinition  mRightOperand ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_C_orComposition'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_orComposition {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_C_orComposition * constructor_new (const GGS_AC_machineDefinition & argument_0,
                                const GGS_AC_machineDefinition & argument_1) ;
  #else
    public : inline static cPtr_C_orComposition * constructor_new (const GGS_AC_machineDefinition & argument_0,
                                const GGS_AC_machineDefinition & argument_1) {
      return new cPtr_C_orComposition(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'C_equalComposition'                         *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_C_equalComposition

#define macroInheritFrom_C_equalComposition

class cPtr_C_equalComposition : public cPtr_AC_machineDefinition {
  private : typedef cPtr_AC_machineDefinition inherited ;
  macroInheritFrom_AC_machineDefinition
  macro_C_equalComposition
  public : cPtr_C_equalComposition (const GGS_AC_machineDefinition & ,
                                const GGS_AC_machineDefinition & ) ;
  public : GGS_AC_machineDefinition  mLeftOperand ;
  public : GGS_AC_machineDefinition  mRightOperand ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_equalComposition'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_equalComposition {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_C_equalComposition * constructor_new (const GGS_AC_machineDefinition & argument_0,
                                const GGS_AC_machineDefinition & argument_1) ;
  #else
    public : inline static cPtr_C_equalComposition * constructor_new (const GGS_AC_machineDefinition & argument_0,
                                const GGS_AC_machineDefinition & argument_1) {
      return new cPtr_C_equalComposition(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_xorComposition'                          *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_C_xorComposition

#define macroInheritFrom_C_xorComposition

class cPtr_C_xorComposition : public cPtr_AC_machineDefinition {
  private : typedef cPtr_AC_machineDefinition inherited ;
  macroInheritFrom_AC_machineDefinition
  macro_C_xorComposition
  public : cPtr_C_xorComposition (const GGS_AC_machineDefinition & ,
                                const GGS_AC_machineDefinition & ) ;
  public : GGS_AC_machineDefinition  mLeftOperand ;
  public : GGS_AC_machineDefinition  mRightOperand ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_xorComposition'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_xorComposition {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_C_xorComposition * constructor_new (const GGS_AC_machineDefinition & argument_0,
                                const GGS_AC_machineDefinition & argument_1) ;
  #else
    public : inline static cPtr_C_xorComposition * constructor_new (const GGS_AC_machineDefinition & argument_0,
                                const GGS_AC_machineDefinition & argument_1) {
      return new cPtr_C_xorComposition(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_impliesComposition'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_C_impliesComposition

#define macroInheritFrom_C_impliesComposition

class cPtr_C_impliesComposition : public cPtr_AC_machineDefinition {
  private : typedef cPtr_AC_machineDefinition inherited ;
  macroInheritFrom_AC_machineDefinition
  macro_C_impliesComposition
  public : cPtr_C_impliesComposition (const GGS_AC_machineDefinition & ,
                                const GGS_AC_machineDefinition & ) ;
  public : GGS_AC_machineDefinition  mLeftOperand ;
  public : GGS_AC_machineDefinition  mRightOperand ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_impliesComposition'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_impliesComposition {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_C_impliesComposition * constructor_new (const GGS_AC_machineDefinition & argument_0,
                                const GGS_AC_machineDefinition & argument_1) ;
  #else
    public : inline static cPtr_C_impliesComposition * constructor_new (const GGS_AC_machineDefinition & argument_0,
                                const GGS_AC_machineDefinition & argument_1) {
      return new cPtr_C_impliesComposition(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_notComposition'                          *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_C_notComposition

#define macroInheritFrom_C_notComposition

class cPtr_C_notComposition : public cPtr_AC_machineDefinition {
  private : typedef cPtr_AC_machineDefinition inherited ;
  macroInheritFrom_AC_machineDefinition
  macro_C_notComposition
  public : cPtr_C_notComposition (const GGS_AC_machineDefinition & ) ;
  public : GGS_AC_machineDefinition  mOperand ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_notComposition'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_notComposition {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_C_notComposition * constructor_new (const GGS_AC_machineDefinition & argument_0) ;
  #else
    public : inline static cPtr_C_notComposition * constructor_new (const GGS_AC_machineDefinition & argument_0) {
      return new cPtr_C_notComposition(argument_0) ;
    }
  #endif
} ;

#include "include_AC_component.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'C_machineComponent'                         *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_C_machineComponent

#define macroInheritFrom_C_machineComponent

class cPtr_C_machineComponent : public cPtr_AC_component {
  private : typedef cPtr_AC_component inherited ;
  macroInheritFrom_AC_component
  macro_C_machineComponent
  public : cPtr_C_machineComponent (const GGS_uint & ,
                                const GGS_M_variablesMap & ,
                                const GGS_AC_machineDefinition & ) ;
  public : GGS_uint  mInputVariableCount ;
  public : GGS_M_variablesMap  mVariablesMap ;
  public : GGS_AC_machineDefinition  mDefinition ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_machineComponent'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_machineComponent {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_C_machineComponent * constructor_new (const GGS_uint & argument_0,
                                const GGS_M_variablesMap & argument_1,
                                const GGS_AC_machineDefinition & argument_2) ;
  #else
    public : inline static cPtr_C_machineComponent * constructor_new (const GGS_uint & argument_0,
                                const GGS_M_variablesMap & argument_1,
                                const GGS_AC_machineDefinition & argument_2) {
      return new cPtr_C_machineComponent(argument_0,
                                argument_1,
                                argument_2) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*

#endif
